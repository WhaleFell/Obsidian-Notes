<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>WhaleFall Obsidian Notes</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="Keep Notes everyday">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> 落落的Notes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="SUMMARY.html"><strong aria-hidden="true">1.1.</strong> SUMMARY</a></li><li class="chapter-item expanded "><a href="业余无线电Ham/index.html"><strong aria-hidden="true">1.2.</strong> 业余无线电Ham</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="业余无线电Ham/业余无线电采购.html"><strong aria-hidden="true">1.2.1.</strong> 业余无线电采购</a></li><li class="chapter-item expanded "><a href="业余无线电Ham/广播.html"><strong aria-hidden="true">1.2.2.</strong> 广播</a></li><li class="chapter-item expanded "><a href="业余无线电Ham/业余无线电笔记.html"><strong aria-hidden="true">1.2.3.</strong> 业余无线电笔记</a></li><li class="chapter-item expanded "><a href="业余无线电Ham/通联日志.html"><strong aria-hidden="true">1.2.4.</strong> 通联日志</a></li><li class="chapter-item expanded "><a href="业余无线电Ham/泉盛-K5-音质优化.html"><strong aria-hidden="true">1.2.5.</strong> 泉盛-K5-音质优化</a></li><li class="chapter-item expanded "><a href="业余无线电Ham/附近航空频率.html"><strong aria-hidden="true">1.2.6.</strong> 附近航空频率</a></li><li class="chapter-item expanded "><a href="业余无线电Ham/Opengd77-Firmware-教程.html"><strong aria-hidden="true">1.2.7.</strong> Opengd77-Firmware-教程</a></li><li class="chapter-item expanded "><a href="业余无线电Ham/广播/index.html"><strong aria-hidden="true">1.2.8.</strong> 广播</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="业余无线电Ham/广播/广播收听报告-2023.05.23.html"><strong aria-hidden="true">1.2.8.1.</strong> 广播收听报告-2023.05.23</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="碎碎念/index.html"><strong aria-hidden="true">1.3.</strong> 碎碎念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="碎碎念/记录.html"><strong aria-hidden="true">1.3.1.</strong> 记录</a></li><li class="chapter-item expanded "><a href="碎碎念/freedom.html"><strong aria-hidden="true">1.3.2.</strong> freedom</a></li><li class="chapter-item expanded "><a href="碎碎念/福芝talk.html"><strong aria-hidden="true">1.3.3.</strong> 福芝talk</a></li><li class="chapter-item expanded "><a href="碎碎念/文案.html"><strong aria-hidden="true">1.3.4.</strong> 文案</a></li><li class="chapter-item expanded "><a href="碎碎念/手机卡分销.html"><strong aria-hidden="true">1.3.5.</strong> 手机卡分销</a></li><li class="chapter-item expanded "><a href="碎碎念/知乎精选.html"><strong aria-hidden="true">1.3.6.</strong> 知乎精选</a></li><li class="chapter-item expanded "><a href="碎碎念/思源笔记本使用感想.html"><strong aria-hidden="true">1.3.7.</strong> 思源笔记本使用感想</a></li><li class="chapter-item expanded "><a href="碎碎念/猫猫.html"><strong aria-hidden="true">1.3.8.</strong> 猫猫</a></li><li class="chapter-item expanded "><a href="碎碎念/手机卡分销类型.html"><strong aria-hidden="true">1.3.9.</strong> 手机卡分销类型</a></li><li class="chapter-item expanded "><a href="碎碎念/闲鱼文案模板.html"><strong aria-hidden="true">1.3.10.</strong> 闲鱼文案模板</a></li><li class="chapter-item expanded "><a href="碎碎念/online-class.html"><strong aria-hidden="true">1.3.11.</strong> online-class</a></li><li class="chapter-item expanded "><a href="碎碎念/奇思妙想.html"><strong aria-hidden="true">1.3.12.</strong> 奇思妙想</a></li><li class="chapter-item expanded "><a href="碎碎念/猫猫/index.html"><strong aria-hidden="true">1.3.13.</strong> 猫猫</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="碎碎念/猫猫/多多.html"><strong aria-hidden="true">1.3.13.1.</strong> 多多</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="CutBoard/index.html"><strong aria-hidden="true">1.4.</strong> CutBoard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="CutBoard/无线电爬取脚本.html"><strong aria-hidden="true">1.4.1.</strong> 无线电爬取脚本</a></li></ol></li><li class="chapter-item expanded "><a href="other/index.html"><strong aria-hidden="true">1.5.</strong> other</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="other/OPENAI-KEY.html"><strong aria-hidden="true">1.5.1.</strong> OPENAI-KEY</a></li><li class="chapter-item expanded "><a href="other/未命名.html"><strong aria-hidden="true">1.5.2.</strong> 未命名</a></li><li class="chapter-item expanded "><a href="other/写给v友的一段话.html"><strong aria-hidden="true">1.5.3.</strong> 写给v友的一段话</a></li><li class="chapter-item expanded "><a href="other/模拟飞行.html"><strong aria-hidden="true">1.5.4.</strong> 模拟飞行</a></li></ol></li><li class="chapter-item expanded "><a href="Study/index.html"><strong aria-hidden="true">1.6.</strong> Study</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Study/Physical/index.html"><strong aria-hidden="true">1.6.1.</strong> Physical</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Study/Physical/第六讲.html"><strong aria-hidden="true">1.6.1.1.</strong> 第六讲</a></li><li class="chapter-item expanded "><a href="Study/Physical/第一讲-运动的描述.html"><strong aria-hidden="true">1.6.1.2.</strong> 第一讲-运动的描述</a></li><li class="chapter-item expanded "><a href="Study/Physical/第二讲-比例问题.html"><strong aria-hidden="true">1.6.1.3.</strong> 第二讲-比例问题</a></li><li class="chapter-item expanded "><a href="Study/Physical/第7讲.html"><strong aria-hidden="true">1.6.1.4.</strong> 第7讲</a></li><li class="chapter-item expanded "><a href="Study/Physical/第5讲-力的正交分解.html"><strong aria-hidden="true">1.6.1.5.</strong> 第5讲-力的正交分解</a></li></ol></li><li class="chapter-item expanded "><a href="Study/Chemistry/index.html"><strong aria-hidden="true">1.6.2.</strong> Chemistry</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Study/Chemistry/第一讲-离子反应的基础概念.html"><strong aria-hidden="true">1.6.2.1.</strong> 第一讲-离子反应的基础概念</a></li></ol></li><li class="chapter-item expanded "><a href="Study/Math/index.html"><strong aria-hidden="true">1.6.3.</strong> Math</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Study/Math/函数.html"><strong aria-hidden="true">1.6.3.1.</strong> 函数</a></li><li class="chapter-item expanded "><a href="Study/Math/第一讲-集合与常用逻辑用语.html"><strong aria-hidden="true">1.6.3.2.</strong> 第一讲-集合与常用逻辑用语</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="test/index.html"><strong aria-hidden="true">1.7.</strong> test</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="test/Obsidian-Hexo-模板测试.html"><strong aria-hidden="true">1.7.1.</strong> Obsidian-Hexo-模板测试</a></li><li class="chapter-item expanded "><a href="test/落落-OpenWRT-导航页.html"><strong aria-hidden="true">1.7.2.</strong> 落落-OpenWRT-导航页</a></li><li class="chapter-item expanded "><a href="test/思源笔记自动同步测试.html"><strong aria-hidden="true">1.7.3.</strong> 思源笔记自动同步测试</a></li></ol></li><li class="chapter-item expanded "><a href="English-Study/index.html"><strong aria-hidden="true">1.8.</strong> English-Study</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="English-Study/英语音标学习.html"><strong aria-hidden="true">1.8.1.</strong> 英语音标学习</a></li></ol></li><li class="chapter-item expanded "><a href="高中事件/index.html"><strong aria-hidden="true">1.9.</strong> 高中事件</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="高中事件/举报信.html"><strong aria-hidden="true">1.9.1.</strong> 举报信</a></li><li class="chapter-item expanded "><a href="高中事件/举报中小学教师违规方法论.html"><strong aria-hidden="true">1.9.2.</strong> 举报中小学教师违规方法论</a></li><li class="chapter-item expanded "><a href="高中事件/举报法律依据.html"><strong aria-hidden="true">1.9.3.</strong> 举报法律依据</a></li></ol></li><li class="chapter-item expanded "><a href="博客文章/index.html"><strong aria-hidden="true">1.10.</strong> 博客文章</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="博客文章/博客文章测试.html"><strong aria-hidden="true">1.10.1.</strong> 博客文章测试</a></li><li class="chapter-item expanded "><a href="博客文章/vscode-shortcut-key.html"><strong aria-hidden="true">1.10.2.</strong> vscode-shortcut-key</a></li><li class="chapter-item expanded "><a href="博客文章/博客文章_post.html"><strong aria-hidden="true">1.10.3.</strong> 博客文章_post</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/index.html"><strong aria-hidden="true">1.10.4.</strong> _posts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="博客文章/_posts/Rpi-1.html"><strong aria-hidden="true">1.10.4.1.</strong> Rpi-1</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/openwebrx-sdr.html"><strong aria-hidden="true">1.10.4.2.</strong> openwebrx-sdr</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Freedom-network.html"><strong aria-hidden="true">1.10.4.3.</strong> Freedom-network</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Samba4-config.html"><strong aria-hidden="true">1.10.4.4.</strong> Samba4-config</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Rpi-2.html"><strong aria-hidden="true">1.10.4.5.</strong> Rpi-2</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/onedrive-guide.html"><strong aria-hidden="true">1.10.4.6.</strong> onedrive-guide</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Github-workflow.html"><strong aria-hidden="true">1.10.4.7.</strong> Github-workflow</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/how-to-ues-free-ChatGPT-in-China.html"><strong aria-hidden="true">1.10.4.8.</strong> how-to-ues-free-ChatGPT-in-China</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Vim-config.html"><strong aria-hidden="true">1.10.4.9.</strong> Vim-config</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Hexo-blog-format.html"><strong aria-hidden="true">1.10.4.10.</strong> Hexo-blog-format</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/clash-proxy-guide.html"><strong aria-hidden="true">1.10.4.11.</strong> clash-proxy-guide</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/cpp-guide-book.html"><strong aria-hidden="true">1.10.4.12.</strong> cpp-guide-book</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Linux-note.html"><strong aria-hidden="true">1.10.4.13.</strong> Linux-note</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Kali-Linux-Help.html"><strong aria-hidden="true">1.10.4.14.</strong> Kali-Linux-Help</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Rpi-3.html"><strong aria-hidden="true">1.10.4.15.</strong> Rpi-3</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Wky-help.html"><strong aria-hidden="true">1.10.4.16.</strong> Wky-help</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Depression-medicine.html"><strong aria-hidden="true">1.10.4.17.</strong> Depression-medicine</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Linux-iptables.html"><strong aria-hidden="true">1.10.4.18.</strong> Linux-iptables</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/openwrt-lede-build-notes.html"><strong aria-hidden="true">1.10.4.19.</strong> openwrt-lede-build-notes</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Server-all.html"><strong aria-hidden="true">1.10.4.20.</strong> Server-all</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/radio-SWshort.html"><strong aria-hidden="true">1.10.4.21.</strong> radio-SWshort</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Python/index.html"><strong aria-hidden="true">1.10.4.22.</strong> Python</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="博客文章/_posts/Python/Python-async.html"><strong aria-hidden="true">1.10.4.22.1.</strong> Python-async</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Python/Python-Concurrent.html"><strong aria-hidden="true">1.10.4.22.2.</strong> Python-Concurrent</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Python/Python-Generator-Iterator-decorater.html"><strong aria-hidden="true">1.10.4.22.3.</strong> Python-Generator-Iterator-decorater</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Python/Python-database-ORM-tutorial.html"><strong aria-hidden="true">1.10.4.22.4.</strong> Python-database-ORM-tutorial</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Python/Python-Tkinter-GUI.html"><strong aria-hidden="true">1.10.4.22.5.</strong> Python-Tkinter-GUI</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Python/python-black-magic.html"><strong aria-hidden="true">1.10.4.22.6.</strong> python-black-magic</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Python/Flask-Web-note.html"><strong aria-hidden="true">1.10.4.22.7.</strong> Flask-Web-note</a></li></ol></li><li class="chapter-item expanded "><a href="博客文章/_posts/Golang/index.html"><strong aria-hidden="true">1.10.4.23.</strong> Golang</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="博客文章/_posts/Golang/Golang-package-note.html"><strong aria-hidden="true">1.10.4.23.1.</strong> Golang-package-note</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Golang/Golang-method-note.html"><strong aria-hidden="true">1.10.4.23.2.</strong> Golang-method-note</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Golang/Golang-interface-note.html"><strong aria-hidden="true">1.10.4.23.3.</strong> Golang-interface-note</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Golang/Golang-function-note.html"><strong aria-hidden="true">1.10.4.23.4.</strong> Golang-function-note</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Golang/Golang-JSON-note.html"><strong aria-hidden="true">1.10.4.23.5.</strong> Golang-JSON-note</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Golang/Golang-envbuild-note.html"><strong aria-hidden="true">1.10.4.23.6.</strong> Golang-envbuild-note</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Golang/Golang-struct-note.html"><strong aria-hidden="true">1.10.4.23.7.</strong> Golang-struct-note</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Golang/Golang-pointer-note.html"><strong aria-hidden="true">1.10.4.23.8.</strong> Golang-pointer-note</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Golang/Golang-error-note.html"><strong aria-hidden="true">1.10.4.23.9.</strong> Golang-error-note</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Golang/Golang-project-and-gomod-note.html"><strong aria-hidden="true">1.10.4.23.10.</strong> Golang-project-and-gomod-note</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Golang/Golang-variable-note.html"><strong aria-hidden="true">1.10.4.23.11.</strong> Golang-variable-note</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Golang/Golang-map-note.html"><strong aria-hidden="true">1.10.4.23.12.</strong> Golang-map-note</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Golang/Golang-const-note.html"><strong aria-hidden="true">1.10.4.23.13.</strong> Golang-const-note</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Golang/Golang-type-keyword-note.html"><strong aria-hidden="true">1.10.4.23.14.</strong> Golang-type-keyword-note</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Golang/Golang-goruntine-note.html"><strong aria-hidden="true">1.10.4.23.15.</strong> Golang-goruntine-note</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Golang/Golang-datatype-note.html"><strong aria-hidden="true">1.10.4.23.16.</strong> Golang-datatype-note</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Golang/Golang-id-note.html"><strong aria-hidden="true">1.10.4.23.17.</strong> Golang-id-note</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Golang/Golang-note-catalogue.html"><strong aria-hidden="true">1.10.4.23.18.</strong> Golang-note-catalogue</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Golang/Golang-HTML-note.html"><strong aria-hidden="true">1.10.4.23.19.</strong> Golang-HTML-note</a></li></ol></li><li class="chapter-item expanded "><a href="博客文章/_posts/JavaScript/index.html"><strong aria-hidden="true">1.10.4.24.</strong> JavaScript</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="博客文章/_posts/JavaScript/JavaScript-fast-start.html"><strong aria-hidden="true">1.10.4.24.1.</strong> JavaScript-fast-start</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/JavaScript/vue-guide.html"><strong aria-hidden="true">1.10.4.24.2.</strong> vue-guide</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/JavaScript/nodejs-fast-start.html"><strong aria-hidden="true">1.10.4.24.3.</strong> nodejs-fast-start</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/JavaScript/TypeScript-fast-start.html"><strong aria-hidden="true">1.10.4.24.4.</strong> TypeScript-fast-start</a></li></ol></li><li class="chapter-item expanded "><a href="博客文章/_posts/Study/index.html"><strong aria-hidden="true">1.10.4.25.</strong> Study</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="博客文章/_posts/Study/Zhongkao-maths.html"><strong aria-hidden="true">1.10.4.25.1.</strong> Zhongkao-maths</a></li><li class="chapter-item expanded "><a href="博客文章/_posts/Study/Ancient-poems.html"><strong aria-hidden="true">1.10.4.25.2.</strong> Ancient-poems</a></li></ol></li></ol></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">WhaleFall Obsidian Notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="落落的notes"><a class="header" href="#落落的notes">落落的Notes</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="落落的notes-1"><a class="header" href="#落落的notes-1">落落的Notes</a></h1>
<ul>
<li><a href="./README.html">落落的Notes</a>
<ul>
<li><a href="./SUMMARY.html">SUMMARY</a></li>
<li><a href="./%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5Ham/README.html">业余无线电Ham</a>
<ul>
<li><a href="./%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5Ham/%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5%E9%87%87%E8%B4%AD.html">业余无线电采购</a></li>
<li><a href="./%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5Ham/%E5%B9%BF%E6%92%AD.html">广播</a></li>
<li><a href="./%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5Ham/%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5%E7%AC%94%E8%AE%B0.html">业余无线电笔记</a></li>
<li><a href="./%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5Ham/%E9%80%9A%E8%81%94%E6%97%A5%E5%BF%97.html">通联日志</a></li>
<li><a href="./%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5Ham/%E6%B3%89%E7%9B%9B-K5-%E9%9F%B3%E8%B4%A8%E4%BC%98%E5%8C%96.html">泉盛-K5-音质优化</a></li>
<li><a href="./%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5Ham/%E9%99%84%E8%BF%91%E8%88%AA%E7%A9%BA%E9%A2%91%E7%8E%87.html">附近航空频率</a></li>
<li><a href="./%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5Ham/Opengd77-Firmware-%E6%95%99%E7%A8%8B.html">Opengd77-Firmware-教程</a></li>
<li><a href="./%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5Ham/%E5%B9%BF%E6%92%AD/README.html">广播</a>
<ul>
<li><a href="./%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5Ham/%E5%B9%BF%E6%92%AD/%E5%B9%BF%E6%92%AD%E6%94%B6%E5%90%AC%E6%8A%A5%E5%91%8A-2023.05.23.html">广播收听报告-2023.05.23</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="./%E7%A2%8E%E7%A2%8E%E5%BF%B5/README.html">碎碎念</a>
<ul>
<li><a href="./%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E8%AE%B0%E5%BD%95.html">记录</a></li>
<li><a href="./%E7%A2%8E%E7%A2%8E%E5%BF%B5/freedom.html">freedom</a></li>
<li><a href="./%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E7%A6%8F%E8%8A%9Dtalk.html">福芝talk</a></li>
<li><a href="./%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E6%96%87%E6%A1%88.html">文案</a></li>
<li><a href="./%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E6%89%8B%E6%9C%BA%E5%8D%A1%E5%88%86%E9%94%80.html">手机卡分销</a></li>
<li><a href="./%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E7%9F%A5%E4%B9%8E%E7%B2%BE%E9%80%89.html">知乎精选</a></li>
<li><a href="./%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%84%9F%E6%83%B3.html">思源笔记本使用感想</a></li>
<li><a href="./%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E7%8C%AB%E7%8C%AB.html">猫猫</a></li>
<li><a href="./%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E6%89%8B%E6%9C%BA%E5%8D%A1%E5%88%86%E9%94%80%E7%B1%BB%E5%9E%8B.html">手机卡分销类型</a></li>
<li><a href="./%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E9%97%B2%E9%B1%BC%E6%96%87%E6%A1%88%E6%A8%A1%E6%9D%BF.html">闲鱼文案模板</a></li>
<li><a href="./%E7%A2%8E%E7%A2%8E%E5%BF%B5/online-class.html">online-class</a></li>
<li><a href="./%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3.html">奇思妙想</a></li>
<li><a href="./%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E7%8C%AB%E7%8C%AB/README.html">猫猫</a>
<ul>
<li><a href="./%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E7%8C%AB%E7%8C%AB/%E5%A4%9A%E5%A4%9A.html">多多</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="./CutBoard/README.html">CutBoard</a>
<ul>
<li><a href="./CutBoard/%E6%97%A0%E7%BA%BF%E7%94%B5%E7%88%AC%E5%8F%96%E8%84%9A%E6%9C%AC.html">无线电爬取脚本</a></li>
</ul>
</li>
<li><a href="./other/README.html">other</a>
<ul>
<li><a href="./other/OPENAI-KEY.html">OPENAI-KEY</a></li>
<li><a href="./other/%E6%9C%AA%E5%91%BD%E5%90%8D.html">未命名</a></li>
<li><a href="./other/%E5%86%99%E7%BB%99v%E5%8F%8B%E7%9A%84%E4%B8%80%E6%AE%B5%E8%AF%9D.html">写给v友的一段话</a></li>
<li><a href="./other/%E6%A8%A1%E6%8B%9F%E9%A3%9E%E8%A1%8C.html">模拟飞行</a></li>
</ul>
</li>
<li><a href="./Study/README.html">Study</a>
<ul>
<li><a href="./Study/Physical/README.html">Physical</a>
<ul>
<li><a href="./Study/Physical/%E7%AC%AC%E5%85%AD%E8%AE%B2.html">第六讲</a></li>
<li><a href="./Study/Physical/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E8%BF%90%E5%8A%A8%E7%9A%84%E6%8F%8F%E8%BF%B0.html">第一讲-运动的描述</a></li>
<li><a href="./Study/Physical/%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E6%AF%94%E4%BE%8B%E9%97%AE%E9%A2%98.html">第二讲-比例问题</a></li>
<li><a href="./Study/Physical/%E7%AC%AC7%E8%AE%B2.html">第7讲</a></li>
<li><a href="./Study/Physical/%E7%AC%AC5%E8%AE%B2-%E5%8A%9B%E7%9A%84%E6%AD%A3%E4%BA%A4%E5%88%86%E8%A7%A3.html">第5讲-力的正交分解</a></li>
</ul>
</li>
<li><a href="./Study/Chemistry/README.html">Chemistry</a>
<ul>
<li><a href="./Study/Chemistry/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E7%A6%BB%E5%AD%90%E5%8F%8D%E5%BA%94%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5.html">第一讲-离子反应的基础概念</a></li>
</ul>
</li>
<li><a href="./Study/Math/README.html">Math</a>
<ul>
<li><a href="./Study/Math/%E5%87%BD%E6%95%B0.html">函数</a></li>
<li><a href="./Study/Math/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E9%9B%86%E5%90%88%E4%B8%8E%E5%B8%B8%E7%94%A8%E9%80%BB%E8%BE%91%E7%94%A8%E8%AF%AD.html">第一讲-集合与常用逻辑用语</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="./test/README.html">test</a>
<ul>
<li><a href="./test/Obsidian-Hexo-%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95.html">Obsidian-Hexo-模板测试</a></li>
<li><a href="./test/%E8%90%BD%E8%90%BD-OpenWRT-%E5%AF%BC%E8%88%AA%E9%A1%B5.html">落落-OpenWRT-导航页</a></li>
<li><a href="./test/%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0%E8%87%AA%E5%8A%A8%E5%90%8C%E6%AD%A5%E6%B5%8B%E8%AF%95.html">思源笔记自动同步测试</a></li>
</ul>
</li>
<li><a href="./English-Study/README.html">English-Study</a>
<ul>
<li><a href="./English-Study/%E8%8B%B1%E8%AF%AD%E9%9F%B3%E6%A0%87%E5%AD%A6%E4%B9%A0.html">英语音标学习</a></li>
</ul>
</li>
<li><a href="./%E9%AB%98%E4%B8%AD%E4%BA%8B%E4%BB%B6/README.html">高中事件</a>
<ul>
<li><a href="./%E9%AB%98%E4%B8%AD%E4%BA%8B%E4%BB%B6/%E4%B8%BE%E6%8A%A5%E4%BF%A1.html">举报信</a></li>
<li><a href="./%E9%AB%98%E4%B8%AD%E4%BA%8B%E4%BB%B6/%E4%B8%BE%E6%8A%A5%E4%B8%AD%E5%B0%8F%E5%AD%A6%E6%95%99%E5%B8%88%E8%BF%9D%E8%A7%84%E6%96%B9%E6%B3%95%E8%AE%BA.html">举报中小学教师违规方法论</a></li>
<li><a href="./%E9%AB%98%E4%B8%AD%E4%BA%8B%E4%BB%B6/%E4%B8%BE%E6%8A%A5%E6%B3%95%E5%BE%8B%E4%BE%9D%E6%8D%AE.html">举报法律依据</a></li>
</ul>
</li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/README.html">博客文章</a>
<ul>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%E6%B5%8B%E8%AF%95.html">博客文章测试</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/vscode-shortcut-key.html">vscode-shortcut-key</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0_post.html">博客文章_post</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/README.html">_posts</a>
<ul>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Rpi-1.html">Rpi-1</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/openwebrx-sdr.html">openwebrx-sdr</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Freedom-network.html">Freedom-network</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Samba4-config.html">Samba4-config</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Rpi-2.html">Rpi-2</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/onedrive-guide.html">onedrive-guide</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Github-workflow.html">Github-workflow</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/how-to-ues-free-ChatGPT-in-China.html">how-to-ues-free-ChatGPT-in-China</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Vim-config.html">Vim-config</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Hexo-blog-format.html">Hexo-blog-format</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/clash-proxy-guide.html">clash-proxy-guide</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/cpp-guide-book.html">cpp-guide-book</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Linux-note.html">Linux-note</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Kali-Linux-Help.html">Kali-Linux-Help</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Rpi-3.html">Rpi-3</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Wky-help.html">Wky-help</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Depression-medicine.html">Depression-medicine</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Linux-iptables.html">Linux-iptables</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/openwrt-lede-build-notes.html">openwrt-lede-build-notes</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Server-all.html">Server-all</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/radio-SWshort.html">radio-SWshort</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Python/README.html">Python</a>
<ul>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Python/Python-async.html">Python-async</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Python/Python-Concurrent.html">Python-Concurrent</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Python/Python-Generator-Iterator-decorater.html">Python-Generator-Iterator-decorater</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Python/Python-database-ORM-tutorial.html">Python-database-ORM-tutorial</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Python/Python-Tkinter-GUI.html">Python-Tkinter-GUI</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Python/python-black-magic.html">python-black-magic</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Python/Flask-Web-note.html">Flask-Web-note</a></li>
</ul>
</li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang/README.html">Golang</a>
<ul>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang/Golang-package-note.html">Golang-package-note</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang/Golang-method-note.html">Golang-method-note</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang/Golang-interface-note.html">Golang-interface-note</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang/Golang-function-note.html">Golang-function-note</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang/Golang-JSON-note.html">Golang-JSON-note</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang/Golang-envbuild-note.html">Golang-envbuild-note</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang/Golang-struct-note.html">Golang-struct-note</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang/Golang-pointer-note.html">Golang-pointer-note</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang/Golang-error-note.html">Golang-error-note</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang/Golang-project-and-gomod-note.html">Golang-project-and-gomod-note</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang/Golang-variable-note.html">Golang-variable-note</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang/Golang-map-note.html">Golang-map-note</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang/Golang-const-note.html">Golang-const-note</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang/Golang-type-keyword-note.html">Golang-type-keyword-note</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang/Golang-goruntine-note.html">Golang-goruntine-note</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang/Golang-datatype-note.html">Golang-datatype-note</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang/Golang-id-note.html">Golang-id-note</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang/Golang-note-catalogue.html">Golang-note-catalogue</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang/Golang-HTML-note.html">Golang-HTML-note</a></li>
</ul>
</li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/JavaScript/README.html">JavaScript</a>
<ul>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/JavaScript/JavaScript-fast-start.html">JavaScript-fast-start</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/JavaScript/vue-guide.html">vue-guide</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/JavaScript/nodejs-fast-start.html">nodejs-fast-start</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/JavaScript/TypeScript-fast-start.html">TypeScript-fast-start</a></li>
</ul>
</li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Study/README.html">Study</a>
<ul>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Study/Zhongkao-maths.html">Zhongkao-maths</a></li>
<li><a href="./%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Study/Ancient-poems.html">Ancient-poems</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="业余无线电ham"><a class="header" href="#业余无线电ham">业余无线电Ham</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="业余无线电采购"><a class="header" href="#业余无线电采购">业余无线电采购</a></h1>
<h2 id="想买的东西"><a class="header" href="#想买的东西">想买的东西</a></h2>
<ol>
<li>
<p>泉益通 KT8900 车台 25w，咸鱼参考价 250。即时通 D9000 车台 1200。</p>
</li>
<li>
<p><del>短波漆包线收音机天线。</del> 漆包线太硬了，可塑性差。线太长反而引入干扰信号。</p>
</li>
<li>
<p><del>UV 380 可以刷 opengd77 的手台，支持数模，宝峰 1801 平替</del></p>
<p>已购买 宝峰 1701B UV 双段 drm 手台，淘宝 350 全新。2023-5-30</p>
<blockquote>
<p>研究一下特易通 TYT MD-760 蹲,MD-730 这两款支持 DMR 模式的数字手台，也支持 opengd77</p>
<p>md1801</p>
<p>md390 md380 蹲</p>
<p>宝峰 1801</p>
</blockquote>
</li>
</ol>
<p>‍</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="广播"><a class="header" href="#广播">广播</a></h1>
<p>记录广播收听日志</p>
<p>频率表：<a href="https://blog.xmgspace.me/archives/international-shortwave-to-cn.html">blog.xmgspace.me/archive...</a></p>
<h2 id="自由亚洲电台"><a class="header" href="#自由亚洲电台">自由亚洲电台</a></h2>
<p>在线直播流：<a href="https://rfa-ingest.akamaized.net/hls/live/2040699/RFA_AUDIO_LIVE1/master.m3u8">https://rfa-ingest.akamaized.net/hls/live/2040699/RFA_AUDIO_LIVE1/master.m3u8</a></p>
<p>‍</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="业余无线电笔记"><a class="header" href="#业余无线电笔记">业余无线电笔记</a></h1>
<h2 id="梅登黑德坐标系统"><a class="header" href="#梅登黑德坐标系统">梅登黑德坐标系统</a></h2>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E6%A2%85%E7%99%BB%E9%BB%91%E5%BE%B7%E5%AE%9A%E4%BD%8D%E7%B3%BB%E7%BB%9F">梅登黑德坐标系统 Wikipedia</a></p>
<p><strong>梅登黑德定位系统</strong>（英语：<strong>Maidenhead Locator System</strong>）是以经纬度作为基准线，将地球分为若干网格，以实现精确报告自己位置的系统。该系统只需 4-6 个字符就可报出误差不超过 10km 的地球上任何地点。报出字符越长，精度越高。梅登黑德网格由大到小依次将地球分为“场”(field)、“方”(square)、“块”(subsquare)。</p>
<p>粗略的网格位置可用 4 个字符表示，如 <a href="https://zh.wikipedia.org/wiki/%E4%B8%8A%E6%B5%B7%E5%B8%82" title="上海市">上海</a> 为“PM01”；比较精确的网格位置，则 可用 6 个字符表示，如 <a href="https://zh.wikipedia.org/wiki/%E5%8C%97%E4%BA%AC%E5%B8%82" title="北京市">北京</a> 为“OM89EV”。在 <a href="https://zh.wikipedia.org/wiki/%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5" title="业余无线电">业余无线电</a> 通讯中，一般只报告 4 位字符即可。</p>
<p><a href="http://sjzham.cn/grid/">Maidenhead 在线查询</a> LO63MA</p>
</blockquote>
<p>​<img src="%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5Ham/assets/image-20230524234651-mz1bmo9.png" alt="image" />​</p>
<h2 id="珠三角无线电中继"><a class="header" href="#珠三角无线电中继">珠三角无线电中继</a></h2>
<blockquote>
<p>数据来源：<a href="http://weixin.cqcqcq.cn/index.php?m=radio&amp;c=map&amp;a=citylist&amp;province_id=6">http://weixin.cqcqcq.cn/index.php?m=radio&amp;c=map&amp;a=citylist&amp;province_id=6</a></p>
<p>在 广东佛山（112，23）LO63MA 处测试</p>
</blockquote>
<p><strong><u><em>TFTC</em></u></strong>（Too far to connect）：表示测试点距离中继太远无法连接，但是可以听见中继下行，判断出中继正常运行。</p>
<p><em><strong><u>IVL</u></strong></em>（invalid）：中继暂时失效，曾经正常使用过。</p>
<h6 id="佛山"><a class="header" href="#佛山">佛山</a></h6>
<ol>
<li>
<ul>
<li>佛山 1 (FS1 650),439.65,-5(下差),434.65,模拟发射亚音 88.5</li>
</ul>
</li>
<li>
<ul>
<li>佛山 2 西樵 (FS2 125),439.125,-5.015(下差),434.11,模拟发射亚音 88.5</li>
</ul>
</li>
<li>
<ul>
<li>佛山 3 (FS3 900),439.9,-5(下差),434.9,模拟发射亚音 88.5</li>
</ul>
</li>
<li>
<ul>
<li>佛山 BR7IAB (FS4 680),439.68,-5(下差),434.68,数字发射和接收亚音 73</li>
</ul>
</li>
<li>佛山禅城 <em><strong><u>IVL ​</u></strong></em>(FSCZ 315),439.315,-8(下差),431.315,模拟发射和接收亚音 88.5</li>
<li>
<ul>
<li>高明 (GM 830),438.83,-5(下差),433.83,模拟发射亚音 88.5</li>
</ul>
</li>
<li>
<ul>
<li>顺德 (SD 700)438.7,-5(下差),433.7,模拟发射亚音 88.5</li>
</ul>
</li>
<li>
<ul>
<li>顺德 (SD 600),439.6,-5(下差),434.6,模拟发射亚音 88.5</li>
</ul>
</li>
<li>
<ul>
<li>顺德 (SD 300),439.3,-5(下差),434.3,模拟发射亚音 88.5</li>
</ul>
</li>
<li>
<ul>
<li>顺德 BR7IAN (SD IAN),439.97,-5(下差),434.97,模拟发射亚音 88.5</li>
</ul>
</li>
</ol>
<p><strong>链路中继：</strong></p>
<ol>
<li>
<ul>
<li>狮山 (SS 615),438.615,-6(下差),432.615,模拟发射亚音 88.5</li>
</ul>
</li>
<li>
<ul>
<li>中山南头 (ZSNT),438.735,-6.45(下差),432.285,模拟发射亚音 88.5</li>
</ul>
</li>
<li>东莞桥头 <strong><u><em>TFTC ​</em></u></strong>(DGQT),439.75,-6(下差),433.75,模拟发射亚音 94.8</li>
<li>
<ul>
<li>中山火炬实验 A <strong><u><em>TFTC ​</em></u></strong>(ZSHJ A),439.9375,-8(下差),431.9375,模拟发射亚音 88.5</li>
</ul>
</li>
<li>
<ul>
<li>南昆山 (NKS 175),439.175,-8(下差),431.175,模拟发射和接收亚音 97.4</li>
</ul>
</li>
<li>
<ul>
<li>博罗龙溪 (BLLX 520),439.52,-5(下差),434.52,模拟发射和接收亚音 88.5</li>
</ul>
</li>
</ol>
<h6 id="广州"><a class="header" href="#广州">广州</a></h6>
<ol>
<li>
<ul>
<li>越秀 (GZYX 765),439.765,-8.055(下差),431.71,模拟发射亚音 103.5</li>
</ul>
</li>
<li>广州,439.35,-5(下差),434.35,模拟发射亚音 88.5</li>
</ol>
<h6 id="深圳"><a class="header" href="#深圳">深圳</a></h6>
<ol>
<li>
<ul>
<li>梧桐山中继 (SZWTS 460),439.460,-5(下差),434.460,模拟发射和接收亚音 88.5</li>
</ul>
</li>
</ol>
<h6 id="江门爱好者"><a class="header" href="#江门爱好者">江门爱好者</a></h6>
<blockquote>
<p>中继更新频率 438.425 -7.05M{即 431.375 ）收发哑音 88.5。DMR 参数色 1，时隙 1，全呼，顺德大良中继（链路）437.400 -7M，收发哑音 97.4 同步滔滔房间 143278.南山 531029.顺德中继 439.425 一 9M，收发哑音 110.9 。</p>
</blockquote>
<blockquote>
<p>cq cq cq，这里是中山市业余无线电阜沙大队应急通讯电台。频率 437.4375 下差 6.8:，发射亚音 88.5:， 同步滔滔链路 256657。欢迎广大 HAM 友上台通联，靓靓 73 送上。</p>
</blockquote>
<ol>
<li>
<ul>
<li>江门 Ham (JM 425),438.425,-7.05,431.375,收发哑音 88.5 DMR 色 1 时隙 1 全呼</li>
</ul>
</li>
<li>
<ul>
<li>顺德&lt;-&gt;江门 (SD T JM), 439.425,-9,430.425,收发哑音 110.9</li>
</ul>
</li>
</ol>
<h6 id="order"><a class="header" href="#order">Order</a></h6>
<ol>
<li>
<ul>
<li>珠海斗门 (ZHDM 690),436.690,-6.5,430.190,亚音 71.9</li>
</ul>
</li>
<li>
<ul>
<li>江门新会 (JMXH),437.4,-7,430.4,亚音 88.5</li>
</ul>
</li>
<li>
<ul>
<li>东莞 (DG 850),439.85,-5,434.85,亚音 118.8</li>
</ul>
</li>
<li>
<ul>
<li>中山小榄 (ZSXN),438.3625,-5,433.3625,收发亚音 88.5</li>
</ul>
</li>
<li>
<ul>
<li>江门鹤山 (JMKS 900),439.900,-5,434.900,亚音 88.5</li>
</ul>
</li>
</ol>
<h6 id="ba7mcg-两年前自己整理"><a class="header" href="#ba7mcg-两年前自己整理">ba7mcg 两年前自己整理</a></h6>
<p>​<img src="%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5Ham/assets/Radio-relay-list-20230528231921-g5ger0h.jpg" alt="mmexport1685253427673" />​</p>
<h2 id="业余卫星通联"><a class="header" href="#业余卫星通联">业余卫星通联</a></h2>
<p>ISS</p>
<p>SO-50</p>
<p>AO-91</p>
<p>AO-92</p>
<p>AO-27</p>
<p>PO-101</p>
<pre><code class="language-csv">
Catalogue number,Display name,Rx,Tx,CTCSS,ArmCTCSS
22825U,AO27,436795000,145850000,0,0
43017U,AO91,145960000,435250000,670,0
43137U,AO92,145880000,435350000,670,0
40908U,CAS3H,437200000,144350000,0,0
40931U,IO86,435880000,145880000,885,0
43678U,PO101,145900000,437500000,1413,0
25544U,ISS,437800000,145990000,670,0
27607U,SO50,436795000,145850000,670,744
54684U,FO118,435600000,145925000,670,0
</code></pre>
<h3 id="opengd77配置自定义卫星satellitestxt"><a class="header" href="#opengd77配置自定义卫星satellitestxt"><a href="http://dtrac.cn/viewtopic.php?t=41&amp;sid=54409a4d776d1ea34bbe03a01d10a31f">OpenGD77配置自定义卫星satellites.txt</a></a></h3>
<p><a href="http://dtrac.cn/viewtopic.php?t=41">http://dtrac.cn/viewtopic.php?t=41</a></p>
<p>在文件 satellites.txt 中定义卫星，导入和上传到电台，该文件随 CPS 安装到其安装目录中。该文件是标准格式的 CSV 文件，包含卫星目录号，以及无线电中的显示名称，以及 Tx、Rx 频率和 Tx CTCSS 以及使用“Arming”的卫星的“Arming”CTCSS “ 信令。操作员可以根据需要编辑此文件以添加或删除卫星。可加载到电台的最大卫星数量为 15 颗。下面提供集成 CSS（中国空间站）的参数，解压缩后将 satellites.txt 覆盖到 CPS 安装目录。</p>
<pre><code class="language-csv">Catalogue number,Display name,Rx,Tx,CTCSS,ArmCTCSS
22825U,AO27,436795000,145850000,0,0
43017U,AO91,145960000,435250000,670,0
43137U,AO92,145880000,435350000,670,0
40908U,CAS3H,437200000,144350000,0,0
40931U,IO86,435880000,145880000,885,0
43678U,PO101,145900000,437500000,1413,0
25544U,ISS,437800000,145990000,670,0
25544U,ISS SSTV,145800000,0,0,0
27607U,SO50,436795000,145850000,670,744
54684U,FO118,435600000,145925000,670,0
25338U,NOAA 15,137500000,0,0,0
28654U,NOAA 18,137912500,0,0,0
33591U,NOAA 19,137100000,0,0,0
</code></pre>
<p><a href="https://www.celestrak.com/NORAD/elements/amateur.txt">https://www.celestrak.com/NORAD/elements/amateur.txt</a></p>
<p><a href="http://www.dtrac.cn/download/active">http://www.dtrac.cn/download/active</a></p>
<p>卫星论坛：</p>
<p><a href="http://dtrac.cn/viewtopic.php?t=41">http://dtrac.cn/viewtopic.php?t=41</a></p>
<h2 id="bg1ica"><a class="header" href="#bg1ica">BG1ICA</a></h2>
<p>业余无线电 SDR 方面的博主</p>
<p><a href="https://www.bilibili.com/video/BV1Es4y1q75j/?spm_id_from=333.999.0.0&amp;vd_source=8b588c19ea4cd636da362bae86b1564a">https://www.bilibili.com/video/BV1Es4y1q75j/?spm_id_from=333.999.0.0&amp;vd_source=8b588c19ea4cd636da362bae86b1564a</a></p>
<p><a href="https://pan.baidu.com/s/1XG0oxSwknUvNt8WO5vHf7Q?pwd=74u6#list/path=%2F">https://pan.baidu.com/s/1XG0oxSwknUvNt8WO5vHf7Q?pwd=74u6#list/path=%2F</a></p>
<h2 id="各国免执照频率vhf-海事频道一览"><a class="header" href="#各国免执照频率vhf-海事频道一览">各国免执照频率&amp;VHF 海事频道一览</a></h2>
<p><a href="https://blog.zqlucifer.com/archives/978">https://blog.zqlucifer.com/archives/978</a></p>
<p>‍</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="通联日志"><a class="header" href="#通联日志">通联日志</a></h1>
<blockquote>
<p>请规范记录通联日志，统一 CSV 文件头格式：</p>
<p><strong>日期,通联频率,对方呼号,对方 QTH,我方信号报告,对方信号报告</strong></p>
<p>时间统一使用 UTC+8 （北京时间）24 小时制</p>
<p>例如：</p>
<p><strong>2023-05-26#23:52,439.6 贵港中继,贵港,BG7RLY,58,56</strong></p>
</blockquote>
<hr />
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">日期</th><th style="text-align: center">通联频率</th><th style="text-align: center">对方呼号</th><th style="text-align: center">对方 QTH</th><th style="text-align: center">我方信号报告</th><th style="text-align: center">对方信号报告</th><th style="text-align: center">备注</th></tr></thead><tbody>
<tr><td style="text-align: center">2023-05-26#23:52</td><td style="text-align: center">439.6 贵港中继</td><td style="text-align: center">BG7RLY</td><td style="text-align: center">广西大链路过来</td><td style="text-align: center">58</td><td style="text-align: center">56</td><td style="text-align: center"></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th style="text-align: center">日期</th><th style="text-align: center">通联频率</th><th style="text-align: center">对方呼号</th><th style="text-align: center">对方 QTH</th><th style="text-align: center">我方信号报告</th><th style="text-align: center">对方信号报告</th><th style="text-align: center">备注</th></tr></thead><tbody>
<tr><td style="text-align: center">2023-06-01#19:57</td><td style="text-align: center">439.68 佛山 BR7IAB</td><td style="text-align: center">BG7JJ</td><td style="text-align: center">魁奇路</td><td style="text-align: center">59</td><td style="text-align: center">59</td><td style="text-align: center">使用设备 5w 手台 YR88GG</td></tr>
</tbody></table>
</div>
<p>bd7kdw 江门中继 ba7nms 830 jsp ba7myt</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">日期</th><th style="text-align: center">通联频率</th><th style="text-align: center">对方呼号</th><th style="text-align: center">对方 QTH</th><th style="text-align: center">我方信号报告</th><th style="text-align: center">对方信号报告</th><th style="text-align: center">备注</th></tr></thead><tbody>
<tr><td style="text-align: center">2023-06-04#13:24</td><td style="text-align: center">437.400 顺德大良 007 中继</td><td style="text-align: center">BA7NDS</td><td style="text-align: center">广州天河</td><td style="text-align: center">59</td><td style="text-align: center">59</td><td style="text-align: center">007 中继链路江门 425 中继</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th style="text-align: center">日期</th><th style="text-align: center">通联频率</th><th style="text-align: center">对方呼号</th><th style="text-align: center">对方 QTH</th><th style="text-align: center">我方信号报告</th><th style="text-align: center">对方信号报告</th><th style="text-align: center">备注</th></tr></thead><tbody>
<tr><td style="text-align: center">2023-06-06#13:32</td><td style="text-align: center">438.425 江门中继</td><td style="text-align: center">BH7NTT</td><td style="text-align: center">南海里水</td><td style="text-align: center">59</td><td style="text-align: center">59</td><td style="text-align: center">对方使用南山对讲</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th style="text-align: center">日期</th><th style="text-align: center">通联频率</th><th style="text-align: center">对方呼号</th><th style="text-align: center">对方 QTH</th><th style="text-align: center">我方信号报告</th><th style="text-align: center">对方信号报告</th><th style="text-align: center">备注</th></tr></thead><tbody>
<tr><td style="text-align: center">2023-06-06#22:47</td><td style="text-align: center">438.520 花都兄弟中继</td><td style="text-align: center">bd7icy 花都 181<br /></td><td style="text-align: center">花都</td><td style="text-align: center">58</td><td style="text-align: center">59</td><td style="text-align: center"></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th style="text-align: center">日期</th><th style="text-align: center">通联频率</th><th style="text-align: center">对方呼号</th><th style="text-align: center">对方 QTH</th><th style="text-align: center">我方信号报告</th><th style="text-align: center">对方信号报告</th><th style="text-align: center">备注</th></tr></thead><tbody>
<tr><td style="text-align: center">2023-06-11#20:13</td><td style="text-align: center">438.5 直频</td><td style="text-align: center">BD7ZRP</td><td style="text-align: center">广州海珠区</td><td style="text-align: center">59</td><td style="text-align: center">58</td><td style="text-align: center">直线距离 23km 我在 32 楼楼顶</td></tr>
</tbody></table>
</div>
<p>上一个通联我认识到了宝峰 1701 的劣势。</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">日期</th><th style="text-align: center">通联频率</th><th style="text-align: center">对方呼号</th><th style="text-align: center">对方 QTH</th><th style="text-align: center">我方信号报告</th><th style="text-align: center">对方信号报告</th><th style="text-align: center">备注</th></tr></thead><tbody>
<tr><td style="text-align: center">2023-06-11#20:26</td><td style="text-align: center">438.425 江门中继</td><td style="text-align: center">BA7NFS</td><td style="text-align: center">中山什么海</td><td style="text-align: center">58</td><td style="text-align: center">59</td><td style="text-align: center">对比了宝峰 dm1701</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th style="text-align: center">日期</th><th style="text-align: center">通联频率</th><th style="text-align: center">对方呼号</th><th style="text-align: center">对方 QTH</th><th style="text-align: center">我方信号报告</th><th style="text-align: center">对方信号报告</th><th style="text-align: center">备注</th></tr></thead><tbody>
<tr><td style="text-align: center">2023-07-23#21:43</td><td style="text-align: center">438.5</td><td style="text-align: center">BA7MYW</td><td style="text-align: center">顺德陈村</td><td style="text-align: center">59</td><td style="text-align: center">58</td><td style="text-align: center">在玖龙湾48w发射，对方5w手台</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th style="text-align: center">日期</th><th style="text-align: center">通联频率</th><th style="text-align: center">对方呼号</th><th style="text-align: center">对方 QTH</th><th style="text-align: center">我方信号报告</th><th style="text-align: center">对方信号报告</th><th style="text-align: center">备注</th></tr></thead><tbody>
<tr><td style="text-align: center">2023-07-23#22:15</td><td style="text-align: center">438.5</td><td style="text-align: center">BI4aop</td><td style="text-align: center">九江镇</td><td style="text-align: center">59</td><td style="text-align: center">59</td><td style="text-align: center"></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="泉盛-k5-音质优化"><a class="header" href="#泉盛-k5-音质优化">泉盛 K5 音质优化</a></h1>
<h2 id="资料"><a class="header" href="#资料">资料</a></h2>
<p>一句话经验: 不用换喇叭，把​K​5 的音频功放（LN4890，SOP8 封装）的负反馈电阻，也就是在功放 IC 上部标注“184”的电阻，直接在它上面并联一个 0603 的 1nf 电容，效果就有明显改善。实测音质不输建伍 G71 手台。如果在功放的输入电容上再并联一只 1UF 电容，效果更佳。​</p>
<h2 id="方法"><a class="header" href="#方法">方法</a></h2>
<p>在 184 电阻上并联 1nF（102）电容。在他右侧的小电容上并联 1uF（105）电容。这个板子上的电容是 0402 封装的，并联 0603 电容时两侧多加点锡即可。</p>
<p><img src="%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5Ham/assets/caz5h.jpg" alt="k5音频改造方案" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附近航空频率"><a class="header" href="#附近航空频率">附近航空频率</a></h1>
<p>127.550 强台 香港赤腊角国际机场 VHHH/HKG<br />
127.950 强台 珠海金湾机场 (原三灶) ZGSD<br />
123.475<br />
127.100 HK<br />
125.350 强台 广州白云国际机场 ZGGG<br />
124.200<br />
123.475<br />
124.450<br />
128.300 强台<br />
126.300<br />
120.400 广州进近 飞机降落的时候</p>
<h2 id="珠三角能收到的航空频率"><a class="header" href="#珠三角能收到的航空频率">珠三角能收到的航空频率</a></h2>
<p>118.1       白云塔台<br />
118.8       白云塔台<br />
118.95     广州区调（7200m 以上）<br />
119.1       香港进近<br />
119.35     香港进近<br />
119.6       广州进近（进场）<br />
119.7       广州进近<br />
120.35     珠海进近<br />
120.4       广州进近<br />
120.75     广州区调（7200m 以下）<br />
120.95     广州区调<br />
121.05     广州进近<br />
121.5       应急频率<br />
121.6       白云放行频率<br />
121.75     白云地面<br />
121.85     白云地面<br />
121.95     白云放行频率<br />
124.25     珠海进近<br />
125.35     广州区调<br />
126.1       广州区调<br />
126.35     广州进近<br />
126.4       澳门机场 ATIS 情报通播<br />
126.55     广州进近<br />
127.0       白云机场 D-ATIS<br />
127.05     香港 D-ATIS<br />
127.1       香港雷达<br />
127.45     深圳机场 ATIS<br />
127.75     广州进近<br />
128.2       香港 A-ATIS<br />
128.35     广州区调<br />
128.6       白云机场 A-ATIS<br />
128.875   香港 VOLMET<br />
131.45     广州 ACARS<br />
131.55     香港 ACARS<br />
132.35     湛江进近、广州区调（西）<br />
133.85     上海区调<br />
HF:（如无注明均为 USB 模式）<br />
广州 FIR: 3.491 (下午）; 6.556 ; 10.066 (上午，广州、南宁、桂林） ; 3.016 （下午）; 6.571 ; 8.897（上午，长沙）<br />
香港 Radio: 3.455 ; 5.655 ; 8.942 ; 11.297 ; 13.309<br />
广州 VOLMET：3.458 ; 5.673（工作时间：8:00am – 4:00pm） ; 8.849 ; 13.285（工作时间：4:00pm – 11:45pm）<br />
香港 VOLMET：8.828（H:10 – H:15 为 VFR，H:15 – H:20 为 IFR）<br />
导航台:<br />
VOR:<br />
108.6            TAN            源潭<br />
112.0            GLN           观澜<br />
113.0            CON           从化<br />
114.1            POU           平洲<br />
114.6            CEN            岑村<br />
115.9            SHK            蛇口<br />
117.7            NLG            南朗<br />
NDB（单位 KHz）<br />
353               XK              平洲<br />
328               不明            石龙<br />
410               FO<br />
418<br />
455</p>
<h2 id="广州白云国际机场"><a class="header" href="#广州白云国际机场">广州白云国际机场</a></h2>
<p><strong>广州新白云机场（ZGGG）</strong></p>
<p>广州区调 A 120.4M B 126.35M C 119.6M C 119.7M</p>
<p>行情通播 128.6M</p>
<p>CLD 121.95M</p>
<p>地面频率 A 121.75M B 121.85M C 121.6M</p>
<p>塔台频率 A 118.1M B 118.8M C 124.3M</p>
<p><strong>ZGGG/CAN 广州白云国际机场</strong></p>
<p>情报通播 Departure ZGGG 127.00</p>
<p>情报通播 ZGGG 128.60</p>
<p>白云放行 BAIYUN Delivery 121.95 ZGGG_DEL</p>
<p>白云地面 BAIYUN Ground 121.85 ZGGG_GND Rwy 02L/20R</p>
<p>白云地面 BAIYUN Ground 121.75 ZGGG_GND Rwy 02R/2OL</p>
<p>白云塔台 BAIYUN Tower 118.80 ZGGG_TWR Rwy 02L/20R</p>
<p>白云塔台 BAIYUN Tower 118.10 ZGGG_TWR Rwy 02R/20L</p>
<p>广州进近 GUANGZHOU Approach 120.40 ZGGG_APP</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="opengd77-firmware-教程"><a class="header" href="#opengd77-firmware-教程">Opengd77 Firmware 教程</a></h1>
<p>教程中文文档：<a href="https://github.com/LibreDMR/OpenGD77_UserGuide/blob/master/OpenGD77_User_Guide_CN.md">guthub</a></p>
<h2 id="flush-刷入"><a class="header" href="#flush-刷入">Flush 刷入</a></h2>
<p>​<img src="%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5Ham/assets/Screenshot_2023-05-30-20-30-34-373_com.bilibili.app.in-20230530211800-jhosuqo.jpg" alt="Screenshot_2023-05-30-20-30-34-373_com.bilibili.app.in" />​</p>
<p>​<img src="%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5Ham/assets/Screenshot_2023-05-30-20-31-27-584_com.bilibili.app.in-20230530211800-jxa3r3g.jpg" alt="Screenshot_2023-05-30-20-31-27-584_com.bilibili.app.in" /><br />
​<img src="%E4%B8%9A%E4%BD%99%E6%97%A0%E7%BA%BF%E7%94%B5Ham/assets/Screenshot_2023-05-30-20-31-33-917_com.bilibili.app.in-20230530211800-vofbzv9.jpg" alt="Screenshot_2023-05-30-20-31-33-917_com.bilibili.app.in" />​</p>
<p>‍</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="广播-1"><a class="header" href="#广播-1">广播</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="广播收听报告-20230523"><a class="header" href="#广播收听报告-20230523">广播收听报告 2023.05.23</a></h1>
<h2 id="希望之声"><a class="header" href="#希望之声">希望之声</a></h2>
<p>17:41 15890 颖慧广播电台</p>
<p>‍</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="碎碎念"><a class="header" href="#碎碎念">碎碎念</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="记录"><a class="header" href="#记录">记录</a></h1>
<p>江门无线电群的小号 425 6502</p>
<p>​<img src="%E7%A2%8E%E7%A2%8E%E5%BF%B5/assets/mmexport1685439410257-20230530213650-9efvnah.jpg" alt="mmexport1685439410257" />​</p>
<p>cyx 的家定位</p>
<p>​<img src="%E7%A2%8E%E7%A2%8E%E5%BF%B5/assets/Screenshot_2023-05-28-00-33-10-309_com.tencent.mobileqq-20230530213752-8um0nw3.jpg" alt="Screenshot_2023-05-28-00-33-10-309_com.tencent.mobileqq" />​</p>
<p>闲鱼文案：</p>
<p>自用 8 成新跑步机，</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="where-to-say"><a class="header" href="#where-to-say">Where-to-say</a></h1>
<p><a href="https://github.com/hello-world-1989/where-to-say">https://github.com/hello-world-1989/where-to-say</a></p>
<p>爆料渠道，发声渠道</p>
<p>请告诉时间、地点、人物、事件、原因等具体内容。欢迎分享照片、音频或视频</p>
<p>美国自由亚洲电台 <a href="mailto:contact@rfa.org">contact@rfa.org</a></p>
<p>美国纽约时报 <a href="mailto:cn.letters@nytimes.com">cn.letters@nytimes.com</a></p>
<p>美国之音 <a href="mailto:chinese@voanews.com">chinese@voanews.com</a></p>
<p>英国广播公司 <a href="mailto:tougao@bbc.co.uk">tougao@bbc.co.uk</a></p>
<p>德国之声 <a href="mailto:info@dw.com">info@dw.com</a></p>
<p>李老师不是你老师 twitter <a href="https://twitter.com/whyyoutouzhele">https://twitter.com/whyyoutouzhele</a></p>
<p>如果无法发送，可以发送到 <a href="mailto:free.vpn.list@hotmail.com">我的邮箱</a>，将代为发送到您指定的媒体</p>
<h2 id="free-vpn"><a class="header" href="#free-vpn">Free VPN</a></h2>
<p><a href="https://www.vpngate.net/cn/">https://www.vpngate.net/cn/</a></p>
<p>v2ray scribeurl：<a href="https://justmysocks3.net/members/getsub.php?service=81247&amp;id=18fd2458-9ecb-4394-875c-e2353fbdfbfc">https://justmysocks3.net/members/getsub.php?service=81247&amp;id=18fd2458-9ecb-4394-875c-e2353fbdfbfc</a></p>
<p>‍</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="福芝-talk"><a class="header" href="#福芝-talk">福芝 talk</a></h1>
<p>与桂雯丽妈妈——福芝的 talking</p>
<pre><code class="language-text">家乐上午好  
今天晚上6-8:30有时间吗？

第一找你看下电脑，讨论一下我怎么突破关口  

第二，我们既然可以成为朋友，有困难互相帮助对吗？  

我现在面临2个大难题  
1、我的脑袋不定时头晕，开车时发生过一次，时间持续了3-5分钟  

在外发生过相对严重的三次:时间5-10分钟  
基于以上我做了全面CT检查，大脑🧠没有问题，脊椎5-7节有变异，吃中药调理了一年，身体护理好几年了，但是都只是暂时缓解，不能根除，现在找一个针灸的医生，说可以根除，她现在回了老家，要8月1号，才回……  

所以，我基本减少了外出的时间

第二，工作上的大难题，好像进入了一个知识和专业大漩涡，无法自拔……“想着道理其实好简单”人人都懂，但，要改变一个人的认知和思维，好难呀……!

你上次给我说的话，一直在我脑袋里转，最难是拟定大纲……我想法太多，总结力太差!所以，你给我的GPT软件可以帮很大的忙，但细节还是靠自己想……不过非常感恩你，认识你真的非常荣幸! 

家乐，我想同你说，只要是人，都有各种各样不易和烦恼，但，每个人都无法身同感受到另一个人的处境和难处，可是，同可以理解你的人，说出你的困难时，最起码他是能理解你的，会站在你的角度上思考……也许不说一个字，你也可以接收到力量……度过眼下的困难……不知道你是否同意这个说法？  
  
  
家乐，我知道你现在面临着人生的最大的一个坎，迈过去，前面就是阳光大道等着你，任你奔跑、任你开辟……  
  
家乐，这个坎对你来说真的有点点难，但，不是很难……因为，很难的时候你已过去了……如果你愿意信任我，我一定可以助你一臂之力的，协助你垮过这个坎，我也1万%的相信你有这个实力去战胜这一切的，因为现在的你已经不是原来的那个你了……，现在是步入成年顶天立地的男子汉……是真的，只是你自己没有发现而已……  
  
家乐，有些话我想当面同你说，我们一起争论，一起畅聊人生，这种场景每次想起非常开心和快乐，你是否愿意给我这个机会呢……
  
家乐，还有要告诉你一个秘密，你知道你有多伟大吗？  
  
朱烨强你知道的，他从进入高二起，就被级长和老师的双重打击……他一直处于摆烂和抗拒的心里之下，她爸，妈不知道，对他也施加压力……搞得他真的差点点崩溃了……还有贺骞，他两都是你好哥们，你比我们更了解他两个……他们的难和苦应该不比你少吧……  
  
昨天朱烨妈妈特意来了我家，说起朱烨强，她妈妈泪流满面……她说要感谢我，告诉她，孩子在校所承受的一切，她现在要用加倍的爱去理解，鼓励和陪伴他……很感恩自己刹车及时，挽救了失去一年多来都没有快乐的孩子，现在，那个原本快乐，懂事的孩子回来了……特别感恩![](file:///C:\Users\WhaleFall\AppData\Roaming\Tencent\QQTempSys\G@YVKCPZR)X}3UKB(_VF`LW.gif)  
  
我说不用感谢我，要感谢黄家乐，没有他的勇敢和诚实告诉我，我们永远不知道这些孩子心中的苦……还有学校不为人知的秘密……家乐是你拯救了朱烨强 和贺骞![](file:///C:\Users\WhaleFall\AppData\Roaming\Tencent\QQTempSys\}$$SH8F5BOR8W96(N@`FVY4.gif)![](file:///C:\Users\WhaleFall\AppData\Roaming\Tencent\QQTempSys\}$$SH8F5BOR8W96(N@`FVY4.gif)![](file:///C:\Users\WhaleFall\AppData\Roaming\Tencent\QQTempSys\}$$SH8F5BOR8W96(N@`FVY4.gif)![](file:///C:\Users\WhaleFall\AppData\Roaming\Tencent\QQTempSys\}$$SH8F5BOR8W96(N@`FVY4.gif)是你拯救了他们，家乐相信这次有能力拯救自己![](file:///C:\Users\WhaleFall\AppData\Roaming\Tencent\QQTempSys\Z~2OKACDD{L1UUZ0)BR01QJ.gif)![](file:///C:\Users\WhaleFall\AppData\Roaming\Tencent\QQTempSys\Z~2OKACDD{L1UUZ0)BR01QJ.gif)  
  
家乐，不知道你看完后想法怎样？也可能同你的内心想法有分歧和矛盾，这些都是正常的，因为，我们必定相差30多年，时代也不相同，各方面都会有差异……请你能够理解我，一心只想与你分享……我们一起学习，探讨，一起共同成长，为了自己想要的生活努力，奋斗吧![](file:///C:\Users\WhaleFall\AppData\Roaming\Tencent\QQTempSys\UG9`@AH2%L{}S0N6}3E~FO2.gif)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文案"><a class="header" href="#文案">文案</a></h1>
<p><audio controls="controls" src="assets/7235993455749614396-20230523101943-vkl4jzf.mp3" data-src="assets/7235993455749614396-20230523101943-vkl4jzf.mp3"></audio></p>
<p><audio controls="controls" src="assets/7235948774571428665-20230523102114-6ckottc.mp3" data-src="assets/7235948774571428665-20230523102114-6ckottc.mp3"></audio></p>
<p>​<img src="%E7%A2%8E%E7%A2%8E%E5%BF%B5/assets/Screenshot_2023-05-23-10-37-55-056-edit_com.ss.android.ugc.aweme-20230523103804-499olr0.jpg" alt="Screenshot_2023-05-23-10-37-55-056-edit_com.ss.android.ugc.aweme" />​</p>
<p>我希望生活在一个下着永不停歇的大雨的城市，居民大多是习惯孤独的艺术家，很少出门。街道上除了递送员总是空荡荡的，人们上街都穿着有高帽檐的雨衣。而我独自坐在窗前，度过一天又一天。</p>
<p>有时候 有时候<br />
我会相信一切有尽头<br />
相聚离开 都有时候<br />
没有什么会永垂不朽…</p>
<p>抱抱我吧，我快要碎掉了。</p>
<p>回忆 2017 岑宁儿《追光者》2018 买辣椒也用券《起风了》2019 雷雨心《纪念》2020 零一九零贰《忘川彼岸》2021 艾辰《错位时空》2022 陈奕迅《孤勇者》2023 张杰《听》</p>
<p>来去都是自由风，想念自然会重逢。</p>
<p>我深知自己太普通了所以我时常自信 时常自卑 时常在想 什么样的人才会带着真诚来到我身边。</p>
<h2 id="抑郁症"><a class="header" href="#抑郁症">抑郁症</a></h2>
<p>我只知道，我在心理诊室听着他们输出他们的观点。他们从不关心我怎么想怎么做，为什么，真的好烧，好烧钱。我舍不得。每次去完之后，父母总是说，“你根本就没问题。800 多块钱一个小时太贵了。你要是不想这么多就好了。这个年纪的小朋友谁没点抑郁啊？”然后，我就开始伪装。我假装自己没有问题一直到现在。可是，我是有病的，只有我自己知道。所以，靠近我的人都会很累。</p>
<p>真的觉得心理医生没有用，只是聊天，而且我说的特别多，也是没有感情的聊天，去心理咨询就跟上课一样，每次都想快点结束，很不耐烦。</p>
<p>‍</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="手机卡分销商副业"><a class="header" href="#手机卡分销商副业">手机卡分销商副业</a></h1>
<h2 id="感叹号订单管理分销"><a class="header" href="#感叹号订单管理分销">感叹号订单管理分销</a></h2>
<p><a href="https://gantanhao.vip/91haoka_platform/#/register">敢探号订单管理与分销系统</a></p>
<p><img src="%E7%A2%8E%E7%A2%8E%E5%BF%B5/assets/%E6%89%8B%E6%9C%BA%E5%8D%A1%E5%88%86%E9%94%80-bilibili-%E6%95%99%E7%A8%8B.png" alt="" /></p>
<h2 id="卡博世订单管理后台"><a class="header" href="#卡博世订单管理后台">卡博世订单管理后台</a></h2>
<h2 id="如何精准引流"><a class="header" href="#如何精准引流">如何精准引流</a></h2>
<h3 id="线上推广"><a class="header" href="#线上推广">线上推广</a></h3>
<pre><code class="language-text">【捡漏好卡】【即将下线】
类型：电信
资费：首充值50半年可用，快递处充50送50，7-12月每月19月租
权益：155G流量+全国通话0.1元/分钟

【资费透明，拒绝套路，快来抢购吧】
</code></pre>
<pre><code class="language-text">【长期稳定、29包165G，200分钟通话】
【新品首发】【捡漏好卡】【即将下线】
类型：电信G904长期永久卡
资费：稳定长期月租 29 元，随时退卡。
权益：29包165G+200分钟通话

【资费透明，拒绝套路，快来抢购吧】

</code></pre>
<pre><code class="language-text">【捡漏好卡】
类型：联通-大鱼卡
资费：月租29元200G通用流量
权益：29元200G流量+100分钟通话+3个月视频会员

【资费透明，拒绝套路，快来抢购吧】
</code></pre>
<pre><code>【大流量用户】【吃到饱】
类型：NX电信
资费：首充50，资费每月稳定49
权益：49元220G通用+30G定向+600分钟
第二次冲50可领取50G专属链接：https://yx.nx.189.cn/m_lx2020xhzw/index_starCardnx.do
</code></pre>
<pre><code class="language-text">【捡漏好卡】【19月租】【50包半年】
类型：H901电信光芒卡
资费：首充50包半年，7-24个月19
权益：125G通用+30G定向+通话0.1元/分钟
【冲50送50专属活动链接】:http://a.189.cn/F6fzbn

（无首冲要求）

https://gantanhao.vip/webapp/merchant/templet1.html?share_id=529294&amp;id=6296315
</code></pre>
<h2 id="落落の卡卡喵"><a class="header" href="#落落の卡卡喵">落落の卡卡喵</a></h2>
<p><a href="https://gantanhao.vip/91haoka_platform/#/minishop?share_id=529294&amp;shop_name=%25E8%2590%25BD%25E8%2590%25BD%25E3%2581%25AE%25E5%258D%25A1%25E5%258D%25A1%25E5%2596%25B5">落落の卡卡喵</a></p>
<p><img src="%E7%A2%8E%E7%A2%8E%E5%BF%B5/assets/%E6%B5%81%E9%87%8F%E5%8D%A1%E5%AE%A3%E4%BC%A0.jpg" alt="" /></p>
<p><img src="%E7%A2%8E%E7%A2%8E%E5%BF%B5/assets/%E6%89%8B%E6%9C%BA%E5%8D%A1%E5%88%86%E9%94%80-qrcode.png" alt="" /></p>
<pre><code class="language-url">https://gantanhao.vip/91haoka_platform/#/minishop?share_id=529294&amp;shop_name=%25E8%2590%25BD%25E8%2590%25BD%25E3%2581%25AE%25E5%258D%25A1%25E5%258D%25A1%25E5%2596%25B5
</code></pre>
<h2 id="ref"><a class="header" href="#ref">ref</a></h2>
<p><a href="https://www.868123.xyz/help/154.html">敢探号全套系统使用教程 | 神卡指南</a></p>
<h2 id="话术"><a class="header" href="#话术">话术</a></h2>
<p>快开学了，友友们需要流量吗，咱就是说刚刚发现了一个超级便宜划算的流量套装哦，我已经上车了。</p>
<p>大家手机用的什么套餐？</p>
<p>我发现了一个很划算的 bug 级套餐</p>
<p>运营商朋友的渠道哦，运营商都没那么便宜。</p>
<p>太适合我们这种底层鼠鼠啦</p>
<p>【冲50送50专属活动链接】:http://a.189.cn/F6fzbn</p>
<h2 id="供应商代码"><a class="header" href="#供应商代码">供应商代码</a></h2>
<h2 id="docs"><a class="header" href="#docs">docs</a></h2>
<p><strong>绝不套路任何一位客户</strong></p>
<p>只卖官方正规套餐，客服，掌厅可查</p>
<p>不做任何套路宣传，实事求是。</p>
<p>我的卡，卖的不是最便宜的，但是绝对是最放心的。</p>
<p>不卖违规加包的卡（不是说卡不好，不喜欢处理售后，所以不喜欢卖）</p>
<p><strong>感谢所有支持我的小伙伴 请往下看完！</strong> </p>
<p>所有卡全是<strong>正规卡</strong>，<strong>正规的三大运营商官方手机卡</strong>**，官方可查**只要你要求符合，全国能办（个别卡除外），全国能用。</p>
<p>别问靠谱吗？稳定吗？连中国移动，中国联通，中国电信的卡你都觉得不靠谱，放弃用手机卡吧。。。。</p>
<p>办卡只办适合自己的，一味的追求永久套餐啊啥的没意义，营业厅里面的都是永久的，你会一直用下去么？而且月租高流量少。</p>
<p>好卡都是 内蒙，湖南，河北，浙江这些地区，你们本地没有出优惠卡，就算出了有些卡也不会全国卖，所以我这边也就没有你所在地区的卡。</p>
<p>这里推荐一个用卡组合方案：</p>
<p>老号码去改成最低月租套餐，比如移动是 8 元飞享套餐（联系 10086 客服就能改）老号码可用来接打电话，现在打电话也便宜，最高也就 0.15 元/分钟，然后办个流量多的外地卡，只用来上网，现在手机一般都双卡双待，2 张卡无压力。</p>
<ol>
<li>
<p>三大运营商的卡，都是不限速的,但是网速取决与你的手机,与区域基站</p>
</li>
<li>
<p>别问流量虚不虚这些问题，正规卡没有这些垃圾物联网卡的问题</p>
</li>
<li>
<p>不卖 BUG 卡：通过漏洞加的流量包或者违规加的流量卡</p>
</li>
<li>
<p>不能办副卡：校园卡一般不能办理副卡</p>
</li>
<li>
<p><strong>不能老号改套餐</strong>：<strong>校园卡的特殊性，只能新办，不能老号改</strong></p>
</li>
<li>
<p>不能携号转网到校园套餐：老号都不能改，携号转网肯定不行</p>
</li>
<li>
<p>不能选归属地：校园卡都是地方性的卡，归属地都是固定</p>
</li>
<li>
<p>不能选号：一般都是随机发，个别卡能选的会在套餐页面说明</p>
</li>
<li>
<p>不能过户：校园卡一般都是 2 年或者 4 年，有合约期，有优惠减免</p>
</li>
<li>
<p>校园卡不能续约 ：校园卡 2 年或者 4 年优惠期，到期后去销户</p>
</li>
</ol>
<p><strong>返佣方式：</strong></p>
<p>我们这有日结、周结、月结、大部分商品为月结方式.</p>
<p>已月结为例：1 月 25 日收货,2 月 1 日激活,算 2 月激活数据,3 月 28 日后结算.</p>
<p>一般都用支付宝转账，不信任的勿扰，以免浪费双方的时间。</p>
<p><strong>代理收费问题：不收代理费！！！</strong></p>
<p>流量问题：套餐都有写着月租多少流量多少，这个流量是每个月都有，有些小白不知道咋想的，就比如 20G 的套餐，怎么可能是一年 20G，肯定是每个月啊，20G 一年够用么？</p>
<p>销户问题：</p>
<p>校园卡一般有优惠期，部分卡优惠期内不能随时销户，如果你确实想要提前销户，可以自己联系运营商客服咨询是否可以提前销户，有可能提前销户要交违约金，所有正规卡都支持异地销户，具体的咨询官方客服。</p>
<p>网速快慢：有些人网速慢或者信号差，就说卡问题，这个取决于你所在地附近的基站信号，跟卡没关系！跟套餐没关系。全国各地用同一种卡，网速都会不一样，各种因素，信号的遮挡，基站用的人多，都会造成网速慢</p>
<p>没有人会给你保证说网速肯定好肯定快之类的，不现实，除非这人住你隔壁。</p>
<p>ps: 小编在湖北，用的内蒙古电信的卡，由于我这边基站信号好，下载速度都是 10M 每秒，不管用哪里的卡都是跟基站有关系，之前小编所在地电信速度慢的网页都打不开，后来联系电信客服反馈问题，电信来检查 说是基站坏了，之后估计电信升级了基站，现在网速一直很好。</p>
<p>5G 问题：大部分 3G 或者 4G 套餐在 5G 手机 +5G 基站的前提下都支持 5G 最低 300M 速率，等于 30M 每秒，没必要办理 5G 套餐（目前太贵）</p>
<p>NFC 开卡问题：不是所有卡都支持 NFC 开卡，如果这个卡线上办理通道关闭了，导致外省用户不能办理，才会通过 NFC 开卡的方式开卡，从而实现远程激活号卡</p>
<p>发身份证件问题：个别卡是官方自助上传证件资料，还有部分卡是需要发身份证件给系统，这个没有办法，你不发，卡就办不了，系统没有你的证件资料入网，就算卡发你了，也是张空卡，你也激活不了。</p>
<p><strong>实名激活规范的严重性：</strong></p>
<p>凡是需要传三张照片，身份证正反面 + 半身照的，必须拍规范，自己不确定的发我审核，如果是给你连接自己传的，发我的时候可以打码。</p>
<p>收到卡实名激活的时候，必须按照要求拍规范，视频拍规范</p>
<p>不规范的后果：</p>
<p>1.导致实名激活失败，卡用不了</p>
<p>2.部分卡不能重新激活的，只能重新下单</p>
<p>这也是为什么，办卡拍照要求这么严格的原因，拍规范了一次性通过，你能直接用上卡，我这边也省事。</p>
<p>证件安全问题：卡都是直接跟营业厅合作，可以保证证件安全，你信任就办，不信任我也没办法，你可以办其他自助官方下单的卡。</p>
<p>诈骗高危地区局停问题：</p>
<p>这个不是我们能决定的，不是卡套餐问题，是你所在的地区问题，为了防止被局停，大部分卡诈骗地区都是不发货，个别卡能发，但是你使用也要注意，不要使用语音功能，如果被公安局停了，需要自己联系运营商客服解决，本公众号无法处理局停问题（个别卡能帮忙解封）</p>
<p>关于售后问题：</p>
<p>售后范围：套餐与宣传的不一致</p>
<p>我能解决的尽量给你解决，无法解决的只能你自己联系官方运营商客服。</p>
<p>不在售后范围之内包含：</p>
<p>1.你所在的地区基站问题导致网速慢</p>
<p>2.在诈骗地区使用导致被公安局停，自己联系官方客服解决</p>
<p>3.卡板人为损坏，导致用不了，自己去营业厅补卡</p>
<p>其余问题全部联系运营商官方售后客服解决！公众号关注后发送人工</p>
<p>中国电信官方客服电话：10000   公众号：中国电信客服</p>
<p>中国联通官方客服电话：10010   公众号：中国联通客服</p>
<p>中国移动官方客服电话：10086   公众号：中国移动 10086</p>
<p><strong>反馈问题：</strong></p>
<p>发送后台订单 ID，报订单 ID，报订单 ID，最不济也发个收货手机号啊！不要跟我说这个，那个，他。。。我怎么知道你说的是那个！！！重要问题要发对应的截图，否者无法处理！</p>
<p>对套餐月租扣费有疑问的，先问运营商官方客服，如果客服核实到套餐不一致，再来我这边反馈！</p>
<p>为广大网友提供校园卡优惠套餐办理，不存在跑路一说，信任就办，不要加了小编后，来一句不会是骗人的吧，跑路啥的，依法办卡，诚信至上！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="知乎精选"><a class="header" href="#知乎精选">知乎精选</a></h1>
<p>‍</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: 思源笔记本使用感想
date: 2023-05-22 19:08:10
updated: 2023-05-22 19:08:10
categories: Note
tags: [思源, note, 笔记软件]
description:
thumbnail:
banner_img:</p>
<hr />
<h1 id="思源笔记本使用体验"><a class="header" href="#思源笔记本使用体验">思源笔记本使用体验</a></h1>
<p>这个笔记本最大的优点就是：<strong>开源、私有化部署、多平台客户端支持、多端同步、可见可得。</strong></p>
<p>当然使用了半小时也感觉有不足：</p>
<ol>
<li>可见可得不能看见原始的 Markdown 文档，有种不安的感觉。但是也省去了使用纯 Mardown 编辑软件调整排版的时间。</li>
<li>S3 的对象存储，目前使用的是七牛云的对象存储，担心日后图片多了就会导致流量暴增。思源文档写不能良好的支持 WebDav 协议，确实这个协议还存在诸多不足。例如“坚果云”限制 Webdav 的速率之类云云。</li>
<li>不能看见原始的 Markdown 文件，只能通过导出生成 Markdown 文件。这基本上是文章和软件深度绑定，必须使用思源才能打开此前的笔记，不通用。只能寄望于写作完成尽快导出 Markdown 文件保存在云盘上。数据可用性保障方面存疑。</li>
<li>思源采用的是 B/S 设计模式，前端使用 Election 技术，可能在低性能设备上运行不良。考虑到其支持多端跨平台，也支持私有 docker 部署 web 页面，这样也不错。</li>
<li>体验到了 思源笔记 的不确定性，因为他是 30s 无操作才能触发自动保存机制，当使用 web 在线编辑时，如果客户端因为某些原因关闭的网页，写的内容就会消失不见，所以提议，<strong>在进行长文本的写作时，应使用外部的可靠笔记软件</strong>，例如：纯纯笔记本，之类的。</li>
</ol>
<p>还得使用一段时间才来写使用感受。</p>
<h2 id="部署"><a class="header" href="#部署">部署</a></h2>
<h3 id="docker-web-镜像"><a class="header" href="#docker-web-镜像">Docker Web 镜像</a></h3>
<p>参数：</p>
<pre><code class="language-plaintext">Usage of /opt/siyuan/kernel:
  -accessAuthCode string
        access auth code
  -alsologtostderr
        log to standard error as well as files
  -lang string
        zh_CN/zh_CHT/en_US/fr_FR/es_ES
  -log_backtrace_at value
        when logging hits line file:N, emit a stack trace
  -log_dir string
        If non-empty, write log files in this directory
  -log_link string
        If non-empty, add symbolic links in this directory to the log files
  -logbuflevel int
        Buffer log messages logged at this level or lower (-1 means don't buffer; 0 means buffer INFO only; ...). Has limited applicability on non-prod platforms.
  -logtostderr
        log to standard error instead of files
  -mode string
        dev/prod (default &quot;prod&quot;)
  -port string
        port of the HTTP server (default &quot;0&quot;)
  -readonly string
        read-only mode (default &quot;false&quot;)
  -ssl
        for https and wss
  -stderrthreshold value
        logs at or above this threshold go to stderr (default 2)
  -v value
        log level for V logs
  -vmodule value
        comma-separated list of pattern=N settings for file-filtered logging
  -wd string
        working directory of SiYuan (default &quot;/opt/siyuan&quot;)
  -workspace string
        dir path of the workspace, default to ~/Documents/SiYuan/
</code></pre>
<p>​<code>/root/siyuan/workspace</code>​​ 需保持完全一致。</p>
<pre><code class="language-shell">docker run -d \
  -v /root/siyuan/:/root/Documents/SiYuan \
  -p 6806:6806 \
  -u $(id -u):$(id -g) \
--name=siyuan-note \
  b3log/siyuan \
--workspace=/root/Documents/SiYuan \
--accessAuthCode=lovehyy9420 \
</code></pre>
<h3 id="amazon-s3-私有部署"><a class="header" href="#amazon-s3-私有部署"><strong>Amazon S3 ​</strong>私有部署</a></h3>
<p>使用 minio 搭建私有化对象存储服务，参考：<a href="https://cloud.tencent.com/developer/article/1647496">https://cloud.tencent.com/developer/article/1647496</a></p>
<p>使用 minio 搭建私有化对象存储服务，用于代替性能不好的 WebDav。</p>
<blockquote>
<p>MinIO 是一个基于 Apache License v2.0 开源协议的对象存储服务。它兼容亚马逊 S3 云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等，而一个对象文件可以是任意大小，从几 kb 到最大 5T 不等。</p>
</blockquote>
<p>使用 Docker 搭建：<a href="https://hub.docker.com/r/minio/minio/">Docker Hub</a></p>
<blockquote>
<p>NOTE: To deploy MinIO on with persistent storage, you must map local persistent directories from the host OS to the container using the <code>docker -v</code>​ option. For example, <code>-v /mnt/data:/data</code>​ maps the host OS drive at <code>/mnt/data</code>​ to <code>/data</code>​ on the container.</p>
<p>注意：要使用持久存储部署 MinIO，必须使用 <code>-v</code>​ 选项将本地持久目录从主机操作系统映射到容器。例如，<code>-v /mnt/data:/data</code>​ 将容器上的 <code>/mnt/data</code>​ 处的主机 OS 驱动器映射到 <code>/data</code>​ 。</p>
</blockquote>
<pre><code class="language-shell">docker run -d \
-p 9020:9000 \
-p 9030:9001 \
-v /mnt/sdb1/s3:/data/ \
--name=minio \
quay.io/minio/minio \
server /data --console-address &quot;:9001&quot;
</code></pre>
<p>运行成功后，访问 <a href="http://127.0.0.1:9030">http://127.0.0.1:9030</a> 各种配置。</p>
<h2 id="config"><a class="header" href="#config">Config</a></h2>
<h3 id="s3-七牛云服务"><a class="header" href="#s3-七牛云服务">S3 七牛云服务</a></h3>
<pre><code class="language-text">EP: s3-cn-south-1.qiniucs.com
AK: Jae1FQjUxMWmhVd_RS6YPX1LoMU8ejJPfXWPp0YF
SK: mJVJzSa-ja7TihdUIIRpKRg4abOlGC-z0xDyXISl
Region: cn-south-1
Bucket: siyuan-note-wf
</code></pre>
<h2 id="nginx-反向代理思源笔记本-web"><a class="header" href="#nginx-反向代理思源笔记本-web">Nginx 反向代理思源笔记本 Web</a></h2>
<p>思源运行在 6806 端口，将其代理至 8080 端口 <code>/note/</code>​ 路径，需要支持 Websocket。</p>
<pre><code class="language-conf">location /note/ {
     proxy_pass http://192.168.8.1:6806/;
     proxy_set_header X-Real-IP $remote_addr;
     proxy_set_header x-wiz-real-ip $remote_addr;
     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
     proxy_set_header X-Forwarded-Proto $scheme;
     proxy_set_header X-NginX-Proxy true;

     proxy_http_version 1.1;
     proxy_set_header Upgrade $http_upgrade;
     proxy_set_header Connection &quot;upgrade&quot;;
     proxy_set_header Connection &quot;keep-alive&quot;;

     proxy_set_header Host $http_host;
     proxy_ssl_session_reuse off;
     proxy_cache_bypass $http_upgrade;
     proxy_redirect off;
 }
</code></pre>
<p>‍</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="猫猫"><a class="header" href="#猫猫">猫猫</a></h1>
<p>‍</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="手机卡分销"><a class="header" href="#手机卡分销">手机卡分销</a></h1>
<p>update: 2023/7/26</p>
<h2 id="电信米兰卡"><a class="header" href="#电信米兰卡">电信米兰卡</a></h2>
<p>19元包125G通用+30G定向+100分钟（首冲100）</p>
<ul>
<li>供应商：速通通信</li>
<li>佣金：按要求首冲100，次月在网佣金：110元（6%专票）</li>
<li>首充：按要求首冲100</li>
</ul>
<pre><code class="language-text">【捡漏好卡】【28晚即将下线】
类型：电信米兰卡
资费：首冲100，第2-13月19元月租
权益：包125G通用+30G定向+100分钟
年龄：21-60周岁
归属地：全国随机
协议：随时可退

【资费透明，拒绝套路，快来抢购吧】
</code></pre>
<h2 id="电信光芒卡-h901"><a class="header" href="#电信光芒卡-h901">电信光芒卡 H901</a></h2>
<ul>
<li>供应商：乐达网络</li>
<li>佣金：次月在网95元</li>
<li>首充：首充50包半年，7-24个月19</li>
</ul>
<pre><code class="language-text">【捡漏好卡】【19月租】【50包半年】  
类型：电信光芒卡  
资费：首充50包半年，冲50送50活动，7-24个月每月19。
权益：125G通用+30G定向+通话0.1元/分钟  
【冲50送50专属活动链接】:http://a.189.cn/F6fzbn
归属地：全国随机
协议：随时可退
年龄：16-60周岁
</code></pre>
<p>‘
下单地址：<a href="https://gantanhao.vip/webapp/merchant/templet1.html?share_id=529294&amp;id=6296315">https://gantanhao.vip/webapp/merchant/templet1.html?share_id=529294&amp;id=6296315</a></p>
<p><img src="https://static.91haoka.cn/16898342428Xh.jpg" alt="" /></p>
<h2 id="电信天卯卡-大流量用户"><a class="header" href="#电信天卯卡-大流量用户">电信天卯卡 （大流量用户）</a></h2>
<ul>
<li>供应商：速动通信</li>
<li>佣金：按要求首冲50/100/200，次月正常在网150元（6%专票）</li>
<li>首充：首冲50/100/200，49元</li>
<li>【首冲】冲50送120（快递处扫码，留意活动内容是否吻合）、100得220/200得460：https://yx.nx.189.cn/s/a/n2A3Ev（到期可尝试续约）丨【第二次冲50】领50G链接：https://yx.nx.189.cn/m_lx2020xhzw/index_starCardnx.do</li>
</ul>
<p><img src="https://static.91haoka.cn/1689674992CA9.jpg" alt="电信天卯卡" /></p>
<h2 id="g904电信永久卡"><a class="header" href="#g904电信永久卡">G904电信永久卡</a></h2>
<pre><code class="language-text">【长期稳定、29包165G，200分钟通话】  
【新品首发】【捡漏好卡】【即将下线】  
类型：电信G904长期永久卡  
资费：首充50，稳定长期月租 29 元，随时退卡。  
权益：29包165G+200分钟通话
</code></pre>
<p><img src="https://static.91haoka.cn/1689674992CA9.jpg" alt="G904电信永久卡" /></p>
<h2 id="广电猫王卡纯流量上网卡"><a class="header" href="#广电猫王卡纯流量上网卡">广电猫王卡（纯流量上网卡）</a></h2>
<ol>
<li>纯流量卡，不支持电话语音</li>
<li>无首充，前三月月租29不限量。</li>
<li>前三个月 5G 不限速不限量月租29，第四个月恢复资费。</li>
</ol>
<p><img src="https://static.91haoka.cn/1686669975XSY.jpg" alt="" /></p>
<h2 id="电信沧星卡"><a class="header" href="#电信沧星卡">电信沧星卡</a></h2>
<ul>
<li>速动通信</li>
<li>按要求首冲50，次月正常在网佣金：125元（6%专票）</li>
</ul>
<pre><code class="language-text">【捡漏好卡】【19月租】 
类型：电信沧星卡 
资费：首充50包半年，冲50送50活动，2-6个月每月19，之后长期29月租。
权益：170G通用+30G定向+通话0.1元/分钟  
【冲50送50专属活动链接】:http://a.189.cn/F6fzbn
归属地：全国随机
协议：随时可退
年龄：16-60周岁
</code></pre>
<p><img src="https://static.91haoka.cn/16898121220Zv.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="闲鱼文案模板"><a class="header" href="#闲鱼文案模板">闲鱼文案模板</a></h1>
<p>【个人闲置】自用 9 成新跑步机，20 年疫情购入，买回来太懒了没用使用几次，搬家了故出闲置跑步机。</p>
<p>该跑步机是高端跑步机，可以链接手机 APP，大液晶屏实时显示当前心率，里程数，设置运动计划，自适应跑步速率，自带专业音响，可以边跑步边听歌🎶。让你足不出户，享受健康跑步。</p>
<p>跑步机体积大，佛山禅城自提吧，走快递也可以，邮费 AA。售出不退不换。</p>
<hr />
<p>神秘资料，神秘学资料，包含 tl、z 星、魔法🔮、草药、东玄西秘，网盘一共 6GB 资料，电子书，PDF，一直持续更新。</p>
<p>本人研究神 m 学多年，资料是我这些年一直收集的，适合初入坑的小伙伴学习探讨！喜欢的 uu 赶紧点击“我想要”。</p>
<p>因为是虚拟商品，具有可复制性，售出不退不换，本人只做收集，相关文献版权归作者所有，如有侵权请联系删除。</p>
<p>​<img src="%E7%A2%8E%E7%A2%8E%E5%BF%B5/assets/image-20230606103439-sjb48xl.png" alt="image" />​​<img src="%E7%A2%8E%E7%A2%8E%E5%BF%B5/assets/image-20230606103522-fxcoj40.png" alt="image" />​</p>
<p>​<img src="%E7%A2%8E%E7%A2%8E%E5%BF%B5/assets/image_editor_1686019053627-20230606103801-kxmifxl.jpg" alt="image_editor_1686019053627" />​</p>
<p>神秘学资料大全，百度网盘：链接：<a href="https://pan.baidu.com/s/1aRlZd68synEH02LHVpJyDQ?pwd=hnw2">https://pan.baidu.com/s/1aRlZd68synEH02LHVpJyDQ?pwd=hnw2</a><br />
提取码：hnw2（因为百度盘有审查，部分资料可能不齐全）</p>
<p>私有云盘 Onedrive，支持在线查看打包下载：<a href="https://pan.whaleluo.top/%E7%A5%9E%E7%A7%98%E5%AD%A6%E8%B5%84%E6%96%99/">https://pan.whaleluo.top/%E7%A5%9E%E7%A7%98%E5%AD%A6%E8%B5%84%E6%96%99/</a> 资料全，但是国内访问速度可能会慢一些。</p>
<p>‍</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="online-class"><a class="header" href="#online-class">Online-class</a></h1>
<h2 id="tencent-meeting"><a class="header" href="#tencent-meeting">Tencent Meeting</a></h2>
<p>3474239661 --&gt; 钟老师的会议号</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="奇思妙想"><a class="header" href="#奇思妙想">奇思妙想</a></h1>
<h2 id="图寻游戏"><a class="header" href="#图寻游戏">图寻游戏</a></h2>
<blockquote>
<p>网络迷踪，在图片上找到位置，并点击地图。</p>
</blockquote>
<p>由炒饭社区开发，文档：<a href="https://www.yuque.com/chaofun/tuxun">https://www.yuque.com/chaofun/tuxun</a></p>
<p><a href="https://tuxun.fun/challenge?challengeId=71d46160-fa13-11ed-b657-ddf1f09f489e">https://tuxun.fun/challenge?challengeId=71d46160-fa13-11ed-b657-ddf1f09f489e</a></p>
<h2 id="chatgpt-镜像"><a class="header" href="#chatgpt-镜像">ChatGPT 镜像</a></h2>
<ol>
<li><a href="https://github.com/LiLittleCat/awesome-free-chatgpt">free chatgpt github repo</a></li>
<li><a href="https://www.aitianhu.com/#/chat">https://www.aitianhu.com/#/chat</a></li>
<li><a href="https://gpt4.gravityengine.cc/">https://gpt4.gravityengine.cc/</a> 需要🌏</li>
</ol>
<h2 id="在线剪贴网站"><a class="header" href="#在线剪贴网站">在线剪贴网站</a></h2>
<ol>
<li><a href="https://netcut.cn/">netcut.cn</a></li>
<li>在线代码分享 <a href="https://paste.org.cn/">https://paste.org.cn/</a></li>
</ol>
<h2 id="邮政寄信"><a class="header" href="#邮政寄信">邮政寄信</a></h2>
<p>平信和挂号信，本市 0.8，出省出市 1.2，去 <strong>中国邮政</strong> 买邮票和信封。</p>
<h2 id="office365-e5-白嫖"><a class="header" href="#office365-e5-白嫖">Office365 E5 白嫖</a></h2>
<p><a href="https://ednovas.xyz/2021/02/15/oneindex/">ednovas.xyz/2021/02/15/o...</a></p>
<h2 id="粤语拼音英文名"><a class="header" href="#粤语拼音英文名">粤语拼音英文名</a></h2>
<p><a href="https://www.namechef.co/zh/hkid-english-name/result/?name=%E9%BB%84%E5%AE%B6%E4%B9%90">https://www.namechef.co/zh/hkid-english-name/result/?name=黄家乐</a></p>
<p>黃	Wong / Ong / Wang<br />
家	Ka<br />
樂	Lok</p>
<h2 id="ai-脸部生成器"><a class="header" href="#ai-脸部生成器">AI 脸部生成器</a></h2>
<p><a href="https://thispersondoesnotexist.xyz/">https://thispersondoesnotexist.xyz/</a></p>
<h2 id="see-pian"><a class="header" href="#see-pian">See Pian</a></h2>
<p><a href="https://theporndude.com/zh">https://theporndude.com/zh</a></p>
<h2 id="搜索引擎"><a class="header" href="#搜索引擎">搜索引擎</a></h2>
<p>duckduckgo.com</p>
<h2 id="windows10-精简系统"><a class="header" href="#windows10-精简系统">Windows10 精简系统</a></h2>
<p><a href="https://atlasos.net/">https://atlasos.net/</a></p>
<h2 id="多功能-pe-系统"><a class="header" href="#多功能-pe-系统">多功能 PE 系统</a></h2>
<p><a href="https://home.edgeless.top/">https://home.edgeless.top/</a></p>
<h2 id="gps-坐标拾取器"><a class="header" href="#gps-坐标拾取器">GPS 坐标拾取器</a></h2>
<p><a href="https://lbs.qq.com/getPoint/">https://lbs.qq.com/getPoint/</a></p>
<p>23.011217,113.046427 广东省佛山市禅城区东平路</p>
<h2 id="李老师不是你老师民运官方网站"><a class="header" href="#李老师不是你老师民运官方网站">李老师不是你老师民运官方网站</a></h2>
<p><a href="https://lilaoshibushinilaoshi.com/wulumuqinight/">https://lilaoshibushinilaoshi.com/wulumuqinight/</a></p>
<h2 id="政治倾向测试-politi-scales-政治天平"><a class="header" href="#政治倾向测试-politi-scales-政治天平">政治倾向测试 Politi Scales (政治天平)</a></h2>
<p><a href="https://politiscales.party/">https://politiscales.party/</a></p>
<p>​<img src="%E7%A2%8E%E7%A2%8E%E5%BF%B5/assets/image-20230612135650-fuwvgr8.png" alt="image" />​</p>
<p>ChatGPT 分析：</p>
<blockquote>
<p>根据你提供的 PolitiScales 政治倾向测试报告，你的政治倾向主要是平等、人权和社会主义。你的社会建构主义得分较高，说明你认为社会是可以被改变和塑造的，而不是由本质决定的。你的修复性司法得分较高，说明你支持通过司法手段来修复社会不公和保护弱势群体的权益。你的进步主义得分较高，说明你支持社会变革和改革，以促进社会进步和公正。你的国际主义得分较高，说明你支持国际合作和互助，以实现全球和平和繁荣。你的共产主义得分较低，但也表明你对社会主义思想持有一定的认同和支持。你的规范主义得分较高，说明你认为社会需要一定的规范和制度来维护秩序和公正。你的生态主义得分较低，但你仍然关注环境问题并认为应该采取措施来保护环境。最后，你的革命派和改良派得分相近，说明你既支持通过改良来推进社会变革，也支持通过革命手段来推翻不公和不平等的制度。</p>
<p>基于用户的得分分析，我们可以进一步推断出以下一些可能的政治立场和价值观：</p>
<ul>
<li>社会主义：用户对共产主义的好感度较高，同时倾向于进步主义、国际主义和规范主义，这些都是社会主义思想的核心价值观。</li>
<li>平等和人权：用户的得分显示他非常重视平等和人权，这也是社会主义和进步主义的核心价值观。</li>
<li>修复性司法：用户支持修复性司法，这意味着他认为司法应该更注重矫正和改善罪犯，而不是仅仅惩罚他们。</li>
<li>生态主义：用户的得分显示他对生态主义持有一定的支持态度，这意味着他可能认为保护环境和可持续发展非常重要。</li>
<li>改良派：用户的得分显示他倾向于改良派，这意味着他可能认为改良和渐进式的改变比革命更可行和有效。</li>
</ul>
</blockquote>
<h2 id="hi-英文输入法"><a class="header" href="#hi-英文输入法">Hi 英文输入法</a></h2>
<p><a href="https://inputhelp.com/inputhelp/">HI 英文输入法官网</a> 可能是中文母语者最适合的输入法。（不合适，界面太老旧不好看了）</p>
<h2 id="keepass"><a class="header" href="#keepass">Keepass</a></h2>
<h3 id="chrome-扩展"><a class="header" href="#chrome-扩展">Chrome 扩展</a></h3>
<p>KeePassHttp-Connector ：自动填充密码</p>
<h2 id="在线画板"><a class="header" href="#在线画板">在线画板</a></h2>
<p><a href="https://www.suxieban.com/index.html">画画_画图_在线画画_在线画图网站_速写板</a></p>
<h2 id="数学公式-letex-识别"><a class="header" href="#数学公式-letex-识别">数学公式 letex 识别</a></h2>
<p>数学公式 Latex 识别：<a href="https://simpletex.cn/ai/latex_ocr">公式识别</a></p>
<h2 id="大文件打开"><a class="header" href="#大文件打开">大文件打开</a></h2>
<p>emeditor</p>
<p><a href="https://zh-cn.emeditor.com/download/">下载 – EmEditor (文本编辑器)</a></p>
<h2 id="jb-激活"><a class="header" href="#jb-激活">Jb 激活</a></h2>
<p>确实，不如 <a href="https://3.jetbra.in/">https://3.jetbra.in/</a></p>
<ol>
<li>点进去，随便选个 IPFS 镜像（你可以理解为分流网站）</li>
<li>下载 <code>jetbra.zip</code> (220801)，并解压到一个合适的路径（别带空格，别带中文），下载完别关网站，后面还要用</li>
<li>运行 <code>jetbra\scripts\install-all-users.vbs</code> ，到 Done</li>
<li>找一下配置文件，一般在 <code>C:\Users\[用户名]\AppData\Roaming\JetBrains\[对应IDE]\[对应IDE]64.exe.vmoptions</code> 直接用 everything 搜 <code>64.exe.vmoptions</code></li>
<li>任意文本编辑器打开这个配置文件，用 <code>jetbra\vmoptions\[对应IDE].vmoptions</code> 里面的内容替换掉原本的内容</li>
<li>在之前下载 <code>jetbra.zip</code> 那个网站上，找到对应的 IDE，复制激活码</li>
<li>打开 IDE，输入刚刚复制的激活码</li>
<li>完事。永久有效，谁跟你嘻嘻哈哈的什么“到 24 年 3 月”</li>
</ol>
<p>为了确保有效，我特意卸载了重装测试的一遍<br />
现在是 2023 年 7 月 19 日，我测的官方最新版 GoLand 2023.1.4，成功复现<br />
激活的许可显示的“active until August 1, 2025”，不必在意<br />
那个是保底许可证，到时候真的到期了也不会掉</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="猫猫-1"><a class="header" href="#猫猫-1">猫猫</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多多"><a class="header" href="#多多">多多</a></h1>
<p>​<img src="%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E7%8C%AB%E7%8C%AB/assets/wx_camera_1684915972641-20230531001922-n165lbb.jpg" alt="wx_camera_1684915972641" />​<br />
多多喝水水视频。<br />
‍<br />
![[VID_20230512_181638-20230531002210-jlbx45e.mp4]]<br />
‍</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cutboard"><a class="header" href="#cutboard">CutBoard</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="无线电爬取脚本"><a class="header" href="#无线电爬取脚本">无线电爬取脚本</a></h1>
<pre><code class="language-python">&quot;&quot;&quot;
爬取业余无线电中继列表:
http://weixin.cqcqcq.cn/index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=80
Beautiful Soup 4 使用参考: http://c.biancheng.net/python_spider/bs4.html
安装依赖：
pip install httpx bs4
&quot;&quot;&quot;
import httpx
from bs4 import BeautifulSoup
import csv
from pathlib import Path

# 广州
# /index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=76
# 佛山
# /index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=80
# 深圳
# /index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=77
# 珠海
# /index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=96
# 湛江
# /index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=93
# 肇庆
# /index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=94
# 江门
# /index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=83

urlsss = [
    [&quot;广州&quot;, &quot;/index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=76&quot;],
    [&quot;佛山&quot;, &quot;/index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=80&quot;],
    [&quot;深圳&quot;, &quot;/index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=77&quot;],
    [&quot;珠海&quot;, &quot;/index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=96&quot;],
    [&quot;湛江&quot;, &quot;/index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=93&quot;],
    [&quot;肇庆&quot;, &quot;/index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=94&quot;],
    [&quot;江门&quot;, &quot;/index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=83&quot;],
    [&quot;汕头&quot;, &quot;/index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=88&quot;],
    [&quot;韶关&quot;, &quot;/index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=90&quot;],
    [&quot;茂名&quot;, &quot;/index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=85&quot;],
    [&quot;惠州&quot;, &quot;/index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=82&quot;],
    [&quot;梅州&quot;, &quot;/index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=86&quot;],
    [&quot;汕尾&quot;, &quot;/index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=89&quot;],
    [&quot;河源&quot;, &quot;/index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=81&quot;],
    [&quot;阳江&quot;, &quot;/index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=91&quot;],
    [&quot;清远&quot;, &quot;/index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=87&quot;],
    [&quot;东莞&quot;, &quot;/index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=79&quot;],
    [&quot;中山&quot;, &quot;/index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=95&quot;],
    [&quot;潮州&quot;, &quot;/index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=78&quot;],
    [&quot;揭阳&quot;, &quot;/index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=84&quot;],
    [&quot;云浮&quot;, &quot;/index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=92&quot;],
    [&quot;顺德&quot;, &quot;/index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=3411&quot;]

]


param = &quot;/index.php?m=radio&amp;c=index&amp;a=list4city&amp;city_id=76&quot;

url = &quot;http://weixin.cqcqcq.cn%s&quot;

header = {&quot;UserAgent&quot;: &quot;Mozilla/5.0 (Linux; Android 6.0.1;)&quot;}

current_dir = Path(__file__).parent


def getListElement(list: list, num: int) -&gt; str:
    &quot;&quot;&quot;get list element by id without error&quot;&quot;&quot;
    try:
        return list[num].text.strip()
    except IndexError:
        return None


def parser(url) -&gt; dict:
    &quot;&quot;&quot;解析单个中继的页面,返回单个中继参数 dict&quot;&quot;&quot;
    with httpx.Client(headers=header) as client:
        resp = client.get(url)

    soup = BeautifulSoup(resp.text, 'html.parser')
    tags = soup.find(class_=&quot;card&quot;)
    name = tags.find(class_=&quot;comment&quot;).text.strip()
    info = tags.find_all(class_=&quot;item-after light&quot;)

    fq_rec = getListElement(info, 1)
    fq_diff = getListElement(info, 2)
    fq_transmit = getListElement(info, 3)
    mute = getListElement(info, 4)

    return {
        &quot;name&quot;: name,
        &quot;R&quot;: fq_rec,
        &quot;diff&quot;: fq_diff,
        &quot;T&quot;: fq_transmit,
        &quot;CSDT&quot;: mute
    }


def getCityRelayUrl_Generator(cityUrl):
    &quot;&quot;&quot;找到一个城市中继页面的URL&quot;&quot;&quot;
    with httpx.Client(headers=header) as client:
        resp = client.get(url % cityUrl)
    # create parser object
    soup = BeautifulSoup(resp.text, 'html.parser')
    tags = soup.find(
        class_=&quot;list-block media-list comment&quot;
    ).find_all(&quot;a&quot;)

    for tag in tags:
        yield url % tag[&quot;href&quot;]


def writeCSV(file, res_dict: dict = None, header=False, title: str = None):
    if title:
        file.write(&quot;\n%s\n&quot; % title)

    fieldnames = [&quot;名称&quot;, &quot;接收频率&quot;, &quot;频差&quot;, &quot;发射频率&quot;, &quot;哑音&quot;]
    writer = csv.DictWriter(file, fieldnames=fieldnames)

    if header:
        writer.writeheader()

    if res_dict:
        writer.writerow({
            &quot;名称&quot;: res_dict[&quot;name&quot;],
            &quot;接收频率&quot;: res_dict[&quot;R&quot;],
            &quot;频差&quot;: res_dict[&quot;diff&quot;],
            &quot;发射频率&quot;: res_dict[&quot;T&quot;],
            &quot;哑音&quot;: res_dict[&quot;CSDT&quot;],
        }
        )


def main():
    # 写入 csv 文件
    # ANSI 使得 excel 打开不会乱码
    # newline 定义新一行的空格
    with open(&quot;%s&quot; % Path(current_dir, &quot;广东中继总表.csv&quot;), 'w', encoding=&quot;ANSI&quot;, newline='') as csvfile:
        for url in urlsss:
            print(&quot;正在爬取...%s&quot; % url[0])
            writeCSV(csvfile, header=True, title=&quot;%s&quot; % url[0])
            for relay_url in getCityRelayUrl_Generator(url[1]):
                data_dict = parser(relay_url)
                print(data_dict)
                writeCSV(csvfile, data_dict)
            print(&quot;%s爬取结束!&quot; % url[0])


if __name__ == &quot;__main__&quot;:
    main()
    print(&quot;DONE!&quot;)
</code></pre>
<p>‍</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other"><a class="header" href="#other">other</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="openai-key"><a class="header" href="#openai-key">OPENAI KEY</a></h1>
<p>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</p>
<p>‍</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="广东佛山-2023-年中考"><a class="header" href="#广东佛山-2023-年中考">广东佛山 2023 年中考</a></h1>
<h2 id="时间安排"><a class="header" href="#时间安排">时间安排</a></h2>
<p><img src="other/assets/Pasted%20image%2020230626155025.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="写给-v-友兼-ham-友的一段话"><a class="header" href="#写给-v-友兼-ham-友的一段话">写给 v 友兼 ham 友的一段话</a></h1>
<h2 id="原贴"><a class="header" href="#原贴">原贴</a></h2>
<p><img src="other/Screenshot_20230626-002517_V2er%202.png" alt="" /></p>
<p>我的情况和你差不多，甚至可以说比你更差，我初二那年确诊重抑，高中就变成双相情感了。现在高二，前段时间因为上课睡觉一位老师的掐住脖子，然后惊恐抑郁发作就跳楼了（没跳成）校方后来以我“扰乱教学秩序”为由强迫我停学，并开除处理，目前的状态也是家里蹲。</p>
<p>我这双相是记录到国家档案的，居委会还会来问。（我还得了各种病：心肌炎、慢性胃炎，可真是折磨啊，活着真是浪费社会自由）学校的开除也有它的道理，已经申请了复议（但是学校是重高，有后台，不好操作），没办法。我毕竟已经吃药控制 4 年了，无数次的想离开这个世界，写过 5 万字的遗书，但又被小猫和“白月光”拉回来。</p>
<p>我也喜欢弄程序，Golang Gin Vue Python Flask JavaScript Typescript 之类的也会点，在家没事干就弄了台 x86 的小主机装各种 Linux 系统，折腾各种 Nas，也能算上半个运维了。运气好的话也可以接接单写一下程序毕设啥的，赚一下猫猫的猫砂和猫粮。（家里养了一只狸花和大橘，小猫真的太治愈辣！）</p>
<p>至于学业，我已经完全脱离学校进度了，目前大概已经把高中数学过了一遍（看 b 站一数的视频咯，然后用 Obsidian 做笔记）也在学习英语，毕竟想润出去，起码西方国家的人文关怀社会环境对我来说好些。在洼地有这个双相的 tag 走到哪里都是关注对象。其实在家就喂猫，学数学，看 YT TED 演讲，背单词，玩无线电（我也是一只 ham），做家务。</p>
<p>和父母关系也不太好，我的精神问题有很大的一部分就是因为原生家庭。但是现在寄人篱下我也不好意思。他们愤怒骂我不争气不懂事，他们惶恐担心我的未来也担心他们的晚年。</p>
<p>感觉 OP 一年半脱离学校能考到 U 段天线中心频点的分数已经很厉害了，我高二上学期期末考也就 410 多，就数学，地理的成绩能看看（我选的物化地），也是大专的料子，在这个学历贬值的体系下，在大环境异常艰难的今天，我真的不知道你我的出路在哪里，只能说步履艰难，颠沛流离，这也是你我的命运。</p>
<p>OP 不要怕，有些 V 友可能建议你复读、参军、打工、暴叔、大专、摆烂、走线，更有甚者质疑你的技术，指责你为何不按照大众价值观按部就班的过完别人的一生，嘲笑你懦弱、无能、逃避，殊不知你是经过多少苦难才走到今天。</p>
<p>同是苦命人，就不说虚的了，祝福 OP 能通过补录拿到三本的录取，这是再好不过的了。如果 OP 真想离开这个世界，那就不留遗憾，永世不留人间。</p>
<p>（可能写的有点乱，OP 见谅。）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模拟飞行"><a class="header" href="#模拟飞行">模拟飞行</a></h1>
<p>rfs 模拟飞行论坛 <a href="https://starry.sky.lucloud.top/">https://starry.sky.lucloud.top/</a></p>
<p>rfs 按键翻译：<a href="https://starry.sky.lucloud.top/archives/1894">https://starry.sky.lucloud.top/archives/1894</a></p>
<p>低配笔记本电脑适合运行 FSX、P3DV4</p>
<h2 id="rfs-模拟飞行"><a class="header" href="#rfs-模拟飞行">RFS 模拟飞行</a></h2>
<h3 id="主界面"><a class="header" href="#主界面">主界面</a></h3>
<p>​<img src="http://oss.whaleluo.top//blog/img/202306252215584.png-picsmall" alt="image" />​</p>
<h3 id="地面服务系统"><a class="header" href="#地面服务系统">地面服务系统</a></h3>
<p>​<img src="http://oss.whaleluo.top//blog/img/202306252215586.png-picsmall" alt="image" />​</p>
<h3 id="主警报系统"><a class="header" href="#主警报系统">主警报系统</a></h3>
<p>​<img src="http://oss.whaleluo.top//blog/img/202306252215587.png-picsmall" alt="image" />​</p>
<h3 id="地面装载"><a class="header" href="#地面装载">地面装载</a></h3>
<p>​<img src="http://oss.whaleluo.top//blog/img/202306252215588.png-picsmall" alt="image" />​</p>
<h3 id="自动驾驶"><a class="header" href="#自动驾驶">自动驾驶</a></h3>
<p>​<img src="http://oss.whaleluo.top//blog/img/202306252215589.png-picsmall" alt="image" />​</p>
<h3 id="地面绕机检查"><a class="header" href="#地面绕机检查">地面绕机检查</a></h3>
<p>​<img src="http://oss.whaleluo.top//blog/img/202306252215590.png-picsmall" alt="image" />​</p>
<h3 id="主系统"><a class="header" href="#主系统">主系统</a></h3>
<p>​<img src="http://oss.whaleluo.top//blog/img/202306252215591.png-picsmall" alt="image" />​</p>
<h3 id="飞行检查单"><a class="header" href="#飞行检查单">飞行检查单</a></h3>
<p>​<img src="http://oss.whaleluo.top//blog/img/202306252215592.png-picsmall" alt="image" /> </p>
<h3 id="引擎"><a class="header" href="#引擎">引擎</a></h3>
<p>​<img src="http://oss.whaleluo.top//blog/img/202306252215593.png-picsmall" alt="image" />​</p>
<h3 id="地面紧急服务"><a class="header" href="#地面紧急服务">地面紧急服务</a></h3>
<p>​<img src="http://oss.whaleluo.top//blog/img/202306252215594.png-picsmall" alt="image" />​</p>
<h3 id="燃料系统"><a class="header" href="#燃料系统">燃料系统</a></h3>
<p>​<img src="http://oss.whaleluo.top//blog/img/202306252215595.png-picsmall" alt="image" />​</p>
<p>‍</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="study"><a class="header" href="#study">Study</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="physical"><a class="header" href="#physical">Physical</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第六讲"><a class="header" href="#第六讲">第六讲</a></h1>
<h2 id="牛顿运动定律"><a class="header" href="#牛顿运动定律">牛顿运动定律</a></h2>
<h3 id="牛顿第二定律"><a class="header" href="#牛顿第二定律">牛顿第二定律</a></h3>
<p>弹簧问题</p>
<p><img src="Study/Physical/assets/%E7%AC%AC%E5%85%AD%E8%AE%B2-%E5%BC%B9%E7%B0%A7%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.png" alt="" /></p>
<p><img src="Study/Physical/assets/%E7%AC%AC%E5%85%AD%E8%AE%B2-P57%20%E4%BE%8B%E4%B8%80.png" alt="" /></p>
<p><img src="Study/Physical/assets/%E7%AC%AC%E5%85%AD%E8%AE%B2-P58-%E7%BB%83%E4%B9%A01-1.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第一讲---运动的描述"><a class="header" href="#第一讲---运动的描述">第一讲 - 运动的描述</a></h1>
<h2 id="速度和速率"><a class="header" href="#速度和速率">速度和速率</a></h2>
<p><img src="Study/Physical/Study/Physical/assets/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E8%BF%90%E5%8A%A8%E7%9A%84%E6%8F%8F%E8%BF%B0-%E9%80%9F%E5%BA%A6%E5%92%8C%E9%80%9F%E7%8E%87.png" alt="" /></p>
<h2 id="一半路程一半时间-求平均速度"><a class="header" href="#一半路程一半时间-求平均速度">一半路程/一半时间 求平均速度</a></h2>
<p><img src="Study/Physical/Study/Physical/assets/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E8%BF%90%E5%8A%A8%E7%9A%84%E6%8F%8F%E8%BF%B0-%E5%B9%B3%E5%9D%87%E9%80%9F%E5%BA%A6.png" alt="" /></p>
<p>例题：</p>
<p><img src="Study/Physical/Study/Physical/assets/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E8%BF%90%E5%8A%A8%E7%9A%84%E6%8F%8F%E8%BF%B0-%E5%88%97%E6%96%B9%E7%A8%8B%E8%A7%A3%E9%A2%98.png" alt="" /></p>
<h2 id="加速度"><a class="header" href="#加速度">加速度</a></h2>
<h3 id="定义"><a class="header" href="#定义">定义</a></h3>
<p><img src="Study/Physical/Study/Physical/assets/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E8%BF%90%E5%8A%A8%E7%9A%84%E6%8F%8F%E8%BF%B0-%E5%8A%A0%E9%80%9F%E5%BA%A6%E5%AE%9A%E4%B9%89.png" alt="" /></p>
<p>加减速判定：</p>
<p><img src="Study/Physical/Study/Physical/assets/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E8%BF%90%E5%8A%A8%E7%9A%84%E6%8F%8F%E8%BF%B0-%E5%8A%A0%E5%87%8F%E9%80%9F%E5%88%A4%E5%AE%9A.png" alt="" /></p>
<p><img src="Study/Physical/Study/Physical/assets/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E8%BF%90%E5%8A%A8%E7%9A%84%E6%8F%8F%E8%BF%B0-1.png" alt="" /></p>
<h2 id="匀变速直线运动"><a class="header" href="#匀变速直线运动">匀变速直线运动</a></h2>
<p>公式，知三求一，x,t,v,a</p>
<p><img src="Study/Physical/Study/Physical/assets/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E8%BF%90%E5%8A%A8%E7%9A%84%E6%8F%8F%E8%BF%B0-%E5%85%AC%E5%BC%8F.png" alt="" /></p>
<h3 id="刹车问题"><a class="header" href="#刹车问题">刹车问题</a></h3>
<p><img src="Study/Physical/Study/Physical/assets/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E8%BF%90%E5%8A%A8%E7%9A%84%E6%8F%8F%E8%BF%B0-%E5%88%B9%E8%BD%A6%E9%97%AE%E9%A2%98.png" alt="" /></p>
<ol>
<li>确定是否停止，计算停止的时间。</li>
<li>求路程，注意加速度的方向正负。</li>
</ol>
<h3 id="易错"><a class="header" href="#易错">易错</a></h3>
<ol>
<li>从匀速减速到 0 再反向加速。</li>
</ol>
<h2 id="x-t-v-t-图像"><a class="header" href="#x-t-v-t-图像">X-T V-T 图像</a></h2>
<h3 id="x-t-图像"><a class="header" href="#x-t-图像">X-t 图像</a></h3>
<p><img src="Study/Physical/Study/Physical/assets/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E8%BF%90%E5%8A%A8%E7%9A%84%E6%8F%8F%E8%BF%B0-v-t-%E5%9B%BE%E5%83%8F.png" alt="" /></p>
<h2 id="vt-图像"><a class="header" href="#vt-图像">Vt 图像</a></h2>
<p><img src="Study/Physical/Study/Physical/assets/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E8%BF%90%E5%8A%A8%E7%9A%84%E6%8F%8F%E8%BF%B0-vt%E5%9B%BE%E5%83%8F.png" alt="" /></p>
<h3 id="匀直中平均速度计算"><a class="header" href="#匀直中平均速度计算">匀直中平均速度计算</a></h3>
<p><img src="Study/Physical/Study/Physical/assets/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E8%BF%90%E5%8A%A8%E7%9A%84%E6%8F%8F%E8%BF%B0-3.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第二讲---比例问题"><a class="header" href="#第二讲---比例问题">第二讲 - 比例问题</a></h1>
<p>数学公式 Latex 识别：<a href="https://simpletex.cn/ai/latex_ocr">公式识别</a></p>
<h2 id="三个推论"><a class="header" href="#三个推论">三个推论</a></h2>
<h3 id="1-比例等时比等位比"><a class="header" href="#1-比例等时比等位比">1. 比例（等时比、等位比）</a></h3>
<p>通过 v-t 图像利用 <strong>相似三角形</strong> 进行推导，在<strong>初末速度为 0 匀加减速直线运动</strong>中：</p>
<p>可以 <strong>忽略加速度</strong> 的实际大小。</p>
<ol>
<li>
<p>等时比：</p>
<ul>
<li>每过 T，<strong>速度</strong> 之比： 1:2:3:4</li>
<li>每过 T，<strong>前 T 位</strong> 移比：1:4:9:16</li>
<li>每过 T ，<strong>第 T 内</strong> 位移比: 1:3:5:7</li>
</ul>
</li>
<li>
<p>等位比：推导同上见图</p>
</li>
</ol>
<p><img src="Study/Physical/assets/%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E7%9B%B4%E7%BA%BF%E8%BF%90%E5%8A%A8-%E6%AF%94%E4%BE%8B.png" alt="" /></p>
<h3 id="2-中时速--平均速度"><a class="header" href="#2-中时速--平均速度">2. 中时速 = 平均速度</a></h3>
<p>$$
V_{\frac{t}{2}}=\frac{V_{0}+V_{1}}{2}=平均速度
$$</p>
<p>用于 <strong>打点计时器</strong> 计算点的瞬间速度。</p>
<p><strong>中间时刻</strong>的瞬时速度 = 全程平均速度</p>
<p><img src="Study/Physical/assets/%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E7%9B%B4%E7%BA%BF%E8%BF%90%E5%8A%A8-%E6%8E%A8%E8%AE%BA%E4%BA%8C%E4%B8%AD%E6%97%B6%E9%80%9F.png" alt="" /></p>
<h3 id="3-等时位移差"><a class="header" href="#3-等时位移差">3. 等时位移差</a></h3>
<p>$$
\Delta x=aT\cdot T=aT^{2}
$$</p>
<p>$$
S_{m^-}S_n=(m-n)\alpha T^2
$$</p>
<p>用于 <strong>打点计时器</strong></p>
<p><img src="Study/Physical/assets/%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E7%9B%B4%E7%BA%BF%E8%BF%90%E5%8A%A8-%E7%AD%89%E6%97%B6%E4%BD%8D%E7%A7%BB%E5%B7%AE.png" alt="" /></p>
<p><strong>匀变速</strong> 直线运动 <strong>相同时间间隔的位移变化相同</strong>。</p>
<p>$$
x_{2}-x_{1}=x_{3}-x_{2}=…=x_{n}-x_{n-1}
$$</p>
<p><img src="Study/Physical/assets/Snipaste_2023-07-11_14-50-48.png" alt="" /></p>
<h2 id="自由落体"><a class="header" href="#自由落体">自由落体</a></h2>
<p><strong>只受重力</strong> G 加速度 g，从<strong>静止</strong>开始。</p>
<h3 id="基本公式"><a class="header" href="#基本公式">基本公式</a></h3>
<p>$$
\begin{aligned}
&amp;v=gt \
&amp;h=\frac{1}{2}gt^{2} \
&amp;v^{2}=2gh
\end{aligned}
$$</p>
<h3 id="应用"><a class="header" href="#应用">应用</a></h3>
<ol>
<li>设时间列位差、中间时刻。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第-7-讲"><a class="header" href="#第-7-讲">第 7 讲</a></h1>
<p><img src="Study/Physical/assets/%E7%AC%AC7%E8%AE%B2-%E5%90%88%E9%80%9F%E5%BA%A6.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第五讲---力的合成与分解"><a class="header" href="#第五讲---力的合成与分解">第五讲 - 力的合成与分解</a></h1>
<h2 id="力的正交分解"><a class="header" href="#力的正交分解">力的正交分解</a></h2>
<p><img src="Study/Physical/assets/%E7%AC%AC5%E8%AE%B2-%E5%8A%9B%E7%9A%84%E6%AD%A3%E4%BA%A4%E5%88%86%E8%A7%A3-1.png" alt="" /></p>
<h2 id="矢量三角形法则"><a class="header" href="#矢量三角形法则">矢量三角形法则</a></h2>
<ol>
<li>固定一条边不动。</li>
<li>挪另外两条边。</li>
</ol>
<p><img src="Study/Physical/assets/%E7%AC%AC5%E8%AE%B2-%E5%8A%9B%E7%9A%84%E6%AD%A3%E4%BA%A4%E5%88%86%E8%A7%A3-%E7%9F%A2%E9%87%8F%E4%B8%89%E8%A7%92%E5%BD%A2.png" alt="" /></p>
<h3 id="动态三角形"><a class="header" href="#动态三角形">动态三角形</a></h3>
<p>角度、边长发生变化。</p>
<p><img src="Study/Physical/assets/%E7%AC%AC5%E8%AE%B2-%E5%8A%9B%E7%9A%84%E6%AD%A3%E4%BA%A4%E5%88%86%E8%A7%A3-%E5%8A%A8%E6%80%81%E4%B8%89%E8%A7%92%E5%BD%A2.png" alt="" /></p>
<p>动态矢量三角形例题：</p>
<p><img src="Study/Physical/assets/%E7%AC%AC5%E8%AE%B2-%E5%8A%9B%E7%9A%84%E6%AD%A3%E4%BA%A4%E5%88%86%E8%A7%A3-%E5%8A%A8%E6%80%81%E4%B8%89%E8%A7%92%E5%BD%A2-%E4%BE%8B%E9%A2%98.png" alt="" /></p>
<h2 id="整体法和隔离法"><a class="header" href="#整体法和隔离法">整体法和隔离法</a></h2>
<h3 id="整体法"><a class="header" href="#整体法">整体法</a></h3>
<p><img src="Study/Physical/assets/%E7%AC%AC5%E8%AE%B2-%E5%8A%9B%E7%9A%84%E6%AD%A3%E4%BA%A4%E5%88%86%E8%A7%A3-%E6%95%B4%E4%BD%93%E6%B3%95.png" alt="" /></p>
<p>条件：</p>
<ol>
<li>大于等于两个物体</li>
<li>状态一致（a 加速度相同）</li>
<li>只求系统的外力</li>
</ol>
<h2 id="牛顿运动定律-1"><a class="header" href="#牛顿运动定律-1">牛顿运动定律</a></h2>
<h3 id="牛二"><a class="header" href="#牛二">牛二</a></h3>
<p><img src="Study/Physical/assets/%E7%AC%AC5%E8%AE%B2-%E5%8A%9B%E7%9A%84%E6%AD%A3%E4%BA%A4%E5%88%86%E8%A7%A3-%E7%89%9B%E4%BA%8C-%E5%8A%A0%E9%80%9F%E5%BA%A6.png" alt="" /></p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p><img src="Study/Physical/assets/%E7%AC%AC5%E8%AE%B2-%E5%8A%9B%E7%9A%84%E6%AD%A3%E4%BA%A4%E5%88%86%E8%A7%A3-%E6%80%BB%E7%BB%93.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chemistry"><a class="header" href="#chemistry">Chemistry</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第一讲-离子反应的基础概念"><a class="header" href="#第一讲-离子反应的基础概念">第一讲 离子反应的基础概念</a></h1>
<p>P4<br />
<img src="Study/Chemistry/" alt="" /><br />
<img src="Study/Chemistry/Study/Chemistry/assets/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E7%A6%BB%E5%AD%90%E5%8F%8D%E5%BA%94%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-P4.png" alt="" /></p>
<p><img src="Study/Chemistry/Study/Chemistry/assets/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E7%A6%BB%E5%AD%90%E5%8F%8D%E5%BA%94%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-note-1.png" alt="" /></p>
<p><img src="Study/Chemistry/Study/Chemistry/assets/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E7%A6%BB%E5%AD%90%E5%8F%8D%E5%BA%94%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-note2.png" alt="" /></p>
<p>少定多变：<br />
<img src="Study/Chemistry/Study/Chemistry/assets/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E7%A6%BB%E5%AD%90%E5%8F%8D%E5%BA%94%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-note3.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="math"><a class="header" href="#math">Math</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数"><a class="header" href="#函数">函数</a></h1>
<p>P31 例题三：<br />
<img src="Study/Math/assets/%E5%87%BD%E6%95%B0.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第一讲---集合与逻辑用语"><a class="header" href="#第一讲---集合与逻辑用语">第一讲 - 集合与逻辑用语</a></h1>
<p><img src="Study/Math/assets/%E7%AC%AC%E4%B8%80%E8%AE%B2-%E9%9B%86%E5%90%88%E4%B8%8E%E5%B8%B8%E7%94%A8%E9%80%BB%E8%BE%91%E7%94%A8%E8%AF%AD-%E5%8F%8C%E6%9B%B2%E7%BA%BF%E5%BF%AB%E9%80%9F%E7%94%BB%E5%9B%BE.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test"><a class="header" href="#test">test</a></h1>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>title: Title
date: 2023-06-25 19:04:51
updated: 2023-06-25 19:04:51
categories: 
tags: []
description: 
thumbnail: 
banner_img:</h2>
<h1 id="未命名"><a class="header" href="#未命名">未命名</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="落落-openwrt-导航页"><a class="header" href="#落落-openwrt-导航页">落落 OpenWRT 导航页</a></h1>
<blockquote>
<p>😅 本页面运行于家中的 OpenWRT，用于承载各种服务。通过 FRP 穿透实现外网访问。</p>
<p>再次感谢 wo25 提供的高速穿透服务！🥳</p>
</blockquote>
<p>FRP 服务端地址: <a href="test/frp.wo25.net">frp.wo25.net</a> 中国 浙江省 台州市 中国联通 IDC</p>
<p>本页面地址: <a href="https://sdr.whaleluo.top:32443/">https://sdr.whaleluo.top:32443/</a></p>
<p>Server IPV6: <a href="http://op.whaleluo.top">http://op.whaleluo.top</a></p>
<p><strong>Tips: 各类地址后面要加上 ​</strong>​**<code>/</code><strong>​</strong>​ 斜杠，<strong>​</strong><del>本人 Nginx 渣渣,无法研究出反向代理后重定向的方法。</del>**</p>
<h2 id="server-status"><a class="header" href="#server-status">Server Status</a></h2>
<p>服务器运行状态监控：<a href="https://sdr.whaleluo.top:32443/status/">https://sdr.whaleluo.top:32443/status/</a></p>
<h2 id="speedtest"><a class="header" href="#speedtest">Speedtest</a></h2>
<p>网速测试,测试通过 frp 到内网的网速.</p>
<p><a href="https://sdr.whaleluo.top:32443/test/">https://sdr.whaleluo.top:32443/test/</a></p>
<p>IPv6 测试,测试直连的速度 (仅支持 IPv6 环境)</p>
<p><a href="http://op.whaleluo.top:8989/">http://op.whaleluo.top:8989/</a></p>
<h2 id="websdr"><a class="header" href="#websdr">WebSDR</a></h2>
<p>用于监听无线电活动</p>
<p><a href="https://sdr.whaleluo.top:32443/sdr/">https://sdr.whaleluo.top:32443/sdr/</a></p>
<h2 id="vmess-服务"><a class="header" href="#vmess-服务">Vmess 服务</a></h2>
<h3 id="client-download"><a class="header" href="#client-download">Client Download</a></h3>
<p>电脑端: <a href="test/v2ray_pc.zip">V2rayN-PC</a> <strong>此版为 5.0 的最后一版,用于兼容老设备</strong> <a href="https://github.com/2dust/v2rayN/releases?page=3">GitHub</a><br />
安卓端:<a href="test/v2ray_an.apk">V2rayNG</a> <strong>Version: 1.8.4</strong> <a href="https://github.com/2dust/v2rayNG/releases">GitHub</a></p>
<h3 id="参数"><a class="header" href="#参数">参数</a></h3>
<p>url: <a href="https://sdr.whaleluo.top:32443/wss/">https://sdr.whaleluo.top:32443/wss/</a> <br />id: <code>5dde3c45-8884-46b2-b0e6-8b04cdc6a578</code>​ <br />alterid: 0 <br />tls: open</p>
<p>Content:</p>
<pre><code class="language-text">dm1lc3M6Ly9ldzBLSUNBaWRpSTZJQ0l5SWl3TkNpQWdJbkJ6SWpvZ0luZHZNalVnYjNBZzVadWU1YTYySWl3TkNpQWdJbUZrWkNJNklDSnpaSEl1ZDJoaGJHVnNkVzh1ZEc5d0lpd05DaUFnSW5CdmNuUWlPaUFpTXpJME5ETWlMQTBLSUNBaWFXUWlPaUFpTldSa1pUTmpORFV0T0RnNE5DMDBObUl5TFdJd1pUWXRPR0l3TkdOa1l6WmhOVGM0SWl3TkNpQWdJbUZwWkNJNklDSXdJaXdOQ2lBZ0luTmplU0k2SUNKaGRYUnZJaXdOQ2lBZ0ltNWxkQ0k2SUNKM2N5SXNEUW9nSUNKMGVYQmxJam9nSW01dmJtVWlMQTBLSUNBaWFHOXpkQ0k2SUNJaUxBMEtJQ0FpY0dGMGFDSTZJQ0l2ZDNOekx5SXNEUW9nSUNKMGJITWlPaUFpZEd4eklpd05DaUFnSW5OdWFTSTZJQ0lpTEEwS0lDQWlZV3h3YmlJNklDSWlEUXA5DQo=
</code></pre>
<h2 id="alist-webdav"><a class="header" href="#alist-webdav">Alist Webdav</a></h2>
<p>url: <a href="https://sdr.whaleluo.top:32443/dav/">https://sdr.whaleluo.top:32443/dav/</a></p>
<p>共享目录、共享的电影、老师、书籍资源，<em><strong><u>==默认只读==</u></strong></em>。</p>
<p>username: public<br />
password: public</p>
<p>‍</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="思源笔记自动同步测试"><a class="header" href="#思源笔记自动同步测试">思源笔记自动同步测试</a></h1>
<p>这是我突然关闭 web 界面写的内容。</p>
<p>这是我突然关闭去另一个客户端查看的内容。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="english-study-英语-remake-笔记"><a class="header" href="#english-study-英语-remake-笔记">English-Study 英语 Remake 笔记</a></h1>
<p><strong>为了早日逃离这个魔幻的国家，学好英语这门语言是必不可少的。</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="音标学习"><a class="header" href="#音标学习">音标学习</a></h1>
<h2 id="学习资源-resource"><a class="header" href="#学习资源-resource">学习资源 Resource</a></h2>
<ol>
<li><a href="https://www.bilibili.com/video/BV1iV411z7Nj/">英语兔全网最适合中国人的免费音标课(纯干货, 超详细!)_哔哩哔哩_bilibili</a></li>
<li><a href="https://space.bilibili.com/483162496">Bilibili 英语兔</a></li>
</ol>
<h2 id="元音辅音"><a class="header" href="#元音辅音">元音、辅音</a></h2>
<p>元音（Vowels）：气流不受阻碍，舌头不与任何口腔部位接触。嘴唇也不能闭上。<br />
辅音（Consonants）：气流受阻碍。</p>
<p><img src="English-Study/assets/Pasted%20image%2020230626153358.png" alt="" /></p>
<h3 id="元音三要素"><a class="header" href="#元音三要素">元音三要素</a></h3>
<p><a href="https://www.bilibili.com/video/BV1iV411z7Nj?p=5">元音三要素 bilibili 英语兔</a></p>
<h2 id="清音浊音"><a class="header" href="#清音浊音">清音、浊音</a></h2>
<p>浊音（Voiced Sound）：声带振动。<br />
清音（Voiceless Sound）：声带不振动。</p>
<p><img src="English-Study/assets/Pasted%20image%2020230626155600.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高中事件"><a class="header" href="#高中事件">高中事件</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="举报信"><a class="header" href="#举报信">举报信</a></h1>
<p>（该教师为现任佛山三中高二级级长、校团委书记廖宇）</p>
<p>在佛山市第三中学，一名教师没收了一名学生的手机。当学生不愿交出手机时，该教师情绪失控，并在教室当着全班人的面用手掐住了学生的脖子，导致该生呼吸不畅、脖子出现红肿的情况，并不礼貌地使用手机拍摄了学生的面部。这一事件导致学生情绪激动，并因其患有抑郁症而做出了跳楼的行为。学生在跳楼过程中被阻拦，导致身上多处擦伤。</p>
<p>事后，该教师否认自己掐住学生脖子的行为，并解释称只是“拍了拍他的脖子”，并声称这是“正当防卫”。然而，在与家长和学校进行沟通时，该教师的态度并不积极。学校要求学生提供精神机构的治疗证明等各种证据，以证明学生有需要复学的必要。此外，该教师还多次劝阻学生转学，并给予学生记过处分。</p>
<p>这一事件对学生的心理造成了严重的创伤。目前，学生正在佛山市第三人民医院精神科接受治疗。经过多次协商无果后，学校要求该生在家反省，并无限期停课处理。</p>
<p>此事件涉及到教师对学生的暴力行为，严重侵犯了学生的人身权利和尊严。教师不仅没有正确处理学生的手机问题，还采取了不当的行为对待学生，这种行为是不可接受的。</p>
<p>根据《中小学教育惩戒规则》第十二条，教师在教育教学管理、实施教育惩戒过程中，不得有下列行为：“超过正常限度的罚站、反复抄写，强制做不适的动作或者姿势，<strong>以及刻意孤立等间接伤害身体、心理的变相体罚。</strong>”第十条：“学生违规违纪情节严重或者影响恶劣的，学校可以实施以下教育惩戒：<strong>给予不超过一周的停课或者停学</strong>，要求家长在家进行教育、管教。”</p>
<p>根据《未成年人保护法》第二十一条、《教育法》第二十一条：“学校、幼儿园、托儿所的教职员工应当尊重未成年人的人格尊严，<strong>不得对未成年人实施体罚、变相体罚或者其他侮辱人格尊严的行为。</strong>”</p>
<p>至于该教师提及因为“正当防卫”而“掐住该生脖子”的法理并不成立。正当防卫是为了使国家、公共利益、本人或者他人的人身、财产和其他权利免受正在进行的不法侵害，而采取的制止不法侵害的行为。教师掐住学生脖子的行为并不符合正当防卫的条件，因为学生并没有进行严重危及人身安全的暴力犯罪，教师采取暴力手段的行为并不能被视为正当防卫。此外，即使教师的行为是为了制止学生违反校规使用手机，也不能使用过度的暴力手段，因为这种行为会对学生的人身权利和尊严造成侵犯。因此，教师的行为不能被视为正当防卫，而应该被视为违反了相关法律法规的暴力行为。</p>
<p>‍</p>
<p>尊敬的有关部门：</p>
<p>我是一名来自佛山三中学生的家长，近日得知了佛山市第三中学一名学生被一名教师暴力对待的事件。我深感震惊和担忧，对于教师使用暴力手段对待学生的行为，我表示强烈谴责。</p>
<p>据了解，该教师在没收学生手机时，情绪失控并使用手掐住了学生的脖子，导致学生呼吸不畅、脖子出现红肿的情况，并不礼貌地使用手机拍摄了学生的面部。这一事件导致学生情绪激动，并因其患有抑郁症而做出了跳楼的行为。学生在跳楼过程中被阻拦，导致身上多处擦伤。</p>
<p>‍</p>
<p>我认为，教师是学生的引路人和榜样，应该以身作则，为学生树立正确的行为模范。但是，该教师的行为却严重侵犯了学生的人身权利和尊严，对学生的心理造成了严重的创伤。而且，学校对学生的处理方式也不够妥善，要求学生提供精神机构的治疗证明等各种证据，以证明学生有需要复学的必要。此外，该教师还多次劝阻学生转学，并给予学生记过处分，这种行为是不可接受的。</p>
<p>我希望有关部门能够对该事件进行彻底的调查，并对相关责任人进行严肃的处理。同时，也希望学校能够重视学生的心理健康问题，为学生提供必要的心理咨询和治疗服务。教师应该以身作则，遵守相关法律法规，尊重学生的人身权利和尊严，为学生的成长和发展提供良好的教育环境。</p>
<p>‍</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="举报中小学教师违规方法论"><a class="header" href="#举报中小学教师违规方法论">举报中小学教师违规方法论</a></h1>
<h2 id="写在前面"><a class="header" href="#写在前面">写在前面</a></h2>
<p>社会总是不公平的，中小学亦是，当自己的合法权利遭受剥夺，例如：被教师体罚打骂不公对待、校园暴力、因疾病被学校停课、被休学、学校违规补课收取不明费用。当冷静、理性的和校方协商无果后，就需要一个第三方参与事情的处理。</p>
<p>但在这个“你法我笑”的国家，向教育局、政府等权力机构的举报可能只是不痛不痒的警告，期间还面临着被“起底”个人信息遭到泄露，被校方“穿小鞋”的风险。但是也不能任凭这种持续性侵害自身人权的事情发生。</p>
<p>笔者写这个方法论，源是一位高中教师（时任高二级级长 校团委书记）在没收我手机时用双手掐住我的脖子，导致我留下严重的心理阴影（PTSD），并出现生命危机的严重后果，校方扬言我影响学校教学秩序，有精神病史（双相）或将把我开除。为了避免校方将我开除学籍，故出此下策，向上级的权力机关举报该名教师的严重违法违纪行为。</p>
<p>最好是将我开除之际，能引起 <strong>社会舆论 ​</strong>的发酵，就足够了。也不奢望上级机构可以实实在在的解决什么问题。</p>
<h3 id="警言"><a class="header" href="#警言">警言</a></h3>
<p>记住一句话，普适于大陆的学校：</p>
<p><strong>有的学校解决问题，有的学校解决提出问题的人。</strong></p>
<h3 id="投诉渠道"><a class="header" href="#投诉渠道">投诉渠道</a></h3>
<p>教育局接到的投诉一般都来自以下几种渠道：</p>
<ol>
<li>直接给教育局打电话投诉</li>
<li>12345 市长热线投诉</li>
<li>信访办投诉</li>
<li>纪委投诉</li>
</ol>
<h2 id="12345-投诉热线"><a class="header" href="#12345-投诉热线">12345 投诉热线</a></h2>
<p><strong>12345 市长热线投诉</strong>。各单位都不喜欢接这种投诉，首先，12345 会非常正式的给教育局出函，要求教育局限期做出书面答复。其次，12345 热线<strong>一旦匿名是绝对保密的</strong>，到教育局的函只会有问题描述和举报人诉求。最后，一旦举报到市长热线，那就必须完全合法合规处理，不能仅仅给学校打电话走个过场了，而是要根据文件规定，走流程、调查取证，如有违规，一定会要求学校整改，算是比较权威的一种投诉渠道。但是缺点是周期比较长，我们这里要求 30 个工作日内答复都可以。</p>
<h2 id="中华人民共和国教育部匿名举报"><a class="header" href="#中华人民共和国教育部匿名举报">中华人民共和国教育部匿名举报</a></h2>
<p><a href="https://hudong.moe.gov.cn/interactive/tsjb/nmjb/index.html">https://hudong.moe.gov.cn/interactive/tsjb/nmjb/index.html</a></p>
<h3 id="受理范围"><a class="header" href="#受理范围">受理范围</a></h3>
<ul>
<li><strong>对教育部</strong>政务服务质量和业务工作方面的投诉举报。</li>
<li>对教育部司局、直属单位领导干部，以及<strong>部直属高校校级领导干部</strong>违纪违法违规和职务犯罪问题的举报。</li>
</ul>
<p><strong>PS：不适用于中小学老师违规的举报</strong></p>
<h3 id="填写样式"><a class="header" href="#填写样式">填写样式</a></h3>
<ol>
<li>被举报者信息。应包括姓名、单位、职务信息。做到“一事一议”，一封举报材料只反映一位被举报人问题。</li>
<li>主要问题。分段书写每个涉嫌违纪违法违规的事实：内容应尽量涵盖时间、地点、涉及人员、违纪违法违规行为、涉及金额（物品）、主要证据、知情人等信息。</li>
<li>附件。请打包上传相关文档、图片等内容。</li>
</ol>
<h2 id="当地教育局政务网站线上信访"><a class="header" href="#当地教育局政务网站线上信访">当地教育局政务网站线上信访</a></h2>
<ol>
<li>
<p>佛山网上信访投诉平台：<a href="https://ts.gdwsxf.gd.gov.cn/fs/web/index">https://ts.gdwsxf.gd.gov.cn/fs/web/index</a></p>
</li>
<li>
<p>佛山市人民政府政务投诉：<a href="http://www.foshan.gov.cn/hdjl/xzts/index.html">http://www.foshan.gov.cn/hdjl/xzts/index.html</a> （主要负责政务人员方面的，可能不适用中小学教师）</p>
</li>
<li>
<p>中共禅城区纪检委员会：<a href="https://guangdong.12388.gov.cn/foshanshi/chanchengqu/">https://guangdong.12388.gov.cn/foshanshi/chanchengqu/</a> （如果涉事教师为党员干部可以试试。“对党组织、党员违反政治纪律、组织纪律、廉洁纪律、<strong>群众纪律、工作纪律、生活纪律</strong>等党的纪律行为的检举控告。”）</p>
<blockquote>
<p>对党组织、党员违反党的纪律行为以及监察对象职务违法、职务犯罪行为请向佛山市纪委监委反映</p>
</blockquote>
</li>
</ol>
<h2 id="案例"><a class="header" href="#案例">案例</a></h2>
<ol>
<li>知乎《那些向教育局投诉学校的同学最后怎么样了？》<a href="https://www.zhihu.com/question/316748169">https://www.zhihu.com/question/316748169</a></li>
</ol>
<p>‍</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="举报法律依据"><a class="header" href="#举报法律依据">举报法律依据</a></h1>
<p>法律分析：老师辱骂学生是违法行为，需要承担的法律责任是由所在学校、其他教育机构或者教育行政部门给予行政处分或者解聘。法律依据：《中华人民共和国教师法》第三十七条 教师有下列情形之一的，由所在学校、其他教育机构或者教育行政部门给予行政处分或者解聘。（一） 故意不完成教育教学任务给教育教学工作造成损失的；<strong>（二） 体罚学生，经教育不改的</strong>；<strong>（三） 品行不良、侮辱学生，影响恶劣的</strong>。<br />
《<a href="https://china.findlaw.cn/fagui/p_1/388044.html">中华人民共和国义务教育法</a>》第二十九条 教师在教育教学中应当平等对待学生，关注学生的个体差异，因材施教，促进学生的充分发展。教师应当尊重学生的人格，不得歧视学生，不得对学生实施体罚、变相体罚或者其他侮辱人格尊严的行为，不得侵犯学生合法权益。<br />
《<a href="https://china.findlaw.cn/fagui/p_1/357793.html">中华人民共和国未成年人保护法</a>》第三条 未成年人享有生存权、发展权、受保护权、参与权等权利，国家根据未成年人身心发展特点给予特殊、优先保护，保障未成年人的合法权益不受侵犯。未成年人享有受教育权，国家、社会、学校和家庭尊重和保障未成年人的受教育权。未成年人不分性别、民族、种族、家庭财产状况、宗教信仰等，依法平等地享有权利。<br />
第六条 保护未成年人，是国家机关、武装力量、政党、社会团体、企业事业组织、城乡基层群众性自治组织、<a href="https://www.findlaw.cn/zongze/ft27/">未成年人的监护人</a> 和其他成年公民的共同责任。对侵犯未成年人合法权益的行为，任何组织和个人都有权予以劝阻、制止或者向有关部门提出检举或者控告。国家、社会、学校和家庭应当教育和帮助未成年人维护自己的合法权益，增强自我保护的意识和能力，增强社会责任感。</p>
<p>‍</p>
<p>中小学教育惩戒规则（试行）：<a href="https://www.gov.cn/zhengce/zhengceku/2020-12/29/content_5574650.htm">https://www.gov.cn/zhengce/zhengceku/2020-12/29/content_5574650.htm</a></p>
<p>‍</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="博客文章"><a class="header" href="#博客文章">博客文章</a></h1>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Title<br />
date: 2023-05-23 00:02:35<br />
updated: 2023-05-23 00:02:35<br />
categories:<br />
tags: []<br />
description:<br />
thumbnail:<br />
banner_img:</p>
<hr />
<h1 id="博客文章测试"><a class="header" href="#博客文章测试">博客文章测试</a></h1>
<p>​<img src="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/assets/ImageSelector_20230530_164933-20230530212302-5pjwm2y.jpeg" alt="ImageSelector_20230530_164933" />​</p>
<p>‍</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Vscode 常用快捷键
date: 2023-09-09 20:53:80
updated: 2023-09-09 20:53:80
categories:</p>
<ul>
<li>Vscode
tags:</li>
<li>Vscode</li>
<li>Vim
description: 
thumbnail: 
banner_img:</li>
</ul>
<hr />
<h1 id="vscode-常用快捷键"><a class="header" href="#vscode-常用快捷键">Vscode 常用快捷键</a></h1>
<p>无线老鼠坏了，所以只能依靠触控板和键盘进行编程，呜呜呜！无奈之下只能学习一下 Vscode 的快捷键了。</p>
<h2 id="编辑文字相关"><a class="header" href="#编辑文字相关">编辑文字相关</a></h2>
<ol>
<li><strong>移动行</strong>：alt+up/down</li>
<li><strong>行增加/减少缩进:</strong> ctrl + [ or ]</li>
<li><strong>选中文字</strong>：shift + left / right / up / down</li>
<li><strong>视图滚动</strong>：Ctrl+up / down</li>
<li><strong>隔单词跳转</strong>：Ctrl+ left / right</li>
<li><strong>快速回到顶部</strong> ： ctrl + Fn +home</li>
<li><strong>快速回到底部</strong> : ctrl + Fn + end</li>
<li><strong>选择整行</strong> CTRL + L </li>
<li><strong>删除整行</strong> CTRL + SHIFT + K / Ctrl+d</li>
<li>|Home| <strong>光标跳转行头</strong>| |End|<strong>光标跳转行尾</strong>|</li>
<li><strong>回到上一次编辑的位置</strong>：Alt + ←</li>
<li><strong>单词删除</strong>：Ctrl+Backspace</li>
<li>Delete <strong>右删除</strong> Backspace <strong>退格 左删除</strong></li>
</ol>
<h2 id="页面相关"><a class="header" href="#页面相关">页面相关</a></h2>
<ol>
<li><strong>显示/隐藏左侧目录栏</strong> ctrl + b</li>
<li><strong>控制台终端显示与隐藏</strong>：ctrl + ~</li>
<li><strong>关闭编辑器窗口</strong> : ctrl + w</li>
<li><strong>关闭所有窗口 :</strong> ctrl + k + w</li>
<li><strong>显示当前文件所有符号 (函数)</strong>：ctrl + shift + O</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="博客文章-_post"><a class="header" href="#博客文章-_post">博客文章 _post</a></h1>
<p>博客的文章，先在 siyun 编辑好，然后在电脑上导出 Markdown 文本（包含图片）上传到图床，编辑元信息，再 git 传到 GitHub pages hexo 博客。为了与博客目录保持统一，该节点下的文章标题一律以英文为标准，例如：<code>github-useful-ways</code>​</p>
<p>看样子还不错，垃圾的 mt3275m 平板也可以在线写作了，真的是泰裤辣！</p>
<p>泰裤辣 泰裤辣 泰裤辣 只是要强依赖于互联网😘</p>
<p>‍</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="_posts"><a class="header" href="#_posts">_posts</a></h1>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: 😃 树莓派折腾手册 (一)——准备系统 😃
date: 2021-06-18 19:37:48
updated: 2021-06-18 19:37:48
categories: Linux
tags: [Respi, Linux]
description:
thumbnail: http://oss.whaleluo.top/blog/old/20210619154345.jpg
banner_img: http://oss.whaleluo.top/blog/old/20210619154345.jpg</p>
<hr />
<h1 id="-树莓派折腾手册-一准备系统-"><a class="header" href="#-树莓派折腾手册-一准备系统-">😃 树莓派折腾手册 (一)——准备系统 😃</a></h1>
<h2 id="烧录官方-debian-10-buster-系统镜像"><a class="header" href="#烧录官方-debian-10-buster-系统镜像">烧录官方 <code>Debian 10 buster</code> 系统镜像</a></h2>
<p>先用 <strong>SDFormatter</strong> 格式化一下内存卡叭:</p>
<p><img src="http://oss.whaleluo.top/blog/old/20210619152409.png-picsmall" alt="hZkDB8qxtRgQz3S" /></p>
<h3 id="1-烧写镜像用到的软件-win32-disk-image"><a class="header" href="#1-烧写镜像用到的软件-win32-disk-image">1. 烧写镜像用到的软件： <strong>Win32 Disk Image</strong></a></h3>
<p><img src="http://oss.whaleluo.top/blog/old/20210619152403.png-picsmall" alt="Zb6CEHnf17oqO5Q" /></p>
<ul>
<li>然后在 U 盘的根目录建立一个空白的 <strong>ssh 文件 方便 ssh 远程连接</strong><br />
<img src="http://oss.whaleluo.top/blog/old/sasw.png-picsmall" alt="FV5qpvWz7LtsOgi" /></li>
<li>用 <strong>Windows PowerShell</strong> 连接树莓派 ssh<br />
<code>shift+右键</code> 呼出<strong>Windows PowerShell</strong><br />
<strong>完整连接语法</strong>:</li>
</ul>
<pre><code class="language-shell">ssh -p 端口号 用户名@主机地址
</code></pre>
<blockquote>
<p>树莓派默认的用户名 <strong>pi</strong> 密码 <strong>raspberry</strong><img src="http://oss.whaleluo.top/blog/old/20210619152448.png-picsmall" alt="QLA74lscbwzRWY2" /></p>
</blockquote>
<ul>
<li>树莓派扩展 TF 卡分区:<br />
sudo raspi-config --&gt; Advanced options --&gt;Expand Filesystem, 确认重启</li>
</ul>
<h3 id="2-启动树莓派-hdmi-功能"><a class="header" href="#2-启动树莓派-hdmi-功能">2. 启动树莓派 HDMI 功能</a></h3>
<ul>
<li>
<p>编辑 <code>config.txt</code> 文件，修改以下参数:<br />
sudo nano /boot/config.txt</p>
<ul>
<li>把下面#注释符号去掉<br />
hdmi_force_hotplug=1 #启用HDMI热插拔功能<br />
config_hdmi_boost=4 #启用加强HDMI信号</li>
</ul>
<blockquote>
<p>不出意外的话应该可以接上，但是我的没有声音输出诶<br />
注：如果还是不能的话，找到#hdmi_group=1 这句话，把前面的#注释符号去掉，把数字改成 2 强行指定显示器类型：1 是连接老式电视，2 代表连接新电视。</p>
</blockquote>
</li>
</ul>
<h2 id="树莓派-debian-10-buster-换清华源"><a class="header" href="#树莓派-debian-10-buster-换清华源">树莓派 <code>Debian 10 buster</code> 换清华源</a></h2>
<pre><code class="language-shell">sudo nano /etc/apt/sources.list
deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib
deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib

sudo nano /etc/apt/sources.list.d/raspi.list
deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui
</code></pre>
<ul>
<li>更新源列表: <code>sudo apt-get update</code></li>
<li>更新软件版本，升级软件包: <code>sudo apt-get upgrade</code></li>
</ul>
<h2 id="树莓派-rasp-config-相关设置"><a class="header" href="#树莓派-rasp-config-相关设置">树莓派 <code>rasp-config</code> 相关设置</a></h2>
<h3 id="1-设置-piroot-用户密码并解锁"><a class="header" href="#1-设置-piroot-用户密码并解锁">1. 设置 pi，root 用户密码，并解锁</a></h3>
<pre><code class="language-shell">#树莓派修改密码，顺便解锁root用户
sudo passwd pi
sudo passwd root
#解锁root用户
sudo passwd --unlock root
#如果想在终端直接用root用户登录，编辑
sudo nano /etc/ssh/sshd_config
修改 PermitRootLogin without-password 为 PermitRootLogin yes
</code></pre>
<h3 id="2-respi-本地化操作"><a class="header" href="#2-respi-本地化操作">2. <strong>respi 本地化</strong>操作</a></h3>
<ul>
<li>安装中文字体，提供几个 Linux 中文字体库:</li>
</ul>
<pre><code class="language-shell">sudo apt-get install xfonts-wqy
sudo apt-get install ttf-wqy-zenhei ttf-wqy-microhei
</code></pre>
<ul>
<li>设置终端中文显示: <code>sudo raspi-config</code>:<br />
选择 change_locale，在 Default locale for the system environment: 中选择 zh_CN.UTF-8。<br />
往下翻一会儿直到找到 zh_CN UTF-8 把光标移动到前面，然后按下空格键打上 *<br />
<img src="http://oss.whaleluo.top/blog/old/20210619152513.png-picsmall" alt="3hQeD8k9L1mgTZc" /></li>
<li>改变键盘布局: <code>sudo dpkg-reconfigure keyboard-configuration</code></li>
</ul>
<h3 id="3-设置-vnc-桌面-连接"><a class="header" href="#3-设置-vnc-桌面-连接">3. 设置 Vnc 桌面 连接</a></h3>
<blockquote>
<p>注: 这里放弃了树莓派自带的 <strong>realvnc</strong> 因为不支持网页 <strong>novnc</strong> 且功能很少，所以用 <strong>Tightvnc</strong> 代替</p>
</blockquote>
<ul>
<li>安装<strong>Tightvncserver</strong>: <code>sudo apt-get install tightvncserver</code></li>
<li>安装好之后设置一个<strong>VNC 密码</strong>: vncpasswd</li>
</ul>
<blockquote>
<p>注: 先输入操作密码两次，然后会询问是否设置一个查看 (view-only) 密码，按自己喜欢，一般没必要。</p>
</blockquote>
<ul>
<li>设置<strong>开机自启动</strong> :</li>
</ul>
<blockquote>
<p>设置<strong>开机启动</strong>，需要在 <strong>/etc/init.d/</strong> 中创建一个文件。例如<strong>tightvncserver</strong>: (启动脚本的名称，有和程序名一致的习惯)</p>
</blockquote>
<pre><code class="language-sh">sudo nano /etc/init.d/tightvncserver
# 内容如下:
#!/bin/sh
### BEGIN INIT INFO
# Provides:          tightvncserver
# Required-Start:    $local_fs
# Required-Stop:     $local_fs
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Start/stop tightvncserver
### END INIT INFO

# More details see:
# http://www.penguintutor.com/linux/tightvnc

### Customize this entry
# Set the USER variable to the name of the user to start tightvncserver under
export USER='pi'
### End customization required

eval cd ~$USER

case &quot;$1&quot; in
  start)
    # 启动命令行。此处自定义分辨率、控制台号码或其它参数。
    su $USER -c '/usr/bin/tightvncserver -depth 16 -geometry 800x600 :1'
    echo &quot;Starting TightVNC server for $USER &quot;
    ;;
  stop)
    # 终止命令行。此处控制台号码与启动一致。
    su $USER -c '/usr/bin/tightvncserver -kill :1'
    echo &quot;Tightvncserver stopped&quot;
    ;;
  *)
    echo &quot;Usage: /etc/init.d/tightvncserver {start|stop}&quot;
    exit 1
    ;;
esac
exit 0
</code></pre>
<p>然后给<strong>tightvncserver 文件</strong>加<strong>执行权限</strong>：</p>
<pre><code class="language-shell">sudo chmod 755 /etc/init.d/tightvncserver
</code></pre>
<p>并更新<strong>开机启动列表</strong>：</p>
<pre><code class="language-shell">sudo update-rc.d tightvncserver defaults
</code></pre>
<p>一些<strong>service 命令</strong> :</p>
<pre><code class="language-shell">sudo service tightvncserver restart #重启服务
sudo service tightvncserver start/stop #关闭/开启服务
sudo service tightvncserver status #查看服务运行状态
</code></pre>
<blockquote>
<p>附: vnc 客户端下载<br />
<a href="https://www.realvnc.com/en/connect/download/viewer/">vnc官网</a></p>
</blockquote>
<p>连接成功惹~:<br />
<img src="http://oss.whaleluo.top/blog/old/20210619152521.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/old/20210619152531.png-picsmall" alt="" /><br />
编辑 ./vnc/xstartup 配置文件使其能与 windown 共享剪贴板</p>
<pre><code class="language-shell">sudo nano .vnc/xstartup

#在后方追加
vncconfig -nowin -iconic &amp;
#重启Tightvncserver
sudo service tightvncserver restart
</code></pre>
<h3 id="4部署novnc-网页"><a class="header" href="#4部署novnc-网页">4.部署<strong>novnc 网页</strong></a></h3>
<blockquote>
<p>方便在网页上控制树莓派屏幕，但是<strong>不支持 realvnc</strong></p>
</blockquote>
<ul>
<li>安装 <strong>git 支持</strong></li>
</ul>
<pre><code class="language-shell">sudo apt-get install git
</code></pre>
<ul>
<li><strong>克隆</strong> novnc 项目:</li>
</ul>
<blockquote>
<p>在中国大陆听说~~加上 ​~~​~~**<del>​~~​ 就可以加速 ​~~​</del><strong>克隆</strong><del>​~~​ 速度丫</del> 改口 应换成 <a href="https://github.com.cnpmjs.org/">https://github.com.cnpmjs.org/</a></p>
</blockquote>
<pre><code class="language-shell">git clone https://github.com/kanaka/noVNC #源地址
git clone https://github.com.cnpmjs.org/kanaka/noVNC #加速地址
</code></pre>
<ul>
<li>运行 <strong>novnc</strong> 并设置<strong>开机自启动</strong>:</li>
</ul>
<pre><code class="language-shell">cd noVNC
# 初始化可能有点点慢
./utils/launch.sh --vnc localhost:5901 #监听5901 vnc端口
</code></pre>
<p><img src="http://oss.whaleluo.top/blog/old/20210619152538.png-picsmall" alt="" /></p>
<ul>
<li>尝试访问: <a href="http://raspiberry:6080">http://raspiberry:6080</a> 可<br />
<img src="http://oss.whaleluo.top/blog/old/20210619152542.png-picsmall" alt="" /></li>
<li>一些<strong>高级设置</strong> :</li>
</ul>
<pre><code class="language-shell">./utils/websockify --web ./ 8787 localhost:5901  #修改6080默认端口
./utils/websockify --web ./ 8787 192.168.1.10:5901 #可以讲localhost改成所有安装了vncserver的IP地址
</code></pre>
<p><strong>连接速度太慢可以安装 Python 的 numpy 库解决</strong></p>
<ul>
<li>设置<strong>开机启动</strong>：</li>
</ul>
<pre><code class="language-shell">#编辑开机启动项
sudo nano /etc/rc.local
#以pi用户运行程序
su pi -c &quot;/home/pi/noVNC/utils/launch.sh --vnc localhost:5901&quot; &amp;
</code></pre>
<p><img src="http://oss.whaleluo.top/blog/old/20210619152617.png-picsmall" alt="fEVci5dlNCMaUs4" /></p>
<h3 id="5安装-cockpit-web-可视化管理"><a class="header" href="#5安装-cockpit-web-可视化管理">5.安装 <code>cockpit</code> Web 可视化管理</a></h3>
<pre><code class="language-shell">sudo apt-get update
sudo apt-get install cockpit
</code></pre>
<blockquote>
<p>安装的依赖有 <strong>一丢丢多</strong></p>
</blockquote>
<ul>
<li>默认是用 <code>https</code> 访问，需要修改配置文件使其能 <code>http</code> 访问</li>
</ul>
<pre><code class="language-shell">sudo nano /etc/cockpit/cockpit.conf #这个文件默认是不存在的需要新建

[WebService]
AllowUnencrypted=true
LoginTitle=鲸云pi
</code></pre>
<ul>
<li>配置<strong>开机启动</strong></li>
</ul>
<pre><code class="language-shell">sudo systemctl enable cockpit.socket
sudo systemctl start cockpit.socket
</code></pre>
<ul>
<li>
<p>页面</p>
<p><img src="http://oss.whaleluo.top/blog/old/20210619152626.png-picsmall" alt="image-20200805174634421" /></p>
</li>
</ul>
<h2 id="python-设置"><a class="header" href="#python-设置">Python 设置</a></h2>
<h3 id="概况"><a class="header" href="#概况">概况</a></h3>
<blockquote>
<p>树莓派默认安装了两个版本的<strong>Python</strong></p>
</blockquote>
<p><img src="http://oss.whaleluo.top/blog/old/20210619152632.png-picsmall" alt="" /></p>
<h3 id="树莓派-pip-换源"><a class="header" href="#树莓派-pip-换源">树莓派 Pip 换源</a></h3>
<blockquote>
<p><strong>pip</strong>更换为<strong>国内源</strong>，可以大大的提高安装成功率和速度。不管你用的是<strong>pip3 还是 pip，方法都是一样的</strong></p>
</blockquote>
<pre><code class="language-shell">mkdir ~/.pip
nano ~/.pip/pip.conf

#写入
[global]
timeout = 5000
index-url = https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple
[install]
use-mirrors = true
mirrors = https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple
</code></pre>
<ul>
<li><strong>更新 pip 版本</strong></li>
</ul>
<pre><code class="language-shell">python3 -m pip install --upgrade pip
</code></pre>
<p><img src="http://oss.whaleluo.top/blog/old/20210619152649.png-picsmall" alt="seVOiSZrBKgE827" /></p>
<ul>
<li><strong>树莓派指定 Python 版本安装模块</strong></li>
</ul>
<pre><code class="language-shell">sudo pip3 install XXX   #Python3版本
sudo pip install XXX   #Python2版本
</code></pre>
<h2 id="部署-zsh"><a class="header" href="#部署-zsh">部署 Zsh</a></h2>
<pre><code class="language-shell">sh -c &quot;$(wget -O- https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)&quot;

git clone https://github.com.cnpmjs.org/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions

 git clone https://github.com.cnpmjs.org/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting
 
 ZSH_DISABLE_COMPFIX=true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: 基于 Openwebrx 搭建 Rsp1 Websdr
date: 2023-04-29 15:51:48
updated: 2023-04-29 15:59:48
categories: Radio
tags: [Ham, Radio, 业余无线电, 软件无线电, Openwebrx]</p>
<hr />
<h1 id="基于-openwebrx-搭建-rsp1-websdr"><a class="header" href="#基于-openwebrx-搭建-rsp1-websdr">基于 Openwebrx 搭建 Rsp1 Websdr</a></h1>
<p><a href="https://www.openwebrx.de/">Openwebrx</a></p>
<p>本文参考：<a href="https://github.com/jketterl/openwebrx/wiki/">https://github.com/jketterl/openwebrx/wiki/</a></p>
<h2 id="安装依赖"><a class="header" href="#安装依赖">安装依赖</a></h2>
<pre><code class="language-sh">sudo apt-get update
sudo apt-get install git build-essential cmake libfftw3-dev python3 python3-setuptools rtl-sdr netcat libsndfile-dev librtlsdr-dev automake autoconf libtool pkg-config libsamplerate-dev libpython3-dev
</code></pre>
<h2 id="install-csdr"><a class="header" href="#install-csdr">Install Csdr</a></h2>
<pre><code class="language-sh">git clone -b master https://github.com/jketterl/csdr.git
cd csdr
mkdir build
cd build
cmake ..
make
sudo make install
cd ../..
sudo ldconfig
</code></pre>
<h2 id="install-pysdr"><a class="header" href="#install-pysdr">Install Pysdr</a></h2>
<pre><code class="language-sh">git clone -b master https://github.com/jketterl/pycsdr.git
cd pycsdr
sudo python3 setup.py install install_headers
cd ..
</code></pre>
<h2 id="install-python-js8py-module"><a class="header" href="#install-python-js8py-module">Install Python js8py Module</a></h2>
<pre><code class="language-sh">git clone -b master https://github.com/jketterl/js8py.git
cd js8py
sudo python3 setup.py install
cd ..
</code></pre>
<h2 id="install-rsp1-device"><a class="header" href="#install-rsp1-device">Install Rsp1 Device</a></h2>
<p>安装 rsp1 的 linux API 驱动,使用 API 3.07.</p>
<p><a href="https://www.sdrplay.com/software">Sdrplay 官网网站</a></p>
<pre><code class="language-sh">wget https://www.sdrplay.com/software/SDRplay_RSP_API-Linux-3.07.1.run
chmod 777 SDRplay_RSP_API-Linux-3.07.1.run
sudo ./SDRplay_RSP_API-Linux-3.07.1.run
</code></pre>
<h2 id="install-soapysdr-驱动"><a class="header" href="#install-soapysdr-驱动">Install Soapysdr 驱动</a></h2>
<p><a href="https://github.com/pothosware/SoapySDR">SoapySDR</a></p>
<p>通过编译安装 SoapySdr 驱动, <del>或者通过 ​~~​</del><code>apt-get</code><del>​~~​ 软件包管理安装</del></p>
<pre><code class="language-sh">git clone https://github.com/pothosware/SoapySDR
cd SoapySDR
mkdir build
cd build
cmake ..
make 
sudo make install
sudo ldconfig
cd ..
</code></pre>
<h2 id="install-soapysdrplay-驱动"><a class="header" href="#install-soapysdrplay-驱动">Install Soapysdrplay 驱动</a></h2>
<p>用于使得 Soapysdr 使得支持 sdrplay 设备.</p>
<pre><code class="language-sh">git clone https://github.com/pothosware/SoapySDRPlay.git
cd SoapySDRPlay
mkdir build
cd build
cmake ..
make
sudo make install
</code></pre>
<h2 id="install-rx_tools"><a class="header" href="#install-rx_tools">Install rx_tools</a></h2>
<pre><code class="language-sh">git clone https://github.com/rxseger/rx_tools
cd rx_tools
mkdir build
cd build
cmake ..
make 
sudo make install
sudo ldconfig
cd ..
</code></pre>
<h2 id="加入内核-blacklist"><a class="header" href="#加入内核-blacklist">加入内核 Blacklist</a></h2>
<p>rtl_sdr 设备</p>
<pre><code class="language-sh">nano /etc/modprobe.d/blacklist-rtlsdr.conf
blacklist dvb_usb_rtl28xxu
</code></pre>
<p>sdrplay 设备</p>
<pre><code class="language-sh">nano /etc/modprobe.d/blacklist-sdrplay.conf
blacklist sdr_msi3101
blacklist msi001
blacklist msi2500
</code></pre>
<h2 id="重启后测试是否可以识别-sdr-设备"><a class="header" href="#重启后测试是否可以识别-sdr-设备">重启后测试是否可以识别 SDR 设备</a></h2>
<pre><code class="language-sh">SoapySDRUtil --find
</code></pre>
<h2 id="安装-openwebrx-主程序"><a class="header" href="#安装-openwebrx-主程序">安装 Openwebrx 主程序</a></h2>
<pre><code class="language-sh"># 新建数据文件
mkdir /var/lib/openwebrx
sudo sh -c &quot;echo [] &gt; /var/lib/openwebrx/users.json&quot;

# download
git clone -b master https://github.com/jketterl/openwebrx.git
cd openwebrx
./openwebrx.py

# add admin user
./openwebrx.py admin adduser admin
</code></pre>
<h2 id="install-owrx_connector-链接组件"><a class="header" href="#install-owrx_connector-链接组件">Install owrx_connector 链接组件</a></h2>
<pre><code class="language-sh">git clone -b master https://github.com/jketterl/owrx_connector.git
cd owrx_connector
mkdir build
cd build
cmake ..
make
sudo make install
cd ../..
sudo ldconfig
</code></pre>
<h2 id="运行-openwebrx"><a class="header" href="#运行-openwebrx">运行 Openwebrx</a></h2>
<pre><code class="language-sh">./openwebrx.py
</code></pre>
<p>访问 IP:8073 打开页面进行 setting.</p>
<h2 id="openwebrx-自动控制瀑布增益"><a class="header" href="#openwebrx-自动控制瀑布增益">Openwebrx 自动控制瀑布增益</a></h2>
<p>在 <code>openwebrx/htdocs/index.html</code> 末尾加入以下 JS 代码即可实现.</p>
<pre><code class="language-html">&lt;script type=&quot;text/javascript&quot;&gt;
$(document).ready(function() {
$('#openwebrx-waterfall-colors-auto').contextmenu();
  setTimeout(function() { 
    $('#openwebrx-waterfall-colors-auto').contextmenu();
		$('#openwebrx-waterfall-colors-auto').click(); 
		}, 2000);
  $('#openwebrx-sdr-profiles-listbox').change(function() {
		console.log(&quot;change profiles!&quot;);
    $('#openwebrx-waterfall-colors-auto').contextmenu();
		setTimeout(function() { 
    $('#openwebrx-waterfall-colors-auto').contextmenu();
		$('#openwebrx-waterfall-colors-auto').click(); 
		}, 2000);
  });
});
&lt;/script&gt;
</code></pre>
<h2 id="参考引用-reference"><a class="header" href="#参考引用-reference">参考引用 Reference</a></h2>
<p>HamCQ.cn</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: 自由上网指北——21世纪网民天赋的权力
date: 2022-08-11 15:51:48
updated: 2022-08-11 15:59:48
categories: GFW
tags: [GFW, Freedom]
description:
thumbnail: http://oss.whaleluo.top/blog/img/Freedom-network-banner.png-picsmall
banner_img: http://oss.whaleluo.top/blog/img/Freedom-network-banner.png-picsmall</p>
<hr />
<h1 id="自由上网指北21-世纪网民天赋的权力"><a class="header" href="#自由上网指北21-世纪网民天赋的权力">自由上网指北——21 世纪网民天赋的权力</a></h1>
<p>​<img src="http://oss.whaleluo.top/blog/img/Freedom-network-banner.png-picsmall" alt="Banner" />​</p>
<p>{% note warning WARNING %}<br />
WARNING：本文可能随时遭到来自 <strong>中国当局</strong> 方面的审查，对此，您需要清楚知悉文章内部分敏感词的代替表达方式。<br />
{% endnote %}</p>
<p><img src="http://oss.whaleluo.top/blog/img/Freedom-Network-1.png-picsmall" alt="KeyWord" /></p>
<p>法律依据：<a href="http://www.scio.gov.cn/ztk/dtzt/28/6/Document/661401/661401.htm">中华人民共和国宪法——保障公民互联网言论自由</a></p>
<p><img src="http://oss.whaleluo.top/blog/img/Freedom-network-2.jpeg-picsmall" alt="你法我笑" /></p>
<h2 id="前言"><a class="header" href="#前言">前言</a></h2>
<p>自由上网，在种花家指得是 FQ ，等突破网络审查或突破网络封锁的手段。由于少数国家实行了高强度的网络审查，使得一些国际网站及软件遭到政府或组织的<strong>结构性屏蔽</strong>。比如 in China 你可能会发现 Stream 上的游戏怎么下载不动呢？GitHub 怎么打不开呢？YouTube 怎么上不了呢？这都是 ZF 对网络进行屏蔽的结果。</p>
<p><img src="http://oss.whaleluo.top/blog/img/Freedom-network-4.png-picsmall" alt="GFW" /></p>
<p>但互联网的 <strong>分布式设计</strong> 从体系上使得任何一个政府或组织完全控制互联网极其困难。俗话说：“ <strong>你有张良计，我有过墙梯！</strong> ”各种 FQ 软件被热爱自由的工程师设计了出来。</p>
<p>FQ 软件的原理通常是连接一个没有被 GFW 阻断的境外服务器，通过该服务器进行流量转发。本文主要面向一些 FQ 的小白，方便其 <strong>快速、安全、便捷</strong> 的建立安全的自由互联网连接。所以主要涉及软件的使用，没有涉及具体的实现原理。</p>
<h2 id="态度"><a class="header" href="#态度">态度</a></h2>
<p>FQ 对于个人而言是十分重要的，您可以第一时间知道世界上发生了什么大事，可以辩证的看待各种信息源，避免 ZF 给民众设置的 <strong>信息茧房</strong>。辩证地看待国内严重的民粹主义、极端的民族主义情绪。多信息源可以避免信息差。</p>
<p>同时，FQ 也是对个人媒介素养的考验，墙外的信息虽然没有审查、信息源也参差不齐，要有选择的吸取信息。总之，要坚持 <strong>良知、理性、平等和爱</strong> 的普世价值。这些价值观基本都超越了宗教、国家和民族，在地球的每个地区都被推崇，也是大多数人类都能共同认可的价值观。</p>
<h2 id="安全性"><a class="header" href="#安全性">安全性</a></h2>
<p>为了确保您上网的安全性，请勿使用那种傻瓜的一键 vpen，比如说 <strong>佛跳墙、快连、老王</strong>，这种 vpen 因为使用便捷，深受小白喜爱。殊不知这些傻瓜一键 vpen 大多数都是有中资背景的，您上网的一举一动王晶都看在眼里，记在小本本上，头上三尺有神明，您是躲不过的迟早会请去喝茶。</p>
<p>所以，为了您的安全请使用开源的 vpen 软件，但可能需要投入一点点的时间成本，但你会收获一个免费、快捷、安全的自由上网方法。</p>
<p>另外，请不要在 FQ 手机上安装 国家防诈 <del>监控</del> APP，懂得都懂！</p>
<p>最后，在访问境外网站时请不要使用手机厂商自带的浏览器和爱国浏览器，推荐使用 via 浏览器和 chrome google 浏览器，这两个浏览器百度都可以搜得到。</p>
<h2 id="v2y-使用"><a class="header" href="#v2y-使用">V2**y 使用</a></h2>
<h3 id="安卓端"><a class="header" href="#安卓端">安卓端</a></h3>
<p>下面简单介绍安卓端 v2**y 的使用。</p>
<h4 id="下载"><a class="header" href="#下载">下载</a></h4>
<p><a href="https://github.com/2dust/v2rayNG/releases/tag/1.7.23">GitHub releases 页</a></p>
<p>因为上面的链接需要 FQ 后才能使用，请用下面的链接下载：</p>
<blockquote>
<p>蓝奏云 <a href="https://wwaz.lanzoum.com/iXHYX0jn0q5e">https://wwaz.lanzoum.com/iXHYX0jn0q5e</a> 密码:7xzj</p>
</blockquote>
<h4 id="使用"><a class="header" href="#使用">使用</a></h4>
<p>安装上面下载的 apk 文件，打开后点击左上角进行设置</p>
<p><img src="http://oss.whaleluo.top/blog/img/Freedom-network-5.png-picsmall" alt="点击左上角进行设置" /></p>
<p>VPN 设置 -&gt; 启动本地 DNS</p>
<p>路由设置 -&gt; 域名策略（IPIfNonMatch）</p>
<p>预定义规则 -&gt; 绕过局域网及大陆地址而后代理</p>
<p><img src="http://oss.whaleluo.top/blog/img/Freedom-network-6.jpg-picsmall" alt="如上图进行设置" /></p>
<p>设置好后回到首页选择订阅分组设置</p>
<p><img src="http://oss.whaleluo.top/blog/img/Freedom-network-7.png-picsmall" alt="选择订阅分组设置" /></p>
<p>点击加号添加订阅然后保存，如果你是我的朋友或者同学，可以问我白嫖订阅地址。</p>
<p>回到首页点击右上角，再选择更新订阅，不出意外的话就会出现各节点。</p>
<p>然后再选择测试 <strong>全部配置真链接</strong>，选择延迟较低的节点，然后点击右下角的 V 图标就会建立 VPN 连接。</p>
<p><img src="http://oss.whaleluo.top/blog/img/Freedom-network-7.jpg-picsmall" alt="选择订阅分组设置" /></p>
<h4 id="测试"><a class="header" href="#测试">测试</a></h4>
<p>连接上 VPN 后，可以使用 via 浏览器打开谷歌网站（<a href="https://google.com">https://google.com</a>）来检验节点是否有效。</p>
<p>打开 <a href="https://whoer.net">https://whoer.net</a> 查看节点的落地 IP 地址。</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Samba4 服务器配置最佳实践
date: 2022-12-25 19:37:48
updated: 2022-12-25 19:37:48
categories: Server
tags: [Server, Linux]
thumbnail: http://oss.whaleluo.top/blog/img/Smb-banner.png-picsmall
banner_img: http://oss.whaleluo.top/blog/img/Smb-banner.png-picsmall</p>
<hr />
<h1 id="samba4-服务器配置最佳实践"><a class="header" href="#samba4-服务器配置最佳实践">Samba4 服务器配置最佳实践</a></h1>
<p><img src="http://oss.whaleluo.top/blog/img/Smb-banner.png-picsmall" alt="banner" /></p>
<h2 id="具体配置文件"><a class="header" href="#具体配置文件">具体配置文件</a></h2>
<p><strong>请按照实际情况进行修改!</strong></p>
<p>smb.conf.ini</p>
<pre><code class="language-ini">[global]
   netbios name = CYX HOME
   #interfaces = |INTERFACES|
   server string = cyx
   #unix charset = |CHARSET|
   workgroup = WORKGROUP

   bind interfaces only = no

   max connections = 0

   deadtime = 15

   ## disable core dumps
   enable core files = no

   security = user

   
   #smb encrypt = default

   ## set invalid users
   ## 设置无效用户
   #invalid users = root

   ## map unknow users to guest
   ## 将未知用户映射为访客
   map to guest = Bad User
   #

   ## 允许客户端访问具有空密码的帐户。
   null passwords = yes

   passdb backend = smbpasswd

   ## Set location of smbpasswd ('smbd -b' will show default compiled location)
   ## 设置smbpasswd的位置（'smbd-b'将显示默认的编译位置）
   #smb passwd file = /etc/samba/smbpasswd 

   ## LAN (IPTOS_LOWDELAY TCP_NODELAY) WAN (IPTOS_THROUGHPUT) WiFi (SO_KEEPALIVE) try&amp;error for buffer sizes (SO_RCVBUF=65536 SO_SNDBUF=65536)
   ## 用来设置服务器和客户端之间会话的Socket选项，可以优化传输速度
   #socket options = TCP_NODELAY SO_RCVBUF=8192 SO_SNDBUF=8192
   socket options = TCP_NODELAY IPTOS_LOWDELAY SO_RCVBUF=131072 SO_SNDBUF=131072
   #socket options = IPTOS_LOWDELAY TCP_NODELAY
   
   
   aio read size = 0
   #aio write size = 0

   ## 这可能会在没有 aio 支持的情况下加速客户端，但确实很危险，因为数据可能会丢失，文件可能会损坏。
   #aio write behind = /*.tmp/

   use sendfile = yes

   ## samba will behave as previous versions of Samba would and will fail the lock request immediately if the lock range cannot be obtained.
   ## samba 将像以前版本的 Samba 一样运行，如果无法获得锁定范围，它将立即使锁定请求失败。
   #blocking locks = No

   ## disable loading of all printcap printers by default (iprint, cups, lpstat)
   ## 默认禁用所有 printcap 打印机的加载（iprint、cups、lpstat）
   load printers = No
   printcap name = /dev/null

   ## Enabling this parameter will disable Samba's support for the SPOOLSS set of MS-RPC's.
   ## 启用此参数将禁用 Samba 对 MS-RPC 的 SPOOLSS 集的支持。
   disable spoolss = yes

   ## This parameters controls how printer status information is interpreted on your system.
   ## 此参数控制打印机状态信息在系统上的解释方式。
   ## (BSD, AIX, LPRNG, PLP, SYSV, HPUX, QNX, SOFTQ)
   printing = bsd

   ## Disable that nmbd is acting as a WINS server for unknow netbios names
   ## 禁用 nmbd 作为未知 netbios 名称的 WINS 服务器
   #dns proxy = No

   ## win/unix user mapping backend
   ## win/unix 用户映射后端
   #idmap config * : backend = tdb

   ## Allows the server name that is advertised through MDNS to be set to the hostname rather than the Samba NETBIOS name.
   ## 允许将通过 MDNS 通告的服务器名称设置为主机名，而不是 Samba NETBIOS 名称。
   ## This allows an administrator to make Samba registered MDNS records match the case of the hostname rather than being in all capitals.
   ## 这允许管理员使 Samba 注册的 MDNS 记录与主机名的大小写匹配，而不是全部大写。
   ## (netbios, mdns)
   #mdns name = mdns

   ## Clients that only support netbios won't be able to see your samba server when netbios support is disabled.
   ## 仅支持 netbios 的客户端在禁用 netbios 支持时将无法看到您的 samba 服务器。
   #disable netbios = Yes

   ## Setting this value to no will cause nmbd never to become a local master browser.
   ## 将此值设置为 no 将导致 nmbd 永远不会成为本地主浏览器。
   #local master = no

   ## (auto, yes) If this is set to yes, on startup, nmbd will force an election, and it will have a slight advantage in winning the election. It is recommended that this parameter is used in conjunction with domain master = yes, so that nmbd can guarantee becoming a domain master. 
   ##（自动，是）如果设置为是，在启动时，nmbd将强制进行选举，并且在赢得选举时会有一点优势。建议将此参数与domain master=yes结合使用，这样nmbd就可以保证成为域主机。
   #preferred master = yes

   ## (445 139) Specifies which ports the server should listen on for SMB traffic.
   ## (445 139) 指定服务器应在哪些端口上侦听 SMB 流量。
   ## 139 is netbios/nmbd
   smb ports = 445 139 4455 44555

   ## This is a list of files and directories that are neither visible nor accessible.
   ## 这是既不可见也不可访问的文件和目录的列表。
   ## Each entry in the list must be separated by a '/', which allows spaces to be included in the entry. '*' and '?' can be used to specify multiple files or directories as in DOS wildcards.
   ## 列表中的每个条目必须用“/”分隔，这允许在条目中包含空格。“*”和“？”可用于指定多个文件或目录，如在 DOS 通配符中一样。
   veto files = /Thumbs.db/.DS_Store/._.DS_Store/.apdisk/

   ## If a directory that is to be deleted contains nothing but veto files this deletion will fail unless you also set the delete veto files parameter to yes.
   ## 如果要删除的目录只包含否决文件，则此删除将失败，除非您还将删除否决文件参数设置为 yes。
   delete veto files = yes

################ Filesystem and creation rules ################
   ## reported filesystem type (NTFS,Samba,FAT)
   ## 报告的文件系统类型(NTFS、Samba、FAT)
   #fstype = FAT

   ## Allows a user who has write access to the file (by whatever means, including an ACL permission) to modify the permissions (including ACL) on it.
   ## 允许对文件具有写入访问权限(以任何方式，包括ACL权限)的用户修改其权限(包括ACL)。
   #dos filemode = Yes

   ## file/dir creating rules
   ## 文件/目录创建规则
   #create mask = 0666
   #directory mask = 0777
   #force group = root
   #force user = root
   #inherit owner = windows and unix
######### Dynamic written config options #########
   ## windows 7 能正常访问，而部分windows 10 不能访问，老是弹出“拒绝访问”，按网上方法设置了、系统重装了n遍还是一样，就用以下两行代码，能解决。
   lanman auth = yes
   ntlm auth = ntlmv1-permitted


#[sda1]
#   path = /mnt/sda1
#   #共享路径
#   force user = root
#   #强制用户
#   force group = root
#   #强制组
#   create mask = 0666
#   #创建文件自身权限
#   directory mask = 0777
#   #创建文件夹自身权限
#   read only = yes
#   write list = root
#   #对于其他用户只读(yes/no)
#   guest ok = no
#   #对于windows 以游客身份是否访问（yes/no），
#   inherit owner = yes
#   #目录继承
#   valid users = root you
#   #有效用户
#   invalid users = you
#   #无效用户


[mnt]
   path = /mnt/
   force user = root
   force group = root
   create mask = 0666
   directory mask = 0777
   read only = no
   guest ok = no
   inherit owner = yes
   valid users = root

[临时目录]
   path = /tmp
   force user = root
   force group = root
   create mask = 0777
   directory mask = 0777
   read only = no
   guest ok = no
   inherit owner = yes
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: 😏 树莓派折腾手册（三）——搭建离线下载器 👀
date: 2021-06-18 19:37:48
updated: 2021-06-18 19:37:48
categories: Linux
tags: [Respi, Linux]
description:
thumbnail: http://oss.whaleluo.top/blog/old/20210619154345.jpg
banner_img: http://oss.whaleluo.top/blog/old/20210619154345.jpg</p>
<hr />
<h1 id="-树莓派折腾手册三搭建离线下载器-"><a class="header" href="#-树莓派折腾手册三搭建离线下载器-">😏 树莓派折腾手册（三）——搭建离线下载器 👀</a></h1>
<h2 id="1挂载硬盘u-盘"><a class="header" href="#1挂载硬盘u-盘">1.挂载硬盘/U 盘</a></h2>
<blockquote>
<p><strong>注意：开始之前先把存储设备格式化成</strong> <strong>fat32 文件系统</strong></p>
</blockquote>
<ul>
<li>
<p>树莓派 4B Debian10 系统插上储存设备后默认自动挂载到 <code>/media</code> 目录我们先卸载 U 盘：</p>
<p>查询硬盘状态: <code>sudo fdisk -l</code></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210619153119.png-picsmall" alt="9XBTemAzD6R8yot" /></p>
</li>
</ul>
<pre><code class="language-shell">sudo umount /media/pi/PI   #这里不能照抄命令，要根据实际情况更改 

#如果出现 target is busy 的情况，我们要强行结束U盘目录下的进程 
sudo fuser -mv -k /media/U盘 名字    # 然后再执行umount卸载命令 
</code></pre>
<ul>
<li>编辑 <code>/etc/fstab</code> 中添加像下面这样的挂载配置：</li>
</ul>
<pre><code>sudo nano /etc/fstab

/dev/sda1 /home/pi/disk vfat utf8,uid=1000,gid=1000,umask=000 0 0 #挂载点需要自行更改 sda1要加数字

sudo reboot

mount /dev/sda1 /home/pi/disk -o utf8,uid=1000,gid=1000,umask=000 -t vfat
</code></pre>
<ul>
<li>
<p>重启 ，不出意外的话开机 应该 会自动挂载，且有写权限，用户是 pi：如图挂载至 <code>/home/pi/disk</code> 目录，有<strong>777 权限</strong></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210619153142.png-picsmall" alt="3ilg9S1UJ2EcHPV" /></p>
</li>
</ul>
<h2 id="2部署-aria2-离线下载器"><a class="header" href="#2部署-aria2-离线下载器">2.部署 Aria2 离线下载器</a></h2>
<ul>
<li>下载安装 <code>Aria2</code>:</li>
</ul>
<pre><code>sudo apt-get update
sudo apt-get install aria2
</code></pre>
<ul>
<li>
<p>安装 nginx：</p>
<blockquote>
<p>上面已经安装过的<strong>小可爱</strong>可以<strong>跳过</strong></p>
</blockquote>
</li>
</ul>
<pre><code>sudo apt-get install nginx
</code></pre>
<ul>
<li>
<p>配置 Aria2， 创建配置文件：</p>
<pre><code>#创建目录 
sudo mkdir /etc/aria2/ 
#创建配置文件 
sudo touch /etc/aria2/aria2.conf 
#创建aria2用户 
sudo useradd -M -s /usr/sbin/nologin aria2 
#创建session文件，用于保存进度: 
sudo touch /etc/aria2/aria2.session 
#修改文件拥有者为aria2： 
sudo chown aria2 /etc/aria2 /etc/aria2/aria2.session
</code></pre>
</li>
<li>
<p>编辑 <code>Aria2配置</code> 文件:</p>
<pre><code>#根据需要编辑文件: 
sudo nano /etc/aria2/aria2.conf 
#配置实例

#默认下载位置，需要改这里！！ 
dir=/home/pi/disk 
#断点续传 
continue=true 
min-split-size=10M 
input-file=/etc/aria2/aria2.session 
save-session=/etc/aria2/aria2.session 
enable-rpc=true 
rpc-allow-origin-all=true 
#只让本机访问6800端口，因为下面让nginx代理 
rpc-listen-all=false 
#rpc秘钥，需要改这里 
rpc-secret=123456 
rpc默认端口为6800
#rpc-listen-port=6800 
listen-port=51413  
enable-dht=false 
enable-peer-exchange=false 
peer-id-prefix=-TR2770- 
user-agent=Transmission/2.77 
seed-ratio=0 
bt-seed-unverified=true 
bt-save-metadata=true
</code></pre>
</li>
<li>
<p>创建<strong>systemd</strong>文件在 <code>/lib/systemd/system/aria2.service</code> 为如下:</p>
<pre><code>sudo nano /lib/systemd/system/aria2.service

#配置实例 
[Unit] 
Description=Aria2c download manager 
After=network.target  
[Service] 
Type=simple 
User=aria2 
ExecStart=/usr/bin/aria2c  --conf-path=/etc/aria2/aria2.conf  [Install] 
WantedBy=multi-user.target 
</code></pre>
</li>
<li>
<p>启动<strong>Aria2</strong>:</p>
<pre><code>#启动Aria2 
sudo systemctl start aria2.service 
#可以设置开机启动 
sudo systemctl enable aria2.service 
#如果要关闭开机启动 
sudo systemctl disable aria2.service
</code></pre>
</li>
<li>
<p>配置<strong>nginx+ariaNg</strong>可视化管理页面：</p>
<blockquote>
<p>到 <a href="https://github.com/mayswind/AriaNg/releases"><strong>AriaNG</strong></a>​<a href="https://github.com/mayswind/AriaNg/releases">开源项目页面</a> 获取最新版版本</p>
</blockquote>
<p><img src="http://oss.whaleluo.top/blog/old/20210619153158.png-picsmall" alt="UO7c5EItjBHRsgN" /></p>
<p><strong>把源码克隆到</strong> <code>/website/AriaNg/</code>：</p>
<pre><code class="language-shell">sudo mkdir /website
sudo chmod 777 -R /website
cd /website
mkdir AriaNg
cd AriaNg

# 自己复制最新版链接
wget https://github.com/mayswind/AriaNg/releases/download/1.1.6/AriaNg-1.1.6.zip
# 祖国加速通道
wget https://gproxy.cn/https://github.com/mayswind/AriaNg/releases/download/1.1.6/AriaNg-1.1.6.zip
# 解压
unzip AriaNg-1.1.6.zip
rm AriaNg-1.1.6.zip
# 授权
sudo chmod 777 -R /website
</code></pre>
</li>
</ul>
<blockquote>
<p>为了方便使用，我把<strong>AriaNg</strong>和<strong>jsonrpc</strong>都配置在了 <strong>80 端口</strong>，利用 nginx 的<strong>代理功能</strong>，把本机 6800 端口隐藏,对外<strong>只暴露 80 端口.</strong></p>
</blockquote>
<pre><code class="language-shell">#修改nginx配置文件 
sudo nano /etc/nginx/sites-enabled/default

#添加配置aria2Ng 
location /aria2 { 
            alias /website/AriaNg/; 
            index index.html; 
    } 
#代理jsonrpc 
location /jsonrpc { 
       proxy_pass http://localhost:6800/jsonrpc; 
            proxy_redirect off; 
            proxy_set_header        X-Real-IP       $remote_addr; 
            proxy_set_header        X-Forwarded-For     $proxy_add_x_forwarded_for; 
            proxy_set_header Host $host; 
            #以下代码使支持WebSocket 
            proxy_http_version 1.1; 
            proxy_set_header Upgrade $http_upgrade; 
            proxy_set_header Connection &quot;upgrade&quot;; 
} 

#最后别忘记重启nginx 
sudo systemctl restart nginx 
</code></pre>
<ul>
<li>尝试访问 <a href="http://%E6%A0%91%E8%8E%93%E6%B4%BEip/aria2">http://树莓派ip/aria2</a> ，<strong>设置参数</strong></li>
<li><img src="http://oss.whaleluo.top/blog/old/20210619153219.png-picsmall" alt="wNbqhBl7KWL6Jcx" /></li>
</ul>
<p><img src="http://oss.whaleluo.top/blog/old/20210619153228.png-picsmall" alt="2o7a8c3qpFODP4Y" /></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Onedrive 完全使用指南
date: 2023-06-03 11:05:50
updated: 2023-06-03 11:05:50
categories: onedrive
tags: [onedrive, 云盘, Rclone]
description:
thumbnail:
banner_img:</p>
<hr />
<h1 id="onedrive-完全使用指南"><a class="header" href="#onedrive-完全使用指南">Onedrive 完全使用指南</a></h1>
<h2 id="前言-1"><a class="header" href="#前言-1">前言</a></h2>
<p>最近一直在寻找一个国内使用的高可用不限速的在线云盘存储，试过了很多国内的云盘存储，不是有内容审查就是网盘限速。这些网盘都拘泥于一个固定的客户端，不能做到 <strong>多端可用、随地随用、增量同步。</strong></p>
<p>就选择了 Onedrive 这个云盘，在小咸鱼买了一年 39 CNY 的 office365 家庭版拼车。Onedirve 家庭版可以支持 6 个用户，每个用户有 1T 的 onedrive 空间和 5 台设备的 office365 授权。</p>
<p>Onedrive 支持将云空间挂载到各种软件上，例如：Rclone、Alist、oneindex。可以支持直链共享，目测在中国大陆的网速也不错。<br />
​<img src="http://oss.whaleluo.top/blog/img/202307191615973.png-picsmall" alt="office-365-family" /></p>
<h2 id="创建-onedrive-api"><a class="header" href="#创建-onedrive-api">创建 OneDrive API</a></h2>
<h3 id="获取-client_id"><a class="header" href="#获取-client_id">获取 client_id</a></h3>
<pre><code class="language-text">5c160d06-e2cf-4dbf-a987-5b672cd6bb5ehyy
</code></pre>
<p>首先访问 <a href="https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/RegisteredApps">Microsoft Azure 应用注册</a>，登录账号后点击 <strong>应用注册</strong></p>
<p>填写以下信息：</p>
<p>​<img src="http://oss.whaleluo.top/blog/img/202307191615975.png-picsmall" alt="image" />点击注册后可以看到你的应用的相关信息，复制好 应用程序 (客户端) ID ==，这个就是== client_id。</p>
<p>​<img src="http://oss.whaleluo.top/blog/img/202307191615976.png-picsmall" alt="image" />​</p>
<h3 id="获取-client_secret"><a class="header" href="#获取-client_secret">获取 client_secret</a></h3>
<pre><code class="language-text">dHd8Q~Nu8~IRN25ihNt3x-sIGrkE9n1tpFYGYbEohxy
</code></pre>
<p>依次点击 <strong>证书和密码</strong>，<strong>新客户端密码</strong>，在截止期限中将时间选择为最长（即两年）</p>
<p>​<img src="http://oss.whaleluo.top/blog/img/202307191615977.png-picsmall" alt="image" />​</p>
<p>然后就可以看见值和机密 ID，我们只需要记录下 <strong>值</strong> 就可以，这个就是 client_secret。</p>
<p>​<img src="http://oss.whaleluo.top//blog/img/202307191615978.png-picsmall" alt="image" />​</p>
<h3 id="添加-api-权限"><a class="header" href="#添加-api-权限">添加 API 权限</a></h3>
<p>依次点击 <strong>API 权限</strong>，<strong>添加权限</strong>，<strong>Microsoft Graph</strong>，在右边栏搜索并添加权限。</p>
<p>需要 <strong>Files.Read, Files.ReadWrite,Files.Read.All, Files.ReadWrite.All, offline_access, User.Read</strong> 。</p>
<p>​​<img src="http://oss.whaleluo.top/blog/img/202307191615979.png-picsmall" alt="image" />​</p>
<p>添加以下权限：</p>
<p>​<img src="http://oss.whaleluo.top/blog/img/202307191615980.png-picsmall" alt="image" />​</p>
<h3 id="添加身份验证"><a class="header" href="#添加身份验证">添加身份验证</a></h3>
<p>依次点击 <strong>身份验证</strong>，<strong>添加平台</strong>，<strong>Web</strong></p>
<p>​<img src="http://oss.whaleluo.top/blog/img/202307191615981.png-picsmall" alt="image" />​在重定向 URI 中输入 ==http://localhost==</p>
<p>​<img src="http://oss.whaleluo.top/blog/img/202307191615982.png-picsmall" alt="image" />​至此，OneDrive API 创建完成</p>
<h2 id="使用-rclone"><a class="header" href="#使用-rclone">使用 Rclone</a></h2>
<p>Rclone 是一个用于多个云平台之间同步文件和目录的命令行工具，其支持多种运营商网盘。使用 Golang 编写，<strong>所以跨平台兼容性良好</strong>。</p>
<p>支持 RC 接口可以通过 API 或 Web UI 操作。</p>
<ul>
<li>官网网址：<a href="https://www.moewah.com/go/aHR0cHM6Ly9yY2xvbmUub3Jn">https://rclone.org</a></li>
<li>开源地址：<a href="https://github.com/ncw/rclone">https://github.com/ncw/rclone</a></li>
<li>中文文档部分翻译： <a href="https://ld246.com/article/1600853705300">https://ld246.com/article/1600853705300</a></li>
<li>rclone 中文站点： <a href="https://rclone.cn/">https://rclone.cn/</a></li>
</ul>
<h3 id="docker"><a class="header" href="#docker">Docker</a></h3>
<p>Rclone can serve a web based GUI. ​<code>rclone rcd --rc-web-gui</code>​​</p>
<p>53682 为 微软令牌验证端口</p>
<p><a href="https://rclone.org/onedrive/">https://rclone.org/onedrive/</a></p>
<pre><code class="language-shell">docker pull rclone/rclone:latest
</code></pre>
<pre><code class="language-shell">docker run -d \
    -v /root/rclone:/config/rclone \
    -v /mnt/:/data \
    -p 5573:5572 \
    -p 53682:53682 \
    --name=rclone \
    --user $(id -u):$(id -g) \
    rclone/rclone \
    rcd --rc-web-gui \
    --rc-web-gui-force-update \
    --rc-web-gui-no-open-browser \
    --rc-addr 0.0.0.0:5572 \
    --rc-user admin \
    --rc-pass lovehyy9420
</code></pre>
<p>打开 http://IP:5573 并登录显示以下页面：</p>
<p>​<img src="http://oss.whaleluo.top/blog/img/202307191615983.png-picsmall" alt="image" />​</p>
<p>进入 docker bash：<code>docker exec -it rclone sh</code>​, 输入 rclone config ，按照提示进行 onedrive 设置。</p>
<p>远程 OA 验证：<a href="https://rclone.org/remote_setup/">https://rclone.org/remote_setup/</a></p>
<p>验证完毕后可以在 Explorer 查看文件：</p>
<p>​<img src="http://oss.whaleluo.top/blog/img/202307191615985.png-picsmall" alt="image" />### Rclone 常用命令</p>
<p>语法：</p>
<pre><code class="language-shell"># 本地到网盘
rclone [功能选项] &lt;本地路径&gt; &lt;网盘名称:路径&gt; [参数] [参数] ...
# 网盘到本地
rclone [功能选项] &lt;网盘名称:路径&gt; &lt;本地路径&gt; [参数] [参数] ...
# 网盘到网盘
rclone [功能选项] &lt;网盘名称:路径&gt; &lt;网盘名称:路径&gt; [参数] [参数] ...
</code></pre>
<p>常用功能选项：</p>
<pre><code class="language-text">rclone copy - 复制
rclone move - 移动，如果要在移动后删除空源目录，请加上 --delete-empty-src-dirs 参数
rclone sync - 同步：将源目录同步到目标目录，只更改目标目录。
rclone delete - 删除路径下的文件内容。
rclone purge - 删除路径及其所有文件内容。
rclone mkdir - 创建目录。
rclone rmdir - 删除目录。
rclone rmdirs - 删除指定灵境下的空目录。如果加上 --leave-root 参数，则不会删除根目录。
rclone check - 检查源和目的地址数据是否匹配。
rclone ls - 列出指定路径下的所有的文件以及文件大小和路径。
rclone lsl - 比上面多一个显示上传时间。
rclone lsd 列出指定路径下的目录
rclone lsf - 列出指定路径下的目录和文件
</code></pre>
<p>常用参数：</p>
<pre><code class="language-text">-n = --dry-run - 测试运行，用来查看 rclone 在实际运行中会进行哪些操作。
-P = --progress - 显示实时传输进度。
--cache-chunk-size SizeSuffi - 块的大小，默认 5M，理论上是越大上传速度越快，同时占用内存也越多。如果设置得太大，可能会导致进程中断。
--cache-chunk-total-size SizeSuffix - 块可以在本地磁盘上占用的总大小，默认 10G。
--transfers=N - 并行文件数，默认为 4。在比较小的内存的 VPS 上建议调小这个参数，比如 128M 的小鸡上使用建议设置为 1。
--config string - 指定配置文件路径，string 为配置文件路径。比如在使用宝塔面板输入命令操作时可能会遇到找不到配置文件的问题，这时就需要指定配置文件路径。
</code></pre>
<h3 id="授权保活"><a class="header" href="#授权保活">授权保活</a></h3>
<p>If you don't use rclone for 90 days the refresh token will expire. This will result in authorization problems. This is easy to fix by running the <code>rclone config reconnect remote:</code>​ command to get a new token and refresh token.</p>
<p>如果在 90 天内不使用 rclone，刷新令牌将过期。这将导致授权问题。通过运行 rclone config reconnect remote: 命令获取新令牌并刷新令牌，可以轻松解决此问题。</p>
<p>重新运行授权：</p>
<pre><code class="language-shell">docker run --rm -it -v /root/rclone:/config/rclone -v /mnt/:/data --user $(id -u):$(id -g) rclone/rclone config reconnect onedrive:
</code></pre>
<h3 id="命令示例"><a class="header" href="#命令示例">命令示例</a></h3>
<p>将 onedrive 上的全部内容下载到本地：</p>
<pre><code class="language-shell">rclone copy source:sourcepath dest:destpsth

rclone copy onedrive:/ /data/sdb1/onedrive_old --transfers=8 -P
</code></pre>
<p>​<img src="http://oss.whaleluo.top/blog/img/202307191615986.png-picsmall" alt="image" />​​</p>
<p>速度还行，将旧的 onedrive 文件一同迁移到本地硬盘。</p>
<h3 id="双向同步"><a class="header" href="#双向同步">双向同步</a></h3>
<pre><code class="language-shell">rclone bisync remote1:path1 remote2:path2 [flags]


--check-access            确保在Path1和Path2文件系统上找到了预期的RCLONE_TEST文件，否则中止操作。
--check-filename string   用于--check-access的文件名（默认值：RCLONE_TEST）
--check-sync string       控制最终列表的比较：true|false|only（默认值：true）（默认值 &quot;true&quot;）
--filters-file string     从文件中读取过滤模式
--force                   跳过--max-delete安全检查并运行同步。考虑与--verbose一起使用
-h, --help                    bisync的帮助信息
--localtime               在列表中使用本地时间（默认值：UTC）
--no-cleanup              保留工作文件（用于故障排除和测试）。
--remove-empty-dirs       在最终清理步骤中删除空目录。
-1, --resync                  执行重新同步操作。Path1文件可能会覆盖Path2版本。首先考虑使用--verbose或--dry-run。
--workdir string          使用自定义的工作目录 - 用于测试。（默认值：$HOME/.cache/rclone/bisync）
</code></pre>
<pre><code class="language-shell">rclone bisync /data/sdb1/Yellow/ onedrive:/Yellow/ --check-access --resync --cache-chunk-size 20M --drive-chunk-size 128M --transfers=8
</code></pre>
<p>仅同步备份到云盘，考虑到云盘备份不需要特别高的实时性，不需要双向同步，所以我选择通过 sync 将硬盘内容定时上传到云盘。<a href="https://rclone.org/commands/rclone_sync/">https://rclone.org/commands/rclone_sync/</a></p>
<p>**将源同步到目标，仅更改目标。**不传输源和目标上相同的文件，按大小和修改时间或 MD5SUM 进行测试。</p>
<p>目标更新以匹配源，<strong>包括在必要时删除文件</strong>（重复对象除外，见下文）。如果不想从目标位置删除文件，请改用复制命令。</p>
<pre><code class="language-shell">rclone sync SOURCE remote:DESTINATION
</code></pre>
<pre><code class="language-shell">rclone sync /data/sdb1/Yellow/ onedrive:/Yellow/ --cache-chunk-size 20M --transfers=8 -P
</code></pre>
<p>​<img src="http://oss.whaleluo.top/blog/img/202307191615987.png-picsmall" alt="image" />​</p>
<p>这是一个关于 <code>bisync</code>​ 命令的错误信息。该错误信息表明，在上一次运行 <code>bisync</code>​ 命令时出现了致命错误，导致无法找到先前的 <code>Path1</code>​ 或 <code>Path2</code>​ 列表。因此，<code>bisync</code>​ 命令无法确定哪些文件需要同步，因此它需要使用 <code>--resync</code>​ 选项来恢复同步操作。</p>
<p>如果您需要在生产环境中进行文件同步操作，建议使用其他可靠的工具，如 <code>rsync</code>​ 或 <code>robocopy</code>​。这些工具已经被广泛使用，并且已经被证明是可靠的文件同步工具。</p>
<pre><code class="language-shell">2023/06/12 08:15:59 NOTICE: bisync is EXPERIMENTAL. Don't use in production!
2023/06/12 08:15:59 INFO : Synching Path1 &quot;/data/sdb1/AMediaBack/&quot; with Path2 &quot;onedrive:AMediaBack/&quot;
2023/06/12 08:15:59 ERROR : Bisync critical error: cannot find prior Path1 or Path2 listings, likely due to critical error on prior run
2023/06/12 08:15:59 ERROR : Bisync aborted. Must run --resync to recover.
</code></pre>
<h3 id="主配置翻译"><a class="header" href="#主配置翻译">主配置翻译</a></h3>
<pre><code class="language-shell">--ask-password 允许提示输入加密配置的密码（默认为true）
--auto-confirm 如果启用，不请求控制台确认
--backup-dir string 将备份制作成基于DIR的层次结构
--bind string 用于传出连接的本地地址，IPv4、IPv6或名称
--buffer-size SizeSuffix 每个--transfer读取文件时的内存缓冲区大小（默认为16Mi）
--bwlimit BwTimetable 带宽限制为KiB/s，或使用后缀B|K|M|G|T|P或完整时间表
--bwlimit-file BwTimetable 每个文件的带宽限制为KiB/s，或使用后缀B|K|M|G|T|P或完整时间表
--ca-cert stringArray 用于验证服务器的CA证书
--cache-dir string rclone将用于缓存的目录（默认为“$HOME/.cache/rclone”）
--check-first 在开始传输之前执行所有检查
--checkers int 并行运行的检查程序数（默认为8）
-c，--checksum 根据校验和（如果可用）和大小跳过，而不是修改时间和大小
--client-cert string 用于相互TLS身份验证的客户端SSL证书（PEM）
--client-key string 用于相互TLS身份验证的客户端SSL私钥（PEM）
--color string 何时显示颜色（和其他ANSI代码）AUTO|NEVER|ALWAYS（默认为“AUTO”）
--compare-dest stringArray 在比较过程中包括其他逗号分隔的服务器端路径
--config string 配置文件（默认为“$HOME/.config/rclone/rclone.conf”）
--contimeout Duration 连接超时（默认为1m0s）
--copy-dest stringArray 意味着--compare-dest，但也将文件从路径复制到目标
--cpuprofile string 将CPU配置文件写入文件
--cutoff-mode string 达到最大传输限制时停止传输的模式HARD|SOFT|CAUTIOUS（默认为“HARD”）
--delete-after 在同步时，在传输后删除目标上的文件（默认）
--delete-before 在同步时，在传输之前删除目标上的文件
--delete-during 在同步时，在传输期间删除文件
--delete-excluded 删除从同步中排除的目标上的文件
--disable string 禁用一系列功能的逗号分隔列表（使用--disable help查看列表）
--disable-http-keep-alives 禁用HTTP保持活动并仅使用每个连接一次。
--disable-http2 在全局传输中禁用HTTP/2
-n，--dry-run 进行试运行，没有永久更改
--dscp string 将DSCP值设置为连接，值或名称，例如CS1、LE、DF、AF21
--dump DumpFlags 要从中转储存的项目列表：头、主体、请求、响应、身份验证、过滤器、goroutines、openfiles
--dump-bodies 转储HTTP头和正文-可能包含敏感信息
--dump-headers 转储HTTP头-可能包含敏感信息
--error-on-no-transfer 如果没有传输文件，则设置退出代码9，在脚本中很有用
--exclude stringArray 排除与模式匹配的文件
--exclude-from stringArray 从文件中读取文件排除模式（使用-从标准输入读取）
--exclude-if-present stringArray 如果文件名存在，则排除目录
--expect-continue-timeout Duration：在使用 HTTP 的 expect / 100-continue 时超时的时间（默认为 1 秒）
--fast-list：如果可用，使用递归列表；使用更多的内存但更少的事务
--files-from stringArray：从文件中读取源文件名列表（使用 - 从标准输入读取）
--files-from-raw stringArray：从文件中读取源文件名列表，而不对行进行任何处理（使用 - 从标准输入读取）
-f, --filter stringArray：添加文件过滤规则
--filter-from stringArray：从文件中读取文件过滤模式（使用 - 从标准输入读取）
--fs-cache-expire-duration Duration：缓存远程文件的时间长度（0 表示禁用缓存）（默认为 5 分钟）
--fs-cache-expire-interval Duration：检查过期远程文件的间隔时间（默认为 1 分钟）
--header stringArray：为所有事务设置 HTTP 标头
--header-download stringArray：为下载事务设置 HTTP 标头
--header-upload stringArray：为上传事务设置 HTTP 标头
--human-readable：以人类可读的格式打印数字，大小带有后缀 Ki|Mi|Gi|Ti|Pi
--ignore-case：在过滤器中忽略大小写（不区分大小写）
--ignore-case-sync：同步时忽略大小写
--ignore-checksum：跳过校验和的后复制检查
--ignore-errors：即使存在 I/O 错误，也要删除
--ignore-existing：跳过所有已存在于目标位置的文件
--ignore-size：在跳过时忽略大小，使用修改时间或校验和
-I, --ignore-times：不跳过与大小和时间匹配的文件 - 传输所有文件
--immutable：不修改文件，如果已修改现有文件，则失败
--include stringArray：包括匹配模式的文件
--include-from stringArray：从文件中读取文件包含模式（使用 - 从标准输入读取）
-i, --interactive：启用交互模式
--kv-lock-time Duration：进程保持键值数据库锁定的最长时间（默认为 1 秒）
--log-file string：将所有内容记录到此文件
--log-format string：日志格式选项的逗号分隔列表（默认为“日期，时间”）
--log-level string：日志级别 DEBUG|INFO|NOTICE|ERROR（默认为“NOTICE”）
--log-systemd：激活日志记录器的 systemd 集成
--low-level-retries int：执行低级别重试的次数（默认为 10）
--max-age Duration：仅传输比此年龄年轻的文件，单位为 s 或后缀 ms|s|m|h|d|w|M|y（默认为关闭）
--max-backlog int：同步或检查后台日志中的最大对象数（默认为 10000）
--max-delete int：在同步时，限制删除的数量（默认为 -1）
--max-delete-size SizeSuffix：在同步时，限制删除的总大小（默认为关闭）
--max-depth int：如果设置，将递归深度限制为此（默认为 -1）
--max-duration Duration：rclone 将传输数据的最长时间（默认为 0 秒）
--max-size SizeSuffix：仅传输小于此大小的文件，单位为 KiB 或后缀 B|K|M|G|T|P（默认为关闭）
--max-stats-groups int：在 max 上，最大的统计组数将保留在内存中，最老的将被丢弃（默认为 1000）
--max-transfer SizeSuffix：要传输的数据的最大大小（默认为关闭）
--memprofile string：将内存配置文件写入文件
-M, --metadata：如果设置，复制对象时保留元数据
--metadata-exclude stringArray：排除与模式匹配的元数据
--metadata-exclude-from stringArray：从文件中读取元数据排除模式（使用 - 从标准输入读取）
--metadata-filter stringArray：添加元数据过滤规则
--metadata-filter-from stringArray：从文件中读取元数据过滤模式（使用 - 从标准输入读取）
--metadata-include stringArray：包括匹配模式的元数据
--metadata-include-from stringArray：从文件中读取元数据包含模式（使用 - 从标准输入读取）
--metadata-set stringArray：上传时添加元数据键=值
--min-age Duration：仅传输比此年龄更老的文件，单位为 s 或后缀 ms|s|m|h|d|w|M|y（默认为关闭）
--min-size SizeSuffix：仅传输大于此大小的文件，单位为 KiB 或后缀 B|K|M|G|T|P（默认为关闭）
--modify-window Duration：被认为是相同的最大时间差异（默认为 1 纳秒）
--multi-thread-cutoff SizeSuffix：对于文件大小超过此值的文件使用多线程下载（默认为 250Mi）
--multi-thread-streams int：用于多线程下载的最大流数（默认为 4）
--no-check-certificate：不验证服务器 SSL 证书（不安全）
--no-check-dest：不检查目标，无论如何都要复制
--no-console：隐藏控制台窗口（仅限 Windows）
--no-gzip-encoding：不设置 Accept-Encoding: gzip
--no-traverse：不在复制时遍历目标文件系统
--no-unicode-normalization：不规范化文件名中的 Unicode 字符
--no-update-modtime：如果文件相同，则不更新目标修改时间
--order-by string：如何排序传输的指令，例如“size，descending”
--password-command SpaceSepList        用于提供加密配置密码的命令
  -P, --progress                             在传输过程中显示进度
      --progress-terminal-title              在终端标题上显示进度（需要 -P/--progress）
  -q, --quiet                                尽可能少地打印信息
      --rc                                   启用远程控制服务器
      --rc-addr stringArray                  IP 地址:端口或 :端口，用于绑定服务器（默认 [localhost:5572]）
      --rc-allow-origin string               设置 CORS 的允许来源
      --rc-baseurl string                    URL 的前缀 - 留空表示根目录
      --rc-cert string                       TLS PEM 密钥（证书和 CA 证书的串联）
      --rc-client-ca string                  客户端证书颁发机构，用于验证客户端
      --rc-enable-metrics                    在 /metrics 上启用 Prometheus 指标
      --rc-files string                      要在 HTTP 服务器上提供的本地文件的路径
      --rc-htpasswd string                   htpasswd 文件 - 如果未提供，则不进行身份验证
      --rc-job-expire-duration Duration      过期完成的异步作业，时间超过此值（默认为 1m0s）
      --rc-job-expire-interval Duration      检查过期的异步作业的间隔时间（默认为 10s）
      --rc-key string                        TLS PEM 私钥
      --rc-max-header-bytes int              请求头的最大大小（默认为 4096）
      --rc-min-tls-version string            可接受的最低 TLS 版本（默认为 &quot;tls1.0&quot;）
      --rc-no-auth                           对某些方法不要求身份验证
      --rc-pass string                       用于身份验证的密码
      --rc-realm string                      用于身份验证的领域
      --rc-salt string                       密码哈希盐（默认为 &quot;dlPL2MqE&quot;）
      --rc-serve                             启用远程对象的服务
      --rc-server-read-timeout Duration      服务器读取数据的超时时间（默认为 1h0m0s）
      --rc-server-write-timeout Duration     服务器写入数据的超时时间（默认为 1h0m0s）
      --rc-template string                   用户指定的模板
      --rc-user string                       用于身份验证的用户名
      --rc-web-fetch-url string              获取 WebGUI 发布的 URL（默认为 &quot;https://api.github.com/repos/rclone/rclone-webui-react/releases/latest&quot;）
      --rc-web-gui                           在本地主机上启动 WebGUI
      --rc-web-gui-force-update              强制更新到 Web GUI 的最新版本
      --rc-web-gui-no-open-browser           不自动打开浏览器
      --rc-web-gui-update                    检查并更新到 Web GUI 的最新版本
      --refresh-times                        刷新远程文件的修改时间
      --retries int                          如果操作失败，重试此次数（默认为 3）
      --retries-sleep Duration               如果操作失败，重试操作之间的间隔时间，例如 500ms、60s、5m（0 表示禁用）（默认为 0s）
      --server-side-across-configs           允许服务器端操作（例如复制）跨不同的配置工作
      --size-only                            仅基于大小跳过，而不是基于修改时间或校验和
      --stats Duration                       打印统计信息的间隔时间，例如 500ms、60s、5m（0 表示禁用）（默认为 1m0s）
      --stats-file-name-length int           统计信息中文件名的最大长度（0 表示无限制）（默认为 45）
      --stats-log-level string               显示 --stats 输出的日志级别 DEBUG|INFO|NOTICE|ERROR（默认为 &quot;INFO&quot;）
      --stats-one-line                       使统计信息适合一行
      --stats-one-line-date                  启用 --stats-one-line 并添加当前日期/时间前缀
      --stats-one-line-date-format string    启用 --stats-one-line-date 并使用自定义格式化日期：将日期字符串括在双引号中，参见 https://golang.org/pkg/time/#Time.Format
      --stats-unit string                    在统计信息中以每秒字节或比特的形式显示数据速率（默认为 &quot;bytes&quot;）
      --streaming-upload-cutoff SizeSuffix   如果文件大小未知，则切换到分块上传的截止点，在达到截止点或文件结束时开始上传（默认为 100Ki）
      --suffix string                        添加到更改的文件后缀
      --suffix-keep-extension                在使用 --suffix 时保留扩展名
      --syslog                               使用 Syslog 记录日志
      --syslog-facility string               Syslog 的设施，例如 KERN、USER...（默认为 &quot;DAEMON&quot;）
      --temp-dir string                      rclone 将用于临时文件的目录（默认为 &quot;/tmp&quot;）
      --timeout Duration                     IO 空闲超时时间（默认为 5m0s）
      --tpslimit float                       每秒限制 HTTP 事务数
      --tpslimit-burst int                   --tpslimit 的最大事务数（默认为 1）
      --track-renames                        在同步时，跟踪文件重命名并在可能的情况下进行服务器端移动
      --track-renames-strategy string        使用 track-renames 时同步时使用的策略 hash|modtime|leaf（默认为 &quot;hash&quot;）
      --transfers int                        并行运行的文件传输数（默认为 4）
  -u, --update                               跳过在目标位置更新的较新文件
      --use-cookies                          启用会话 cookiejar
      --use-json-log                         使用 json 日志格式
      --use-mmap                             使用 mmap 分配器（请参阅文档）
      --use-server-modtime                   使用服务器修改时间而不是对象元数据
      --user-agent string                    将用户代理设置为指定的字符串（默认为 &quot;rclone/v1.62.2&quot;）
  -v, --verbose count                        打印更多的信息（重复以获得更多）
</code></pre>
<h3 id="同步坚果云"><a class="header" href="#同步坚果云">同步坚果云</a></h3>
<p>因为坚果云 Webdav 有并发限制，所以需要限制线程数慢慢拉取。</p>
<p>将坚果云拉取到本地。</p>
<pre><code class="language-shell"># rclone sync --interactive SOURCE remote:DESTINATION

docker run --rm \
-v /root/rclone:/config/rclone \
-v /mnt/:/data \
-v /root/rclone/bisync:/root/.cache/rclone/bisync \
--user $(id -u):$(id -g) \
rclone/rclone sync \
JGY:/ \
/data/sdb1/JianGuoYunBack/ \
--cache-chunk-size 20M \
--transfers=1 \
--verbose
</code></pre>
<h3 id="在容器内定时运行同步命令"><a class="header" href="#在容器内定时运行同步命令">在容器内定时运行同步命令</a></h3>
<p><a href="https://meishizaolunzi.com/cron-in-docker/">https://meishizaolunzi.com/cron-in-docker/</a></p>
<p>Alpine：已经预装，可以使用 <code>which crond</code>​ 查看。</p>
<p>对于 Docker 容器来说，多用户的作用不大，只需要专注全局的配置文件：<code>/etc/crontab</code>​ 即可。</p>
<pre><code class="language-shell">vi /etc/crontab

* * * * * root date
</code></pre>
<h3 id="通过-crantab-实现定时备份"><a class="header" href="#通过-crantab-实现定时备份">通过 Crantab 实现定时备份</a></h3>
<p>写一个备份脚本：rclone_bak.sh</p>
<p>实测 22000 个文件需要大概 6 分 35 秒 才能完全扫描并同步。</p>
<p>双向同步前需要先在 Onedrive 创建文件夹。</p>
<pre><code class="language-shell">#!/bin/bash
# Website:  https://whalefall.top/

DATE=`date +%Y%m%d`

ARCHIVE_LOG_FILE=/root/backup.log

# Yellow 
docker run --rm -v /root/rclone:/config/rclone -v /mnt/:/data -v /root/rclone/bisync:/root/.cache/rclone/bisync --user $(id -u):$(id -g) rclone/rclone bisync /data/sdb1/Yellow/ onedrive:/Yellow/ --check-access --resync --workdir=/root/.cache/rclone/bisync --cache-chunk-size 20M --transfers=8 --verbose &gt;&gt; $ARCHIVE_LOG_FILE 2&gt;&amp;1

# AMediaBack
docker run --rm -v /root/rclone:/config/rclone -v /mnt/:/data -v /root/rclone/bisync:/root/.cache/rclone/bisync --user $(id -u):$(id -g) rclone/rclone bisync /data/sdb1/AMediaBack/ onedrive:/AMediaBack/ --check-access --resync --workdir=/root/.cache/rclone/bisync --cache-chunk-size 20M --transfers=8 --verbose &gt;&gt; $ARCHIVE_LOG_FILE 2&gt;&amp;1

# Music
docker run --rm -v /root/rclone:/config/rclone -v /mnt/:/data -v /root/rclone/bisync:/root/.cache/rclone/bisync --user $(id -u):$(id -g) rclone/rclone bisync /data/sdb1/Music/ onedrive:/Music/ --check-access --resync --workdir=/root/.cache/rclone/bisync --cache-chunk-size 20M --transfers=8 --verbose &gt;&gt; $ARCHIVE_LOG_FILE 2&gt;&amp;1

# Output log file
echo -e &quot;\e[1;32m---------------------------------------------\e[0m&quot; &gt;&gt; $ARCHIVE_LOG_FILE
echo -e &quot;每日备份 Backup date: &quot;$(date +%Y-%m-%d)&quot;\t&quot;&quot;Finish time: &quot;$(date +%H:%M:%S) &gt;&gt; $ARCHIVE_LOG_FILE
echo -e &quot;\e[1;32m---------------------------------------------\e[0m\n&quot; &gt;&gt; $ARCHIVE_LOG_FILE
</code></pre>
<p>快速备份文件夹，双向同步。<a href="https://rclone.org/commands/rclone_bisync/">https://rclone.org/commands/rclone_bisync/</a></p>
<blockquote>
<p>This will effectively make both Path1 and Path2 filesystems contain a matching superset of all files. Path2 files that do not exist in Path1 will be copied to Path1, and the process will then sync the Path1 tree to Path2.</p>
</blockquote>
<pre><code class="language-shell">#!/bin/bash
# Website:  https://whalefall.top/

DATE=`date +%Y%m%d`

ARCHIVE_LOG_FILE=/root/backup_fast.log

# onedrive_fast
docker run --rm -v /root/rclone:/config/rclone -v /mnt/:/data -v /root/rclone/bisync:/root/.cache/rclone/bisync --user $(id -u):$(id -g) rclone/rclone bisync /data/sdb1/onedrive_fast/ onedrive:/onedrive_fast/ --check-access --resync --workdir=/root/.cache/rclone/bisync --cache-chunk-size 20M --transfers=8 &gt;&gt; $ARCHIVE_LOG_FILE 2&gt;&amp;1

# Output log file
echo -e &quot;\e[1;32m---------------------------------------------\e[0m&quot; &gt;&gt; $ARCHIVE_LOG_FILE
echo -e &quot;快速备份 Backup date: &quot;$(date +%Y-%m-%d)&quot;\t&quot;&quot;Finish time: &quot;$(date +%H:%M:%S) &gt;&gt; $ARCHIVE_LOG_FILE
echo -e &quot;\e[1;32m---------------------------------------------\e[0m\n&quot; &gt;&gt; $ARCHIVE_LOG_FILE
</code></pre>
<h3 id="简单同步"><a class="header" href="#简单同步">简单同步</a></h3>
<p>将源同步到目标，只修改目标。</p>
<blockquote>
<p>参考：<a href="https://superuser.com/questions/1729603/rclone-to-onedrive-is-excruciatingly-slow">performance - rclone to OneDrive is excruciatingly slow - Super User</a><br />
<code>--drive-chunk-size 128M</code> 增加上传文件分块的大小。</p>
</blockquote>
<pre><code class="language-shell">docker run --rm \
-v /root/rclone:/config/rclone \
-v /mnt/:/data \
-v /root/rclone/bisync:/root/.cache/rclone/bisync \
--user $(id -u):$(id -g) \
rclone/rclone sync \
/data/sdb1/AMediaBack/ \
onedrive:/AMediaBack/ \
--cache-chunk-size 20M \
--drive-chunk-size 128M \
--transfers=8 \
--verbose
</code></pre>
<p>pastes：</p>
<pre><code class="language-shell">docker run --rm \
-v /root/rclone:/config/rclone \
-v /mnt/:/data \
-v /root/rclone/bisync:/root/.cache/rclone/bisync \
--user $(id -u):$(id -g) \
rclone/rclone sync \
/data/sdb1/WinEXE/ \
onedrive:/WinEXE/ \
--cache-chunk-size 20M \
--transfers=8 \
--verbose

# 神秘学资料

docker run --rm \
-v /root/rclone:/config/rclone \
-v /mnt/:/data \
-v /root/rclone/bisync:/root/.cache/rclone/bisync \
--user $(id -u):$(id -g) \
rclone/rclone sync \
/data/sdb1/神秘学资料/ \
onedrive:/神秘学资料/ \
--cache-chunk-size 20M \
--transfers=8 \
--verbose

# HamRadio

docker run --rm \
-v /root/rclone:/config/rclone \
-v /mnt/:/data \
-v /root/rclone/bisync:/root/.cache/rclone/bisync \
--user $(id -u):$(id -g) \
rclone/rclone sync \
/data/sdb1/HamRadio/ \
onedrive:/HamRadio/ \
--cache-chunk-size 20M \
--transfers=8 \
--verbose

# 双向同步 AMediaBack
$ docker run --rm \
-v /root/rclone:/config/rclone \
-v /mnt/:/data \
-v /root/rclone/bisync:/root/.cache/rclone/bisync \
--user $(id -u):$(id -g) \
rclone/rclone bisync \
/data/sdb1/AMediaBack/ \
onedrive:/AMediaBack/ \
--cache-chunk-size 20M \
--transfers=8 \
--localtime \
--verbose --resync --check-access


rclone --config=&quot;/root/rclone/rclone.conf&quot; \
--checkers=16 --cache-dir=&quot;/root/rclone/&quot; \
--transfers=10 --verbose --cache-chunk-size=20M \
rclone bisync --config=&quot;/root/rclone/rclone.conf&quot; \
--checkers=80 --cache-dir=&quot;/root/rclone/&quot; \
--transfers=10 --verbose --cache-chunk-size=20M --check-first --stats=1s --checksum --retries 3 --low-level-retries 10 \
/mnt/sdb1/Onedrive-Sync \
onedrive: \
--resync --check-access --dry-run -vvv --localtime --timeout=10s 


# rclone browser generate command
D:\rclone-v1.62.2-windows-amd64\rclone.exe copy --ignore-existing --verbose --transfers 2 --checkers 80 --contimeout 60s --timeout 300s --retries 3 --low-level-retries 10 --stats 1s --stats-file-name-length 0 --fast-list jgy:我的坚果云 E:\jgy\我的坚果云\

</code></pre>
<h3 id="查看-rclone-进程"><a class="header" href="#查看-rclone-进程">查看 Rclone 进程</a></h3>
<pre><code class="language-shell">ps -ef | grep rclone
13307 root      727m S    docker run --rm -v /root/rclone:/config/rclone -v /mnt/:/data -v /root/rclone/bisync:/root/.
13611 root      745m S    rclone sync JGY:/ /data/sdb1/JianGuoYunBack/ --cache-chunk-size 20M --transfers=1 --verbose
14867 root      727m S    docker run --rm -v /root/rclone:/config/rclone -v /mnt/:/data -v /root/rclone/bisync:/root/.
15207 root     1134m S    rclone sync /data/sdb1/WinEXE/ onedrive:/WinEXE/ --cache-chunk-size 20M --transfers=8 --verb
15651 root      726m S    docker run --rm -v /root/rclone:/config/rclone -v /mnt/:/data -v /root/rclone/bisync:/root/.
16003 root      939m S    rclone sync /data/sdb1/神秘学资料/ onedrive:/神秘学资料/ --cache-chunk-size 20M --
17596 root      1124 S    grep rclone
</code></pre>
<h3 id="rcloneng-ui"><a class="header" href="#rcloneng-ui">RcloneNg UI</a></h3>
<p><a href="https://github.com/ElonH/RcloneNg">https://github.com/ElonH/RcloneNg</a></p>
<h2 id="windows-mount"><a class="header" href="#windows-mount">Windows Mount</a></h2>
<p>使用 Rclone 挂载 Onedrive 盘。</p>
<blockquote>
<p>official docs： <a href="https://rclone.org/commands/rclone_mount/">https://rclone.org/commands/rclone_mount/</a><br />
fix <a href="https://forum.rclone.org/t/onedrive-mount-extremely-slow/28267">OneDrive mount - extremely slow</a></p>
</blockquote>
<pre><code class="language-shell">rclone mount onedrive: q: --network-mode --cache-dir E:\onedrive --volname=rclone_od --vfs-cache-mode=full --vfs-cache-max-size=20G --vfs-read-chunk-size-limit=256M --user-agent=Chrome --no-checksum --no-modtime --drive-chunk-size=256M
</code></pre>
<ul>
<li><code>--allow-other</code>：指的是允许非当前 Rclone 用户外的用户进行访问</li>
<li><code>--attr-timeout 5m</code>：文件属性缓存，（大小，修改时间等）的时间。如果小鸡配置比较低，建议适当提高这个值，避免过多的和内核交互，占用资源。</li>
<li><code>-vfs-cache-mode full</code>：开启 VFS 文件缓存，这样可减少 Rclone 与 API 交互，同时可提高文件读写效率</li>
<li><code>--vfs-cache-max-age 24h</code>：VFS 文件缓存时间，这里设置的 24 小时，如果文件很少更改，建议设置更长的时间</li>
<li><code>--vfs-cache-max-size 10G</code>：VFS 文件缓存上限大小，建议不超过当前空余磁盘的 50%</li>
<li><code>vfs-read-chunk-size-limit 100M</code>：分块读取大小，这里设置的是 100M，可提高文件读的效率，比如 1G 的文件，大致分为 10 个块进行读取，但与此同时 API 请求次数也会增多</li>
<li><code>--buffer-size 100M</code>：内存缓存，如果您内存比较小，可降低此值，如果内存比较大，可适当提高</li>
<li><code>--daemon</code>：指后台方式运行</li>
<li><code>--drive-chunk-size 128M</code>：增加上传文件分块的大小。</li>
</ul>
<h2 id="onedrive-index-在线列出网盘"><a class="header" href="#onedrive-index-在线列出网盘">Onedrive Index 在线列出网盘</a></h2>
<p><a href="https://github.com/spencerwooo/onedrive-vercel-index">https://github.com/spencerwooo/onedrive-vercel-index</a></p>
<p>最大的优点是 Server-less (free) 使用 vercel 免费部署并支持绑定自定义域名。</p>
<p>Quick Start：<a href="https://ovi.swo.moe/docs/getting-started">https://ovi.swo.moe/docs/getting-started</a></p>
<p>申请个人 API：<a href="https://ovi.swo.moe/docs/advanced#using-your-own-clientid-and-clientsecret-1">https://ovi.swo.moe/docs/advanced#using-your-own-clientid-and-clientsecret-1</a></p>
<h3 id="解决部署一周后出现的-404-错误"><a class="header" href="#解决部署一周后出现的-404-错误">解决部署一周后出现的 404 错误</a></h3>
<p>今天是 2023/6/6 日，上去云盘看突然显示部署错误了：</p>
<p>​<img src="http://oss.whaleluo.top/blog/img/202307191615988.png-picsmall" alt="image" />​</p>
<p>经过 Github Issue 查找，<a href="https://github.com/spencerwooo/onedrive-vercel-index/discussions/722">#772</a> 也同样存在这个问题，解决方法：</p>
<blockquote>
<p>如果一进入首页就显示这个提示的话，请检查下最近是否修改过 <code>Microsoft</code>​ 的账户密码。如有修改请删除 <code>upstash</code>​ 中的 redis 缓存，再刷新你的网站重新进行认证。</p>
<p>進入<br />
<a href="https://console.upstash.com/">https://console.upstash.com/</a><br />
首頁會看到<br />
Databases<br />
<a href="https://console.upstash.com/redis/">onedrive-vercel-index</a></p>
<p>點進去後點上方的 Data Browser<br />
把裡面的 token 都刪除<br />
就可以重新認證了</p>
</blockquote>
<p>一查是因为 redis 在线网站限额。改用 <a href="https://app.redislabs.com/">https://app.redislabs.com/</a></p>
<p>discuss 当站点访问量过大时： <a href="https://github.com/spencerwooo/onedrive-vercel-index/discussions/595">https://github.com/spencerwooo/onedrive-vercel-index/discussions/595</a> 使用：<a href="https://redis.com/try-free/">https://redis.com/try-free/</a></p>
<h2 id="onemanager-serverless"><a class="header" href="#onemanager-serverless">OneManager Serverless</a></h2>
<p><a href="https://github.com/qkqpttgf/OneManager-php/blob/master/readme_cn.md">OneManager Serverless</a></p>
<h2 id="使用-alist"><a class="header" href="#使用-alist">使用 Alist</a></h2>
<p>文档：<a href="https://alist-doc.nn.ci/docs/driver/onedrive/">https://alist-doc.nn.ci/docs/driver/onedrive/</a></p>
<h2 id="use-proxy"><a class="header" href="#use-proxy">Use Proxy</a></h2>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<pre><code class="language-shell">set http_proxy=socks5://127.0.0.1:10808
set https_proxy=$http_proxy
set HTTP_PROXY=$http_proxy
set HTTPS_PROXY=$http_proxy

D:\rclone-v1.62.2-windows-amd64\rclone.exe copy --verbose --transfers 16 --checkers 8 --contimeout 60s --timeout 300s --retries 3 --low-level-retries 10 --stats 1s --stats-file-name-length 0 --fast-list Z:\sdb1\2022.11.26白纸革命 onedrive:政治/2022.11.26白纸革命
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: GitHub Workflow 工作流使用笔记
date: 2022-03-29 20:51:48
updated: 2022-03-29 20:51:48
categories: GitHub
tags: [GitHub, Workflow]
description: GitHub Workflow 工作流使用笔记</p>
<hr />
<h1 id="github-workflow"><a class="header" href="#github-workflow">Github-workflow</a></h1>
<p>下面是格式化后的 YAML 文件：</p>
<pre><code class="language-yaml">name: commit HexoBlogSource (Obsidian update)

on:
  push:
    branches:
      - main

jobs:
  submit:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
        
      - name: git config
        run: |
          git config --local user.email &quot;41898282+github-actions[bot]@users.noreply.github.com&quot;
          git config --local user.name &quot;github-actions[bot]&quot;
          git commit -a -m &quot;Add changes&quot;

      - name: New Branch to pull
        run: |
          git checkout -b temp-branch
          git add .
          git commit -m &quot;Obsidian Update&quot;
          

      - name: Push to target repository
        uses: ad-m/github-push-action@v0.5.0
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          branch: main
          directory: /source/__post/
          repository: WhaleFell/HexoBlogSource
</code></pre>
<p>我移除了缩进错误，并确保所有步骤的格式正确。请注意，我没有更改步骤的顺序或内容，只是对整个 YAML 文件进行了格式化。</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>title: 【科普向】如何在 China 轻松免费使用 ChatGPT
date: 2023-07-24 17:39:67
updated: 2023-07-24 17:39:67
categories: ChatGPT
tags: [AI, ChatGPT, 小白, 科普]
description: 
thumbnail: http://oss.whaleluo.top/blog/img/202307241743871.png-picsmall
banner_img: http://oss.whaleluo.top/blog/img/202307241743871.png-picsmall</h2>
<h1 id="科普向如何在-china-轻松免费使用-chatgpt"><a class="header" href="#科普向如何在-china-轻松免费使用-chatgpt">【科普向】如何在 China 轻松免费使用 ChatGPT</a></h1>
<p><img src="http://oss.whaleluo.top/blog/img/202307241743871.png-picsmall" alt="" /></p>
<h2 id="start"><a class="header" href="#start">Start</a></h2>
<p>ChatGPT，是一个由美国公司 <strong>OpenAI</strong> 开发的一个基于大数据文字模型的人工智能系统。简单来说就是可以聊天帮你解决问题的一个对话系统。</p>
<p>众所周知，<strong>China Gov</strong> 因为一些原因将 ChatGPT 拒之门外，宛如当年满清慈禧太后将西人的蒸汽机车拒之国门外的场景，十分讽刺。</p>
<p><img src="http://oss.whaleluo.top/blog/img/how-to-ues-free-ChatGPT-in-China-chixitaihou.png-picsmall" alt="" /></p>
<blockquote>
<p>据记载，1888年清朝政府在北京西苑修建了一条铁路，慈禧太后因火车司机坐在自己前面开车，弃用了从德国引进的蒸汽机车而改用太监牵拉。——《全球通史》</p>
</blockquote>
<p>综上所述，在中共国，墙内的鼠鼠们有以下渠道可以自由使用 ChatGPT：</p>
<ol>
<li>使用 <strong>魔法</strong> 软件，进入 <strong>国际互联网</strong>，使用官方 <a href="https://chat.openai.com/">ChatGPT</a> 的服务器。门槛较高，需要非86手机号注册 OpenAI Account 但可以稳定使用。魔法软件的使用请看我的这篇文字 <a href="https://whaleluo.top/clash-proxy-guide/">Clash 小猫咪使用备忘 | 😊落落のBlog😊</a></li>
<li>使用国内套壳的 ChatGPT 镜像网站，这种一般是个人自建，<strong>隐私和安全性得不到保障</strong>，内容也有所审查。缺点是不稳定可能随时跑路。优点是免费。</li>
<li>使用国内的其他 AI 服务代替，例如 百度 <strong>文心一言</strong> 之类的云云。当然相比正统 ChatGPT ，这些只是个玩具。</li>
</ol>
<p>基于本文针对的对象是想体验并使用 ChatGPT 的小白白，本文主要阐述第二种方案。</p>
<h2 id="github-free-gpt-项目"><a class="header" href="#github-free-gpt-项目">GitHub Free GPT 项目</a></h2>
<p>这是一个公开的 GitHub Repo 会分享一些国内可用的 ChatGPT 镜像地址，点进去就可以使用了</p>
<p>链接：<a href="https://github.com/LiLittleCat/awesome-free-chatgpt/tree/main">GitHub - LiLittleCat/awesome-free-chatgpt: 🆓免费的 ChatGPT 镜像网站列表，持续更新。List of free ChatGPT mirror sites, continuously updated.</a></p>
<p>（国内网络打开 GitHub 链接缓慢）</p>
<p><img src="http://oss.whaleluo.top/blog/img/how-to-ues-free-ChatGPT-in-China-github-free-gpt-repo.png-picsmall" alt="GITHUB" /></p>
<p>下面是一些网站的 URL，<strong>请注意时效性</strong>。</p>
<p><img src="http://oss.whaleluo.top/blog/img/how-to-ues-free-ChatGPT-in-China-url.png-picsmall" alt="" /></p>
<h3 id="自用"><a class="header" href="#自用">自用</a></h3>
<p><a href="https://site.easygpt.work/">https://site.easygpt.work/</a></p>
<p>笔者自用的是 <a href="https://site.easygpt.work/">EasyGPT地址发布页</a> 用了几个月比较稳定，3.5 模型也是免费的，点进去就会出现一个 EasyGPT 的导航页，挑一个延时小的使用。如果一个网址不可使用，返回引导页再尝试另一个。若服务完全不可用，请尝试下文提供的 GitHub 镜像网址合集。</p>
<p><img src="http://oss.whaleluo.top/blog/img/how-to-ues-free-ChatGPT-in-China-index.png-picsmall" alt="" /></p>
<p><strong>WAN</strong>: 使用第三方 ChatGPT 国内套壳服务时 <strong>请勿提交敏感信息</strong>，网站运营者 <strong>会查看的到你提交的任何内容</strong>. 若提交一些 <strong>NSFW</strong> (NOT SEE FOR WORK) 及一些涉政的内容，<strong>网站运营者可能会把你的 IP 地址提交给网安国保之类的机构，请鼠鼠们注意！</strong></p>
<h2 id="镜像合集-2023724-update"><a class="header" href="#镜像合集-2023724-update">镜像合集 2023/7/24 update</a></h2>
<div class="table-wrapper"><table><thead><tr><th>序号</th><th>网站</th><th>标签</th><th>添加时间</th><th>备注</th></tr></thead><tbody>
<tr><td>1</td><td><a href="https://free.icoding.ink/">https://free.icoding.ink/</a></td><td>🆓 💪</td><td>2023-07-11</td><td></td></tr>
<tr><td>2</td><td><a href="https://doai.c1ns.cn/">https://doai.c1ns.cn</a></td><td>🆓 💪</td><td>2023-07-07</td><td></td></tr>
<tr><td>3</td><td><a href="https://gptleg.zeabur.app/">https://gptleg.zeabur.app/</a></td><td>🆓 💪</td><td>2023-07-07</td><td></td></tr>
<tr><td>4</td><td><a href="https://py.c1ns.cn/">https://py.c1ns.cn</a></td><td>🆓 💪</td><td>2023-06-25</td><td></td></tr>
<tr><td>5</td><td><a href="https://free.easychat.work/">https://free.easychat.work</a></td><td>🆓 💪</td><td>2023-06-18</td><td>备用链接: <a href="https://www.easygpt.work/">https://www.easygpt.work</a></td></tr>
<tr><td>6</td><td><a href="http://chat3.aiyunos.top/">http://chat3.aiyunos.top</a></td><td>🆓 💪</td><td>2023-06-17</td><td></td></tr>
<tr><td>7</td><td><a href="https://chatc.free2gpt.xyz/">https://chatc.free2gpt.xyz/</a></td><td>🆓</td><td>2023-07-13</td><td></td></tr>
<tr><td>8</td><td><a href="http://c.newstop.uk/">http://c.newstop.uk</a></td><td>🆓</td><td>2023-07-12</td><td></td></tr>
<tr><td>9</td><td><a href="https://openai.aifree.site/">https://openai.aifree.site/</a></td><td>🆓</td><td>2023-07-11</td><td></td></tr>
<tr><td>10</td><td><a href="https://ai.azstudio.top/">https://ai.azstudio.top/</a></td><td>🆓</td><td>2023-07-10</td><td></td></tr>
<tr><td>11</td><td><a href="https://ai.zenglingkun.cn/">https://ai.zenglingkun.cn/</a></td><td>🆓</td><td>2023-07-10</td><td></td></tr>
<tr><td>12</td><td><a href="https://chatgpt.kiask.xyz/">https://chatgpt.kiask.xyz/</a></td><td>🆓</td><td>2023-07-09</td><td></td></tr>
<tr><td>13</td><td><a href="https://xiaoc.eu.org/">https://xiaoc.eu.org/</a></td><td>🆓</td><td>2023-07-08</td><td>访问码:754685.</td></tr>
<tr><td>14</td><td><a href="https://xiaor.eu.org/">https://xiaor.eu.org/</a></td><td>🆓</td><td>2023-07-04</td><td></td></tr>
<tr><td>15</td><td><a href="https://chat.acytoo.com/">https://chat.acytoo.com/</a></td><td>🆓</td><td>2023-07-01</td><td></td></tr>
<tr><td>16</td><td><a href="https://chat.dfehub.com/">https://chat.dfehub.com</a></td><td>🆓</td><td>2023-06-30</td><td></td></tr>
<tr><td>17</td><td><a href="http://g01.plitun.com/">http://g01.plitun.com/</a></td><td>🆓</td><td>2023-06-29</td><td></td></tr>
<tr><td>18</td><td><a href="https://gpt4.ezchat.top/">https://gpt4.ezchat.top/</a></td><td>🆓</td><td>2023-06-28</td><td></td></tr>
<tr><td>19</td><td><a href="https://c1ns.cn/chat/">https://c1ns.cn/chat/</a></td><td>🆓</td><td>2023-06-26</td><td></td></tr>
<tr><td>20</td><td><a href="https://macqv.com/">https://macqv.com</a></td><td>🆓</td><td>2023-06-26</td><td></td></tr>
<tr><td>21</td><td><a href="https://newstop.c1ns.cn/">https://newstop.c1ns.cn/</a></td><td>🆓</td><td>2023-06-25</td><td></td></tr>
<tr><td>22</td><td><a href="https://gpt.aifree.site/">https://gpt.aifree.site/</a></td><td>🆓</td><td>2023-06-24</td><td></td></tr>
<tr><td>23</td><td><a href="https://hteyun.com/">https://hteyun.com/</a></td><td>🆓</td><td>2023-06-23</td><td></td></tr>
<tr><td>24</td><td><a href="https://chat.weuseing.com/">https://chat.weuseing.com/</a></td><td>🆓</td><td>2023-06-17</td><td></td></tr>
<tr><td>25</td><td><a href="https://zyq-chatgpt.github.io/">https://zyq-chatgpt.github.io</a></td><td>🆓</td><td>2023-06-16</td><td></td></tr>
<tr><td>26</td><td><a href="http://chat.aisoftworks.com/">http://chat.aisoftworks.com</a></td><td>🆓</td><td>2023-06-15</td><td></td></tr>
<tr><td>27</td><td><a href="https://gptdidi.com/">https://gptdidi.com/</a></td><td>🆓</td><td>2023-06-14</td><td></td></tr>
<tr><td>28</td><td><a href="http://chat.darkflow.top/">http://chat.darkflow.top/</a></td><td>🆓</td><td>2023-06-13</td><td></td></tr>
<tr><td>29</td><td><a href="http://chat3.aiyunos.top/">http://chat3.aiyunos.top</a></td><td>🆓</td><td>2023-06-13</td><td></td></tr>
<tr><td>30</td><td><a href="https://chat.flares.ai/">https://chat.flares.ai/</a></td><td>🆓</td><td>2023-06-08</td><td></td></tr>
<tr><td>31</td><td><a href="https://devgpt.com/">https://devgpt.com/</a></td><td>🆓</td><td>2023-06-08</td><td></td></tr>
<tr><td>32</td><td><a href="https://chat.newstop.asia/">https://chat.newstop.asia/</a></td><td>🆓</td><td>2023-06-06</td><td></td></tr>
<tr><td>33</td><td><a href="https://nb8.c1ns.cn/">https://nb8.c1ns.cn/</a></td><td>🆓</td><td>2023-06-02</td><td></td></tr>
<tr><td>34</td><td><a href="https://chatyou.lovebaby.today/">https://chatyou.lovebaby.today/</a></td><td>🆓</td><td>2023-06-01</td><td></td></tr>
<tr><td>35</td><td><a href="https://www.magicaibot.com/talk">https://www.magicaibot.com/talk</a></td><td>🆓</td><td>2023-06-01</td><td></td></tr>
<tr><td>36</td><td><a href="https://521.zeabur.app/">https://521.zeabur.app/</a></td><td>🆓</td><td>2023-06-01</td><td></td></tr>
<tr><td>37</td><td><a href="https://chat.kunshanyuxin.com/">https://chat.kunshanyuxin.com/</a></td><td>🆓</td><td>2023-05-31</td><td></td></tr>
<tr><td>38</td><td><a href="https://chat.jubianxingqiu.com/">https://chat.jubianxingqiu.com/</a></td><td>🆓</td><td>2023-05-31</td><td></td></tr>
<tr><td>39</td><td><a href="https://tchat.c1ns.cn/">https://tchat.c1ns.cn/</a></td><td>🆓</td><td>2023-05-29</td><td></td></tr>
<tr><td>40</td><td><a href="https://a.aiask.me/">https://a.aiask.me/</a></td><td>🆓</td><td>2023-05-26</td><td></td></tr>
<tr><td>41</td><td><a href="https://ai.gptforlove.com/">https://ai.gptforlove.com/</a></td><td>🆓</td><td>2023-05-26</td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: 个人常用的 Vim 配置
date: 2023-01-29 1:37:48
updated: 2023-01-29 1:37:48
categories: Linux
tags: [Vim, Linux]
thumbnail:
banner_img:</p>
<hr />
<h1 id="vim-常用配置"><a class="header" href="#vim-常用配置">Vim 常用配置</a></h1>
<p>经常在服务端上修改文件，苦于 vim 默认的界面很不友好，又不想重现手捏配置文件，就分享一下个人常用的简单配置吧。</p>
<h2 id="配置"><a class="header" href="#配置">配置</a></h2>
<blockquote>
<p><strong>自用 ​</strong>​**<code>.vimrc</code><strong>​</strong>​ 已上传到 GitHub 仓库**<br />
参考：<a href="https://github.com/WhaleFell/vimrc/blob/main/.vimrc">WhaleFell/vimrc</a><br />
raw: <a href="https://raw.githubusercontent.com/WhaleFell/vimrc/main/.vimrc">https://raw.githubusercontent.com/WhaleFell/vimrc/main/.vimrc</a></p>
</blockquote>
<p>设置中文字符集</p>
<pre><code class="language-shell">dpkg-reconfigure locales
</code></pre>
<p>在用户目录下创建配置。</p>
<pre><code class="language-shell">vim ~/.vimrc
</code></pre>
<p>写入以下配置</p>
<pre><code class="language-txt">&quot; 打开语法高亮
syntax on

&quot; 使用配色方案
colorscheme desert

&quot; 打开文件类型检测功能
filetype on

&quot; 不同文件类型采用不同缩进
filetype indent on

&quot; 允许使用插件
filetype plugin on
filetype plugin indent on

&quot; 允许区域选择
set selection=exclusive
set selectmode=mouse,key

&quot; 高亮光标所在行
set cursorline

&quot; 取消光标闪烁
set novisualbell

&quot; 状态栏显示当前执行的命令
set showcmd

&quot; 标尺功能，显示当前光标所在行列号
set ruler

&quot; 粘贴时保持格式
set paste

&quot; 高亮显示匹配的括号
set showmatch

&quot; 在搜索的时候忽略大小写
set ignorecase
 
&quot; 高亮被搜索的句子
set hlsearch
 
&quot; 在搜索时，输入的词句的逐字符高亮（类似firefox的搜索）
set incsearch

&quot; 继承前一行的缩进方式，特别适用于多行注释
set autoindent

&quot; 为C程序提供自动缩进
set smartindent

&quot; 使用C样式的缩进
set cindent

&quot; 制表符为4
set tabstop=4

&quot; 统一缩进为4
set softtabstop=4
set shiftwidth=4
set tabstop=4

&quot; 允许使用退格键，或set backspace=2
set backspace=eol,start,indent
set whichwrap+=&lt;,&gt;,h,l

&quot; 取消换行
set nowrap

&quot; 启动的时候不显示那个援助索马里儿童的提示
set shortmess=atI

&quot; 在被分割的窗口间显示空白，便于阅读
set fillchars=vert:\ ,stl:\ ,stlnc:\

&quot; 光标移动到buffer的顶部和底部时保持3行距离, 或set so=3
set scrolloff=3

&quot; 设定默认解码
set fenc=utf-8
set fencs=utf-8,usc-bom,euc-jp,gb18030,gbk,gb2312,cp936
 
&quot; 设定编码
set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936
set termencoding=utf-8
set encoding=utf-8
set enc=utf-8
set langmenu=zh_CN.UTF-8
language message zh_CN.UTF-8
source $VIMRUNTIME/delmenu.vim
source $VIMRUNTIME/menu.vim

&quot; 自动补全
filetype plugin indent on
set completeopt=longest,menu

&quot; 自动补全命令时候使用菜单式匹配列表
set wildmenu
autocmd FileType ruby,eruby set omnifunc=rubycomplete#Complete
autocmd FileType python set omnifunc=pythoncomplete#Complete
autocmd FileType javascript set omnifunc=javascriptcomplete#CompleteJS
autocmd FileType html set omnifunc=htmlcomplete#CompleteTags
autocmd FileType css set omnifunc=csscomplete#CompleteCSS
autocmd FileType xml set omnifunc=xmlcomplete#CompleteTags
autocmd FileType java set omnifunc=javacomplete#Complet

&quot; 行号
set number

&quot; 突出显示
set cursorline

&quot; 关闭鼠标
set mouse=c

&quot; 启动鼠标
&quot; set mouse=a

set selection=exclusive
set selectmode=mouse,key

&quot; 自动缩进
set autoindent

&quot; 语法高亮
syntax enable

&quot; 文件类型检查
filetype indent on

&quot; status line
set laststatus=2
set statusline=\ %{HasPaste()}%F%m%r%h\ %w\ \ CWD:\ %r%{getcwd()}%h\ \ \ Line:\ %l\ \ Column:\ %c

&quot; other

&quot; Set to auto read when a file is changed from the outside
set autoread
au FocusGained,BufEnter * checktime

&quot; When searching try to be smart about cases
set smartcase

&quot; No annoying sound on errors
set noerrorbells
set novisualbell
set t_vb=
set tm=500

&quot; Turn backup off
set nobackup
set nowb
set noswapfile

&quot; Use spaces instead of tabs
set expandtab

&quot; Be smart when using tabs ;)
set smarttab

&quot; Linebreak on 500 characters
set lbr
set tw=500

set ai &quot;Auto indent
set si &quot;Smart indent
set wrap &quot;Wrap lines

&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;
&quot; =&gt; Helper functions
&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;
&quot; Returns true if paste mode is enabled
function! HasPaste()
    if &amp;paste
        return 'PASTE MODE  '
    endif
    return ''
endfunction

&quot; Don't close window, when deleting a buffer
command! Bclose call &lt;SID&gt;BufcloseCloseIt()
function! &lt;SID&gt;BufcloseCloseIt()
    let l:currentBufNum = bufnr(&quot;%&quot;)
    let l:alternateBufNum = bufnr(&quot;#&quot;)

    if buflisted(l:alternateBufNum)
        buffer #
    else
        bnext
    endif

    if bufnr(&quot;%&quot;) == l:currentBufNum
        new
    endif

    if buflisted(l:currentBufNum)
        execute(&quot;bdelete! &quot;.l:currentBufNum)
    endif
endfunction

function! CmdLine(str)
    call feedkeys(&quot;:&quot; . a:str)
endfunction

function! VisualSelection(direction, extra_filter) range
    let l:saved_reg = @&quot;
    execute &quot;normal! vgvy&quot;

    let l:pattern = escape(@&quot;, &quot;\\/.*'$^~[]&quot;)
    let l:pattern = substitute(l:pattern, &quot;\n$&quot;, &quot;&quot;, &quot;&quot;)

    if a:direction == 'gv'
        call CmdLine(&quot;Ack '&quot; . l:pattern . &quot;' &quot; )
    elseif a:direction == 'replace'
        call CmdLine(&quot;%s&quot; . '/'. l:pattern . '/')
    endif

    let @/ = l:pattern
    let @&quot; = l:saved_reg
endfunction
</code></pre>
<h2 id="使用现成的配置"><a class="header" href="#使用现成的配置">使用现成的配置</a></h2>
<p>利用了 <a href="https://github.com/amix/vimrc">amix/vimrc</a> 这个开源项目。</p>
<h2 id="参考-reference"><a class="header" href="#参考-reference">参考 Reference</a></h2>
<p><a href="http://c.biancheng.net/view/3024.html">Vim配置文件（.vimrc），Vim配置教程</a><br />
<a href="https://www.ruanyifeng.com/blog/2018/09/vimrc.html">Vim配置-王遗风</a></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Hexo 博客写作规范约定
date: 2018-12-11T15:51:48.000Z
updated: 2018-12-11T15:59:48.000Z
categories: Hexo
tags:</p>
<ul>
<li>Hexo</li>
<li>Blog
description: 在编写本 Hexo 博客时需要遵循的既定格式，方便规范和索引。
date updated: 2023-06-29 23:18</li>
</ul>
<hr />
<h1 id="hexo-博客写作规范约定"><a class="header" href="#hexo-博客写作规范约定">Hexo 博客写作规范约定</a></h1>
<p>于 2023/4/11 因为原域名 <a href="https://lskyl.xyz">lskyl.xyz</a> 到期了,故把博客域名和 oss 域名整体迁移到 <a href="https://whaleluo.top">whaleluo.top</a> 取鲸落之意.其中带 www 前缀 <a href="https://www.whaleluo.top">www.whaleluo.top</a> 经过 cloudflare 加速,用于某些不能直接访问到 github pages 的场景.</p>
<p>于 2023/2/10 更换了更快的博客主题 <strong>Card</strong> <a href="https://github.com/ChrAlpha/hexo-theme-cards">Card</a>.<a href="https://theme-cards.ichr.me/">主题文档</a></p>
<p>于 2022/12/11 重新拾起荒废已久的 Hexo 博客，就当是给自己的笔记、想法一个家叭。还是得规范一下博客写作的格式方便自己收纳的。</p>
<h2 id="头注"><a class="header" href="#头注">头注</a></h2>
<blockquote>
<p>reference: <a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/">Fluid 主题文档</a></p>
</blockquote>
<p>头注必须注明 <code>title</code> 、<code>data</code> 、<code>categories</code>(分类)、<code>tags</code>(标签)，其中分类和标签需要统一使用英文字符，<code>post_/</code> 目录下的 <code>markdown</code> 文件名需要使用英文，<code>hexo</code> 会根据文件名生成路径。</p>
<p>md 文件名遵从 <code>Key-word.md</code> 格式，单词之间用 <code>-</code> 分隔，首字母大写。</p>
<pre><code class="language-md">---
title: Hexo 博客写作规范约定
date: 2022-12-11 15:51:48
updated: 2022-12-11 15:59:48
categories: 
    - Hexo
tags: [Hexo, Blog]
description: Hexo 博客写作规范约定
thumbnail: http://....jpg
---
</code></pre>
<p>根据时间排序文章.</p>
<p>该参数可以设置置顶文章，sticky 数值越大，该文章越靠前，达到类似于置顶的效果，其他未设置的文章依然按默认排序。</p>
<pre><code class="language-text">sticky: 100
</code></pre>
<h2 id="blog-banner-img-生成"><a class="header" href="#blog-banner-img-生成">Blog Banner Img 生成</a></h2>
<p>使用 <a href="https://coverview.vercel.app/">CoverView</a> 设计博客 banner 图片，统一头图风格！</p>
<h2 id="markdown-语法"><a class="header" href="#markdown-语法">MarkDown 语法</a></h2>
<h2 id="插入图片并储存在-七牛云-oss-上"><a class="header" href="#插入图片并储存在-七牛云-oss-上">插入图片并储存在 七牛云 OSS 上</a></h2>
<h2 id="本地部署"><a class="header" href="#本地部署">本地部署</a></h2>
<pre><code class="language-shell">hexo generate --watch --deploy
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>title: Clash 小猫咪使用备忘
date: 2023-07-09 10:26:56
updated: 2023-07-09 10:26:56
categories: Proxy
tags: [Proxy, Clash]
description: 
thumbnail: 
banner_img:</h2>
<h1 id="clash-小猫咪使用备忘"><a class="header" href="#clash-小猫咪使用备忘">Clash 小猫咪使用备忘</a></h1>
<p>Clash is a rule-based tunnel in Go.</p>
<blockquote>
<p>Clash is a <strong>cross-platform</strong> <strong>rule-based</strong> proxy utility that runs on the network and application layer, supporting various proxy and <strong>anti-censorship protocols</strong> out-of-the-box.</p>
<p>It has been adopted widely by the Internet users in some countries and regions <strong>where the Internet is heavily censored or blocked.</strong></p>
</blockquote>
<p><strong>China Anti-censorship</strong>: <a href="https://geneva.cs.umd.edu/zh/posts/china-censors-esni/esni/">censorship.ai | 揭示和规避中国对加密SNI（ESNI）的封锁</a></p>
<blockquote>
<p>anti-censorship /ˌæn.tiˈsen.sə.ʃɪp/ adj. 反审查 <a href="https://dictionary.cambridge.org/zhs/%E8%AF%8D%E5%85%B8/%E8%8B%B1%E8%AF%AD/anti-censorship">cambridge dictionary</a></p>
</blockquote>
<h2 id="document"><a class="header" href="#document">Document</a></h2>
<p>GitHub: <a href="https://github.com/Dreamacro/clash">GitHub - Dreamacro/clash: A rule-based tunnel in Go.</a><br />
official document: <a href="https://dreamacro.github.io/clash/">What is Clash? | Clash</a><br />
<a href="https://docs.cfw.lbyczf.com/">Clash for Windows</a> config file: <a href="https://docs.cfw.lbyczf.com/contents/configfile.html">配置文件 | Clash for Windows</a></p>
<h2 id="use-client"><a class="header" href="#use-client">Use Client</a></h2>
<h2 id="use-raw-console-program"><a class="header" href="#use-raw-console-program">Use Raw Console Program</a></h2>
<p>The main configuration file is called <code>config.yaml</code>.<br />
Use command-line option <code>-d</code> to specify a configuration directory.<br />
use option <code>-f</code> to specify a configuration file</p>
<pre><code class="language-shell">clash -d . # current directory
clash -d /etc/clash

clash -f ./config.yaml
clash -f /etc/clash/config.yaml
</code></pre>
<h2 id="openwrt-openclash"><a class="header" href="#openwrt-openclash">OpenWRT OpenClash</a></h2>
<p><a href="https://github.com/vernesong/OpenClash/releases">Releases · vernesong/OpenClash</a><br />
<a href="https://github.com/vernesong/OpenClash/wiki">Home · vernesong/OpenClash Wiki · GitHub</a></p>
<p>内核文件下载<br />
<a href="https://github.com/vernesong/OpenClash/releases/tag/Clash">Release Clash · vernesong/OpenClash · GitHub</a></p>
<p>Dev 内核下载: <a href="https://github.com/vernesong/OpenClash/releases/tag/Clash">https://github.com/vernesong/OpenClash/releases/tag/Clash</a><br />
Tun 内核下载: <a href="https://github.com/vernesong/OpenClash/releases/tag/TUN-Premium">https://github.com/vernesong/OpenClash/releases/tag/TUN-Premium</a><br />
Tun 游戏内核: <a href="https://github.com/vernesong/OpenClash/releases/tag/TUN">https://github.com/vernesong/OpenClash/releases/tag/TUN</a></p>
<h3 id="install"><a class="header" href="#install">INSTALL</a></h3>
<pre><code class="language-shell">opkg list | grep &quot;clash&quot;

opkg remove luci-app-clash --autoremove
opkg remove luci-app-openclash --autoremove

#iptables
opkg update
opkg install coreutils-nohup bash iptables dnsmasq-full curl ca-certificates ipset ip-full iptables-mod-tproxy iptables-mod-extra libcap libcap-bin ruby ruby-yaml kmod-tun kmod-inet-diag unzip luci-compat luci luci-base

cd /tmp/
wget ...
opkg install ...ipk

wget https://github.com/vernesong/OpenClash/releases/download/Clash/clash-linux-386.tar.gz
tar -zxvf .
chmod 777 
</code></pre>
<blockquote>
<p>curl 故障：<br />
重新安装 libmbedtls<br />
<a href="https://github.com/vernesong/OpenClash/issues/3386">[Bug] 升级后更新功能错误 · Issue #3386 · vernesong/OpenClash · GitHub</a></p>
</blockquote>
<h2 id="config-file"><a class="header" href="#config-file">Config File</a></h2>
<h2 id="fake-ip"><a class="header" href="#fake-ip">Fake-IP</a></h2>
<p>ref: <a href="https://blog.skk.moe/post/what-happend-to-dns-in-proxy/">浅谈在代理环境中的 DNS 解析行为 | Sukka's Blog</a></p>
<p>在 Client 端设置 Socks5 代理的分流过程：<br />
<img src="http://oss.whaleluo.top//blog/img/202307091454148.png-picsmall" alt="在 Client 端设置 Socks5 代理的分流过程" /></p>
<p>但是使用 Route 透明代理、全局 tun/tun2socks 代理时，此时应用程序是 <strong>不会感知到代理客户端的存在</strong>，它们会正常的 <strong>发起 TCP 连接</strong>，并且由于 TCP/IP 协议，在拿到 DNS 解析结果之前，连接是不能建立的。</p>
<blockquote>
<p><strong>在应用发起 TCP 连接时，会先发出一个 DNS question（发一个 IP Packet），获取要连接的服务器的 IP 地址，然后直接向这个 IP 地址发起连接。</strong><br />
<strong>—— TCP/IP 协议</strong></p>
</blockquote>
<p>当 Proxy 运行在 tun 模式的透明代理时：<br />
<img src="http://oss.whaleluo.top//blog/img/202307091516885.png-picsmall" alt="当 Proxy 运行在 tun 模式的透明代理时" /></p>
<p>和应用程序直接将流量 <strong>封装成 SOCKS5</strong> 大有不同，在类似于透明代理的环境下浏览器和其它应用程序是正常地发起 TCP 连接。因此需要得到一个 DNS 解析结果，才能建立 TCP 连接；代理客户端也会需要通过这个 DNS 查询动作，才能找到之后的 TCP 连接的域名，进行分流。</p>
<p>浏览器、应用程序直接设置 SOCKS5 代理的话，<strong>可以不在代理客户端发起 DNS 解析请求</strong> 就能将流量发送给远端服务器；而在 <strong>透明代理模式</strong> 下，不论是否需要 IP 规则分流都需要<strong>先进行一次 DNS 解析</strong>才能建立连接。</p>
<p><strong>而且 DNS 解析的过程在 Proxy Server 上实现，远端服务器只能获取到解析出来的 IP，对于 CDN 优化不好。</strong></p>
<p>如果是支持 <strong>redir</strong> 的代理客户端，那么代理客户端就会直接将 <strong>域名</strong> 和 <strong>TCP content</strong> 封装成 某种协议 发给远端服务器，<strong>总之解析域名 DNS 和请求将在远端服务器进行，最大程度优化 CDN 速度</strong>。</p>
<p><a href="https://github.com/vernesong/OpenClash/issues/974">Fake-ip 和 Redir-host 两个模式，从速度上看，那个有优势？如果综合看那个更有优势？ · Issue #974 · vernesong/OpenClash · GitHub</a></p>
<p>Fake-IP 实现过程：<br />
<img src="http://oss.whaleluo.top/blog/img/202307091530969.png-picsmall" alt="Fake-IP 实现过程" /></p>
<p><strong>Fake-IP</strong> 能够省下 Client 向远端 DNS 请求 IP 的过程，就是代理客户端自己不先执行查询动作，丢一个 Fake IP 回去让浏览器、应用程序立刻建立 TCP 连接。</p>
<p><strong>Fake-IP</strong> 技术更加适合根据 <strong>IP 规则分流、Route 透明代理</strong> 的情景，如果应用程序直接将流量封装成 SOCKS5 可以不在 Client 发起 DNS 请求就能把浏览转发到 Proxy Server.而在透明代理模式下，不论是否需要 IP 规则分流都需要先进行一次 DNS 解析才能建立连接。</p>
<p><strong>Fake-IP</strong> 可以使域名解析在远端服务器上进行，能有效优化 DNS 解析速度。</p>
<blockquote>
<p>实际使用 Fake-IP 可能导致映射表丢失，导致浏览器或者本地缓存了错误的 DNS 解析结果比如 <code>192.168.16.7 --&gt; google.com</code> <strong>这时需要清除 DNS 缓存</strong>才行。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>title: C++ 初学者笔记
date: 2023-08-09 07:57:89
updated: 2023-08-09 07:57:89
categories: CPP
tags: [CPP, Guide]
description: 
thumbnail: 
banner_img:</h2>
<h1 id="c-初学者笔记"><a class="header" href="#c-初学者笔记">C++ 初学者笔记</a></h1>
<h2 id="c-environment-and-vscode"><a class="header" href="#c-environment-and-vscode">C++ environment and VSCode</a></h2>
<p><a href="https://code.visualstudio.com/docs/languages/cpp">C++ programming with Visual Studio Code</a></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Linux 运维笔记(持续更新)
date: 2022-03-20 16:37:48
updated: 2022-03-20 16:37:48
categories: Linux
tags: [Linux]
description:
thumbnail: http://oss.whaleluo.top/blog/img/Linux-Operation-Note-Banner.png-picsmall
banner_img: http://oss.whaleluo.top/blog/img/Linux-Operation-Note-Banner.png-picsmall</p>
<hr />
<h1 id="linux-operation-note"><a class="header" href="#linux-operation-note">Linux Operation Note</a></h1>
<p>​<img src="http://oss.whaleluo.top/blog/img/Linux-Operation-Note-Banner.png-picsmall" alt="Banner" />​</p>
<h2 id="硬盘操作"><a class="header" href="#硬盘操作">硬盘操作</a></h2>
<h3 id="格式化硬盘为-etx4-格式"><a class="header" href="#格式化硬盘为-etx4-格式">格式化硬盘为 ETX4 格式</a></h3>
<pre><code class="language-shell">mkfs.ext4 /dev/*** #将硬盘格式化成 ext4 格式
</code></pre>
<h3 id="设置硬盘开机挂载"><a class="header" href="#设置硬盘开机挂载">设置硬盘开机挂载</a></h3>
<pre><code class="language-shell"># 1.通过 lsblk 命令获取磁盘分区，并挂载磁盘到mnts目录。
lsblk

# 2.通过 blkid 命令获取存储设备UUID
blkid /dev/sda

# 3.编辑 /etc/fstab 文件，在fstab最后添加存储设备信息，实现开机自动加载
vim /etc/fstab
UUID=cdfc0924-7703-40f4-b6ab-8ef3f9adbf06 /mnt/disk ext4 defaults 0 0

# 4.通过mount -a命令重新加载 /etc/fstab 内容
mount -a

# 常用查询硬盘命令
fdisk -l
df -h
</code></pre>
<h3 id="备份与目录迁移"><a class="header" href="#备份与目录迁移">备份与目录迁移</a></h3>
<h4 id="使用-targz"><a class="header" href="#使用-targz">使用 tar.gz</a></h4>
<p>备份打包：</p>
<pre><code class="language-shell">tar -czvf backup.tar.gz /path/to/directory
</code></pre>
<p>这将使用 <code>tar</code> 命令将指定目录打包成一个压缩文件 <code>backup.tar.gz</code>。你可以将 <code>/path/to/directory</code> 替换为要备份的目录路径。使用 <code>-c</code> 参数表示创建新的备份，<code>-z</code> 参数表示使用 gzip 压缩，<code>-v</code> 参数表示显示备份过程中的详细信息。</p>
<p>还原备份：</p>
<pre><code class="language-shell">tar -xzvf backup.tar.gz -C /path/to/destination
</code></pre>
<p>这将使用 <code>tar</code> 命令解压缩备份文件 <code>backup.tar.gz</code> 并将文件还原到目标目录 <code>/path/to/destination</code>。使用 <code>-x</code> 参数表示解压缩，<code>-z</code> 参数表示使用 gzip 解压缩，<code>-v</code> 参数表示显示还原过程中的详细信息，<code>-C</code> 参数指定还原到的目标目录。</p>
<h2 id="进程相关"><a class="header" href="#进程相关">进程相关</a></h2>
<h3 id="开机自启动某个脚本"><a class="header" href="#开机自启动某个脚本">开机自启动某个脚本</a></h3>
<pre><code class="language-shell"># 编辑 systemctl 文件
vim /etc/systemd/system/ttnode.service

# 文件内容
[Unit]
Description=Python Task Service
After=network.target

[Service]
Type=simple
User=root
Group=root
ExecStart=/usr/node/ttnode -p /mnt/disk/
Restart=always
RestartSec=2
PrivateTmp=true

[Install]
WantedBy=multi-user.target

# 重载
systemctl daemon-reload
# 启动
systemctl start ttnode
# 开机自启
systemctl enable ttnode
</code></pre>
<h2 id="网络相关"><a class="header" href="#网络相关">网络相关</a></h2>
<h3 id="openvpn"><a class="header" href="#openvpn">OpenVPN</a></h3>
<blockquote>
<p>参考：<a href="https://serverfault.com/questions/785767/with-openvpn-how-can-i-only-let-lan-go-through-the-vpn">窗口 - 使用OpenVPN，我如何只能让局域网通过VPN？- 服务器故障 (serverfault.com)</a> <strong>重要</strong></p>
<p><a href="https://www.cnblogs.com/lsgxeva/p/11378768.html">ROUTE: route addition failed - lsgxeva - 博客园 (cnblogs.com)</a></p>
<p><a href="https://superuser.com/questions/1608345/how-to-route-only-subnet-in-openvpn-and-not-internet-traffic">networking - How to route only subnet in OpenVPN and not internet traffic - Super User</a></p>
</blockquote>
<p>安装脚本:<a href="https://github.com/Nyr/openvpn-install">Nyr/openvpn-install</a></p>
<p>服务端：<code>server.conf</code></p>
<pre><code class="language-ini">server 192.168.255.0 255.255.255.0
verb 3
key /etc/openvpn/pki/private/0.0.0.0.key
ca /etc/openvpn/pki/ca.crt
cert /etc/openvpn/pki/issued/0.0.0.0.crt
dh /etc/openvpn/pki/dh.pem
tls-auth /etc/openvpn/pki/ta.key
key-direction 0
keepalive 10 60
persist-key
persist-tun

proto tcp
# Rely on Docker to do port mapping, internally always 1194
port 1194
dev tun0
status /tmp/openvpn-status.log

user nobody
group nogroup
comp-lzo no

### Route Configurations Below
route 192.168.254.0 225.225.225.0

### Push Configurations Below
</code></pre>
<p>客户端：<code>client.conf</code></p>
<pre><code class="language-ini">client
nobind
dev tun
remote-cert-tls server
remote tx.cyidz.xyz 11194 tcp

&lt;key&gt;
-----BEGIN PRIVATE KEY-----
....
-----END CERTIFICATE-----
&lt;/ca&gt;
key-direction 1
&lt;tls-auth&gt;
#
# 2048 bit OpenVPN static key
#
-----BEGIN OpenVPN Static key V1-----
....
-----END OpenVPN Static key V1-----
&lt;/tls-auth&gt;

# redirect-gateway def1  # 注释掉
dhcp-option DNS 114.114.114.114 # 自定义DNS
route 192.168.1.0 255.255.255.0  # 添加路由
route 192.168.0.0 255.255.255.0
</code></pre>
<h3 id="frp"><a class="header" href="#frp">FRP</a></h3>
<h4 id="服务端配置"><a class="header" href="#服务端配置">服务端配置</a></h4>
<p>frps.ini</p>
<pre><code class="language-ini">[common]
bind_addr = 0.0.0.0
bind_port = 57700
bind_udp_port= 57711

token = lovehyy

dashboard_port = 57710
dashboard_user = admin
dashboard_pwd = lovehyy

max_pool_count = 9999
max_ports_per_client = 0

tls_only = true
allow_ports = 57700-57800
</code></pre>
<h4 id="客户端"><a class="header" href="#客户端">客户端</a></h4>
<p>frpc.ini</p>
<pre><code class="language-ini">[common]
server_addr = vps.lskyl.xyz
server_port = 57700
token = lovehyy
user = dlgz-nas
login_fail_exit = false
protocol = tcp
tcp_mux = true
dns_server = 223.5.5.5
tls_enable = true

[ssh]
type = tcp
local_ip = 127.0.0.1
local_port = 22
remote_port = 57722
use_encryption = false
use_compression = true
</code></pre>
<h2 id="shell-相关"><a class="header" href="#shell-相关">Shell 相关</a></h2>
<h3 id="ssh-链接超时设置"><a class="header" href="#ssh-链接超时设置">SSH 链接超时设置</a></h3>
<p>修改 server 端的 <code>/etc/ssh/sshd_config</code></p>
<pre><code class="language-shell"># server每隔60秒发送一次请求给client，然后client响应，从而保持连接
ClientAliveInterval 60 

# server发出请求后，客户端没有响应得次数达到3，就自动断开连接，正常情况下，client不会不响应
ClientAliveCountMax 3 
</code></pre>
<h3 id="ssh-配置密钥登陆"><a class="header" href="#ssh-配置密钥登陆">SSH 配置密钥登陆</a></h3>
<p>客户端运行</p>
<pre><code class="language-shell"># WAY1
ssh-copy-id username@remote_host

# WAY2
mkdir -p ~/.ssh
cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys

# WAY3
scp ./file root@192.168.1.1:/path_on_host/
</code></pre>
<p>编辑 /etc/ssh/sshd_config 文件，进行如下设置：</p>
<pre><code class="language-shell">RSAAuthentication yes
PubkeyAuthentication yes
</code></pre>
<p>重启 ssh 服务：</p>
<pre><code class="language-shell">service sshd restart
</code></pre>
<h3 id="zsh-终端美化"><a class="header" href="#zsh-终端美化">ZSH 终端美化</a></h3>
<p>安装</p>
<pre><code class="language-shell">cd ~
sudo apt-get install git zsh wget
sh -c &quot;$(wget -O- https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)&quot;

# 从马云安装
export REMOTE=https://gitee.com/mirrors/oh-my-zsh.git 
sh -c &quot;$(curl -fsSL https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)&quot;

# 原Github安装
sh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;

# 解决 OpenWRT git 异常
opkg update  
opkg remove git  
opkg install git-http  
opkg install ca-bundle

# 解决收手机字体问题
sudo apt-get install fonts-powerline

# 安装插件
cd ~/.oh-my-zsh/plugins
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git
git clone https://github.com/zsh-users/zsh-autosuggestions.git

# 编辑配置
vim ~/.zshrc
ZSH_THEME=&quot;agnoster&quot; or &quot;ys&quot;
plugins=(git zsh-syntax-highlighting zsh-autosuggestions sudo)

# 刷新
source ~/.zshrc

# 设置 ZSH 为默认 shell
cat /etc/shells
chsh -s /bin/zsh

# OpenWRT 设置 ZSH 为默认 shell
which zsh &amp;&amp; sed -i -- 's:/bin/ash:'`which zsh`':g' /etc/passwd
</code></pre>
<h2 id="docker-1"><a class="header" href="#docker-1">Docker</a></h2>
<h3 id="安装"><a class="header" href="#安装">安装</a></h3>
<p>国内加速: <a href="https://get.daocloud.io/">https://get.daocloud.io/</a></p>
<p>官方命令安装：</p>
<pre><code class="language-shell">curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh
</code></pre>
<h3 id="useful-command"><a class="header" href="#useful-command">Useful Command</a></h3>
<pre><code class="language-shell"># 强制停止并删除镜像
docker rm -f 名称
# entry shell and rm
docker run -it --rm --name tgbot /bin/sh

# 复制文件
docker cp ./TGBot.session tgbot:/wkdir/

docker run -it --rm --name tg_forwardMsgBot -v /wfwork/tgbot_base/:/wkdir/ tgbot_base /bin/sh

docker run -d --name tg_forwardMsgBot -v /wfwork/tgbot_base/:/wkdir/ tgbot_base python3 main.py
</code></pre>
<h3 id="image-各种镜像"><a class="header" href="#image-各种镜像">Image 各种镜像</a></h3>
<h4 id="portainer-管理-ui"><a class="header" href="#portainer-管理-ui">Portainer 管理 UI</a></h4>
<pre><code class="language-shell">docker run -d -p 9000:9000 \
--name portainer \
--restart=always \
-v /var/run/docker.sock:/var/run/docker.sock \
portainer/portainer:latest
</code></pre>
<h4 id="frps-服务端"><a class="header" href="#frps-服务端">Frps 服务端</a></h4>
<pre><code class="language-shell">docker run --restart=always --network host -d \
-v /etc/frp/frps.ini:/etc/frp/frps.ini \
--name frps snowdreamtech/frps
</code></pre>
<p>frps.ini</p>
<pre><code class="language-ini">[common]
bind_addr = 0.0.0.0
bind_port = 37700
bind_udp_port = 37711

token = lovecyx

dashboard_port = 37710
dashboard_user = admin
dashboard_pwd = lovehyy

max_pool_count = 9999
max_ports_per_client = 0

tls_only = true
allow_ports = 30000-50000
</code></pre>
<h4 id="frpc-客户端"><a class="header" href="#frpc-客户端">Frpc 客户端</a></h4>
<p><a href="https://www.itcoder.tech/posts/docker-frp/">docker frpc 中文文档</a></p>
<pre><code class="language-shell">docker run --network host -d \
-v /root/frpc/frpc.ini:/etc/frp/frpc.ini \
--name frpc \
--restart=always \
snowdreamtech/frpc
</code></pre>
<h4 id="到服务器的网速测试"><a class="header" href="#到服务器的网速测试">到服务器的网速测试</a></h4>
<p><a href="https://hub.docker.com/r/ilemonrain/html5-speedtest/">Docker</a></p>
<pre><code class="language-shell">sudo docker run --restart=always \
--name openspeedtest \
-d -p 6688:80 ilemonrain/html5-speedtest
</code></pre>
<h4 id="filebrowser-文件管理"><a class="header" href="#filebrowser-文件管理">FileBrowser 文件管理</a></h4>
<p><a href="https://filebrowser.org/installation">https://filebrowser.org/installation</a></p>
<pre><code class="language-sh">docker run \
    -v /mnt/:/srv \
    -v /root/filebrowser.db:/database.db \
    -v /path/.filebrowser.json:/.filebrowser.json \
    -u $(id -u):$(id -g) \
    -p 8080:80 \
    filebrowser/filebrowser
</code></pre>
<h4 id="nfs-文件共享"><a class="header" href="#nfs-文件共享">NFS 文件共享</a></h4>
<blockquote>
<p><strong>NFS</strong>，是 <strong>Network File System</strong> 的简写，即网络文件系统。网络文件系统是 FreeBSD 支持的文件系统中的一种，也被称为 NFS. NFS 允许一个系统在网络上与他人共享目录和文件。 通过使用 NFS，用户和程序可以像访问本地文件一样访问远端系统上的文件。</p>
</blockquote>
<p>docker hub：<a href="https://hub.docker.com/r/erichough/nfs-server/">https://hub.docker.com/r/erichough/nfs-server/</a></p>
<pre><code class="language-shell">docker pull erichough/nfs-server
docker run                                            \
  -v /root/:/file/  \
  -e NFS_EXPORT_0='/file *(rw,no_subtree_check,async)'        \
  -e NFS_SERVER_THREAD_COUNT=4 \
  --privileged                               \
  --network host \
  --name=nfs-server \
  erichough/nfs-server
</code></pre>
<blockquote>
<p>在 UNIX 和类 UNIX 系统中，/etc/exports 是一个配置文件，用于指定可以通过 NFS 共享的文件系统和相关参数。该文件定义了服务器上可供客户端挂载的共享目录以及访问权限。以下是/etc/exports 文件的一般格式和作用：</p>
<p>每一行代表一个共享目录的定义，具有以下基本格式：</p>
<pre><code>&lt;目录路径&gt; &lt;允许访问的客户端&gt;(选项)
</code></pre>
<ul>
<li>
<p>​<code>&lt;目录路径&gt;</code>​：指定要共享的目录的路径。可以是绝对路径或相对路径。</p>
</li>
<li>
<p>​<code>&lt;允许访问的客户端&gt;</code>​：指定被允许访问该共享目录的客户端。可以使用 IP 地址、域名或子网掩码来指定。也可以使用通配符进行模式匹配，如 <code>*</code>​表示允许所有客户端访问。</p>
</li>
<li>
<p>​<code>(选项)</code>​：可选项，用于指定共享选项。常用的选项包括：</p>
<ul>
<li>​<code>rw</code>​：允许读写访问权限。</li>
<li>​<code>ro</code>​：只允许读取访问权限。</li>
<li>​<code>noaccess</code>​：禁止访问该共享目录。</li>
<li>​<code>root_squash</code>​：将客户端的 root 用户映射为匿名用户（通常是 nfsnobody），以增加安全性。</li>
<li>​<code>all_squash</code>​：将所有用户映射为匿名用户，用于增加安全性。</li>
<li>​<code>async</code>​：异步写入，提高性能但降低可靠性。</li>
<li>​<code>sync</code>​：同步写入，确保数据的可靠性但性能较低。</li>
<li>​<code>insecure</code>​：允许不安全的访问请求，如非特权端口。</li>
<li>​<code>no_subtree_check</code>​：不进行子树检查。</li>
</ul>
</li>
</ul>
<p>/etc/exports 文件的作用是定义 NFS 共享的配置信息，以便服务器将指定的目录和选项提供给客户端进行挂载和访问。每当修改 /etc/exports 文件后，需要使用 <code>exportfs</code>​命令重新加载 NFS 服务器的配置，以使更改生效。</p>
</blockquote>
<p>仅通过 NFSv4 连接，则只需使用 TCP 端口 <code>2049</code>​</p>
<p>performance-tuning：<a href="https://github.com/ehough/docker-nfs-server/blob/develop/doc/advanced/performance-tuning.md">https://github.com/ehough/docker-nfs-server/blob/develop/doc/advanced/performance-tuning.md</a></p>
<p>Set the **<code>NFS_SERVER_THREAD_COUNT</code>**​ environment variable to control how many server threads <code>rpc.nfsd</code>​ will use. A good minimum is one thread per CPU core, but 4 or 8 threads per core is probably better. The default is one thread per CPU core.</p>
<p>Running the container with <code>--network host</code>​ <em>might</em> improve network performance by 10% - 20% on a heavily-loaded server [<a href="https://jtway.co/docker-network-performance-b95bce32b4b9">1</a>,<a href="https://www.percona.com/blog/2016/08/03/testing-docker-multi-host-network-performance/">2</a>], <strong>though this hasn't been tested.</strong></p>
<p>查看 CPU 内核数：<code>cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq</code>​</p>
<p>问题：the problem is in the docker-machine. If you want to use nfs mounts you need to run modprobe nfs in the machine itself, not in container. Container uses kernel of the machine. Same with modprobe nfs and nfs server.问题出在码头工人机器上。如果你想使用 nfs 挂载，你需要在机器本身而不是容器中运行 modprobe nfs。容器使用机器的内核。与 modprobe nfs 和 nfs 服务器相同。</p>
<p>在 Windows 上配置 NFS 客户端： <a href="https://cloud.tencent.com/developer/article/1840455">https://cloud.tencent.com/developer/article/1840455</a></p>
<h4 id="ddns-go"><a class="header" href="#ddns-go">DDNS-GO</a></h4>
<p>基于 Golang 语言开发的 DDNS 程序。<a href="https://github.com/jeessy2/ddns-go">GitHub - jeessy2/ddns-go: 简单好用的DDNS。自动更新域名解析到公网IP(支持阿里云、腾讯云、Dnspod、Cloudflare、Callback、华为云、百度云、Porkbun、GoDaddy、Google Domain)</a></p>
<pre><code class="language-shell">docker run -d --name ddns-go --restart=always --net=host -v /root/ddns-go:/root jeessy/ddns-go
</code></pre>
<h2 id="nginx"><a class="header" href="#nginx">Nginx</a></h2>
<p>docker running</p>
<pre><code class="language-sh">docker run -d -p 8080:8080 \
--name nginx-proxy \
--restart=always \
-v /root/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \
-v /root/nginx/www:/usr/share/nginx/html \
-v /root/nginx/cert:/usr/local/nginx/cert \
nginx:latest
</code></pre>
<h3 id="调优-performance-tuning"><a class="header" href="#调优-performance-tuning">调优 Performance Tuning</a></h3>
<p>在 server 字段下添加</p>
<pre><code class="language-nginx">client_max_body_size 5G;
client_header_timeout 1m;
client_body_timeout 1m;
proxy_connect_timeout 60s;
proxy_read_timeout 1m;
proxy_send_timeout 1m;      
</code></pre>
<h3 id="反向代理"><a class="header" href="#反向代理">反向代理</a></h3>
<pre><code class="language-nginx">user  nginx;
worker_processes  auto;

error_log  /var/log/nginx/error.log notice;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    gzip on;

    # include /etc/nginx/conf.d/*.conf;
        server {
        listen 80;
        server_name _;

        # location / {
        #     root   /usr/share/nginx/html;
        #     index  index.html index.htm;
        # }

        location / {
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header Host $http_host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header Range $http_range;
            proxy_set_header If-Range $http_if_range;
            proxy_redirect off;
            proxy_pass http://172.17.0.1:5244/;
            # the max size of file to upload
            client_max_body_size 20000m;
        }
    }

}
</code></pre>
<p>反向代理 ws. <a href="http://nginx.org/en/docs/http/websocket.html">nginx docs</a></p>
<pre><code class="language-nginx">location /chat/ {
    proxy_pass http://backend;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection &quot;upgrade&quot;;
}
</code></pre>
<p>解决 WS 反向代理超时问题, 在 server 字段下添加</p>
<pre><code class="language-nginx">proxy_connect_timeout 60s;
proxy_read_timeout 60m;
proxy_send_timeout 60m; 
</code></pre>
<p>自动添加 <code>/</code>​ 在 server 字段下添加:</p>
<pre><code class="language-nginx">server_name_in_redirect off;
</code></pre>
<p><strong>完整支持 WS 的反向代理模板：</strong></p>
<pre><code class="language-nginx">location /note/ {
     proxy_pass http://192.168.8.1:6806/;
     proxy_set_header X-Real-IP $remote_addr;
     proxy_set_header x-wiz-real-ip $remote_addr;
     proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
     proxy_set_header X-Forwarded-Proto $scheme;
     proxy_set_header X-NginX-Proxy true;

     proxy_http_version 1.1;
     proxy_set_header Upgrade $http_upgrade;
     proxy_set_header Connection &quot;upgrade&quot;;
     proxy_set_header Connection &quot;keep-alive&quot;;

     proxy_set_header Host $http_host;
     proxy_ssl_session_reuse off;
     proxy_cache_bypass $http_upgrade;
     proxy_redirect off;
 }
</code></pre>
<h3 id="添加证书"><a class="header" href="#添加证书">添加证书</a></h3>
<h4 id="使用-acmesh-申请证书"><a class="header" href="#使用-acmesh-申请证书">使用 acme.sh 申请证书</a></h4>
<pre><code class="language-shell"># 配置 Docker 为 daemon
docker run -d \
-v /root/acme/:/acme.sh \
-e &quot;CF_Key=e1c57d011aae471eaca549607a2f74154cbe5&quot; \
-e &quot;CF_Email=whalefall9420@outlook.com&quot; \
--restart=always \
--name=acme.sh \
--net=host \
neilpang/acme.sh daemon

# 进入 docker shell
docker exec -it acme.sh sh

# 设置自动更新
docker exec acme.sh --upgrade --auto-upgrade 

# 使用 letsencrypt 签发证书
docker exec acme.sh --set-default-ca --server letsencrypt --issue --dns dns_cf -d *.whaleluo.top -d www.whaleluo.top

# 导出 nginx 使用的证书
docker exec acme.sh --install-cert -d whaleluo.top --key-file /acme.sh/private.key --fullchain-file /acme.sh/cert.pem

# 导出 uhttpd 使用的证书
acme.sh --install-cert -d *.whaleluo.top \
--cert-file      /acme.sh/uhttpd.crt  \
--key-file       /acme.sh/uhttpd.key  \

# 容器会自动更新 crantab 每天0点检查证书 `crontab -l`
/acme.sh # acme.sh --cron --home &quot;/root/.acme.sh&quot; --config-home &quot;/acme.sh&quot;
[Wed Jul 19 02:31:31 UTC 2023] ===Starting cron===
[Wed Jul 19 02:31:31 UTC 2023] Already uptodate!
[Wed Jul 19 02:31:31 UTC 2023] Upgrade success!
[Wed Jul 19 02:31:31 UTC 2023] Auto upgraded to: 3.0.6
[Wed Jul 19 02:31:32 UTC 2023] Renew: '*.whaleluo.top'
[Wed Jul 19 02:31:32 UTC 2023] Renew to Le_API=https://acme-v02.api.letsencrypt.org/directory
[Wed Jul 19 02:31:32 UTC 2023] Skip, Next renewal time is: 2023-09-14T17:18:24Z
[Wed Jul 19 02:31:32 UTC 2023] Add '--force' to force to renew.
[Wed Jul 19 02:31:32 UTC 2023] Skipped *.whaleluo.top_ecc
[Wed Jul 19 02:31:32 UTC 2023] ===End cron===

</code></pre>
<h4 id="nginx-配置"><a class="header" href="#nginx-配置">Nginx 配置</a></h4>
<pre><code class="language-nginx">user  nginx;
worker_processes  auto;
error_log  /var/log/nginx/error.log notice;
pid        /var/run/nginx.pid;
events {
    worker_connections  1024;
}
http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

    access_log  /var/log/nginx/access.log  main;
    sendfile        on;
    keepalive_timeout  65;
    gzip on;

    server {
        listen 80 ssl http2;
        server_name _;

        ssl                      on;
        ssl_certificate     /usr/local/nginx/cert/cert.pem;
        ssl_certificate_key  /usr/local/nginx/cert/private.key;
      
        ssl_session_timeout  5m;
        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
        ssl_prefer_server_ciphers on;

        error_page 497 https://$host:8080$uris;
      
        if ($scheme = http) {
            return 301 https://$host$request_uri;
        }


        location / {
                root   /usr/share/nginx/html;
                index  index.html index.htm;
        }

    }
}
</code></pre>
<h3 id="跨域"><a class="header" href="#跨域">跨域</a></h3>
<pre><code class="language-nginx">add_header Access-Control-Allow-Origin *;
add_header Access-Control-Allow-Methods GET,POST,OPTIONS;
add_header Access-Control-Allow-Headers Content-Type,Authorization;
</code></pre>
<h3 id="自用完整的-nginxconf"><a class="header" href="#自用完整的-nginxconf">自用完整的 nginx.conf</a></h3>
<p>nginx file format： <a href="https://nginxbeautifier.github.io/" title="在线整理 nginx 配置文件">https://nginxbeautifier.github.io/</a></p>
<p>github repo: <a href="https://github.com/nginxbeautifier/nginxbeautifier.github.io">https://github.com/nginxbeautifier/nginxbeautifier.github.io</a></p>
<pre><code class="language-nginx">user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log notice;
pid /var/run/nginx.pid;
events {

	worker_connections 1024;
}
http {

	include /etc/nginx/mime.types;
	default_type application/octet-stream;

	log_format main '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
	'$status $body_bytes_sent &quot;$http_referer&quot; '
	'&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

	access_log /var/log/nginx/access.log main;
	sendfile on;
	keepalive_timeout 65;
	gzip on;

	server {

		listen 8080 ssl http2;
		server_name _;

		# ssl off;
		ssl_certificate /usr/local/nginx/cert/cert.pem;
		ssl_certificate_key /usr/local/nginx/cert/private.key;

		ssl_session_timeout 5m;
		ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
		ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
		ssl_prefer_server_ciphers on;

		error_page 497 https://$host:8080$request_uri;

		client_max_body_size 5G;
		client_header_timeout 1m;
		client_body_timeout 1m;
		proxy_connect_timeout 60s;
		proxy_read_timeout 60m;
		proxy_send_timeout 60m;


		location / {

			alias /usr/share/nginx/html;
			index index.html;
		}


		location /sdr/ {

			proxy_pass http://192.168.8.1:8073/;
			proxy_set_header X-Real-IP $remote_addr;
			proxy_set_header x-wiz-real-ip $remote_addr;
			proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
			proxy_set_header X-Forwarded-Proto $scheme;
			proxy_set_header X-NginX-Proxy true;

			proxy_http_version 1.1;
			proxy_set_header Upgrade $http_upgrade;
			proxy_set_header Connection &quot;upgrade&quot;;
			proxy_set_header Connection &quot;keep-alive&quot;;

			proxy_set_header Host $http_host;
			proxy_ssl_session_reuse off;
			proxy_cache_bypass $http_upgrade;
			proxy_redirect off;
		}

		location /wss/ {

			proxy_pass http://192.168.8.1:10000/wss/;
			proxy_set_header X-Real-IP $remote_addr;
			proxy_set_header x-wiz-real-ip $remote_addr;
			proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
			proxy_set_header X-Forwarded-Proto $scheme;
			proxy_set_header X-NginX-Proxy true;

			proxy_http_version 1.1;
			proxy_set_header Upgrade $http_upgrade;
			proxy_set_header Connection &quot;upgrade&quot;;
			proxy_set_header Connection &quot;keep-alive&quot;;

			proxy_set_header Host $http_host;
			proxy_ssl_session_reuse off;
			proxy_cache_bypass $http_upgrade;
			proxy_redirect off;
		}

		location /dav/ {

			proxy_pass http://192.168.8.1:5244/dav/;
			proxy_set_header X-Real-IP $remote_addr;
			proxy_set_header x-wiz-real-ip $remote_addr;
			proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
			proxy_set_header X-Forwarded-Proto $scheme;
			proxy_set_header X-NginX-Proxy true;

			proxy_http_version 1.1;
			proxy_set_header Upgrade $http_upgrade;
			proxy_set_header Connection &quot;upgrade&quot;;
			proxy_set_header Connection &quot;keep-alive&quot;;

			proxy_set_header Host $http_host;
			proxy_ssl_session_reuse off;
			proxy_cache_bypass $http_upgrade;
			proxy_redirect off;
		}

		location /test/ {

			proxy_pass http://192.168.8.1:3300/;
			proxy_set_header X-Real-IP $remote_addr;
			proxy_set_header x-wiz-real-ip $remote_addr;
			proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
			proxy_set_header X-Forwarded-Proto $scheme;
			proxy_set_header X-NginX-Proxy true;

			proxy_http_version 1.1;
			proxy_set_header Upgrade $http_upgrade;
			proxy_set_header Connection &quot;upgrade&quot;;
			proxy_set_header Connection &quot;keep-alive&quot;;

			proxy_set_header Host $http_host;
			proxy_ssl_session_reuse off;
			proxy_cache_bypass $http_upgrade;
			proxy_redirect off;
		}
	}
}
</code></pre>
<h2 id="openwrt"><a class="header" href="#openwrt">OpenWRT</a></h2>
<p>x86 官方源</p>
<pre><code class="language-shell">src/gz openwrt_core http://downloads.openwrt.org/releases/21.02.0/targets/x86/64/packages  
src/gz openwrt_base https://downloads.openwrt.org/snapshots/packages/x86_64/base  
src/gz openwrt_luci    https://downloads.openwrt.org/snapshots/packages/x86_64/luci  
src/gz openwrt_packages https://downloads.openwrt.org/snapshots/packages/x86_64/packages  
src/gz openwrt_routing https://mirrors.cloud.tencent.com/lede/snapshots/packages/x86_64/routing  
src/gz openwrt_telephony https://mirrors.cloud.tencent.com/lede/snapshots/packages/x86_64/telephony
</code></pre>
<h2 id="引用-reference"><a class="header" href="#引用-reference">引用 Reference</a></h2>
<blockquote>
<p>感谢以下博客的作者和教程网站，如有侵权请及时联系博主删除。</p>
</blockquote>
<ol>
<li>Golang 和 Linux 学习笔记合集 <a href="https://www.huweihuang.com/">https://www.huweihuang.com/</a></li>
</ol>
<p>‍</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Kali 平台渗透教程
date: 2021-06-18 22:16:49
updated: 2021-06-18 22:16:49
categories: Linux
tags: [Linux, Kali]
description:
thumbnail: http://oss.whaleluo.top/blog/old/20210619154844.jpg
banner_img: http://oss.whaleluo.top/blog/old/20210619154844.jpg</p>
<hr />
<p><img src="http://oss.whaleluo.top/blog/old/20210619154844.jpg-picsmall" alt="Kali" /></p>
<h1 id="kali-linux-漏洞审计-批量扫描-弱密码撞库-教程"><a class="header" href="#kali-linux-漏洞审计-批量扫描-弱密码撞库-教程">Kali Linux 漏洞审计 批量扫描 弱密码撞库 教程</a></h1>
<h1 id="nmap-端口扫描"><a class="header" href="#nmap-端口扫描">Nmap 端口扫描</a></h1>
<h2 id="安装-1"><a class="header" href="#安装-1">安装</a></h2>
<p><code>sudo apt-get install nmap</code></p>
<h2 id="语法"><a class="header" href="#语法">语法</a></h2>
<p><code>nmap [扫描类型] [扫描参数] [hosts 地址与范围]</code></p>
<h2 id="扫描类型"><a class="header" href="#扫描类型">扫描类型</a></h2>
<ul>
<li>-sT TCP connect() 扫描，这是最基本的 TCP 扫描方式。这种扫描很容易被检测到，在目标主机的日志中会记录大批的连接请求以及错误信息。</li>
<li>-sS TCP 同步扫描 (TCP SYN)，因为不必全部打开一个 TCP 连接，所以这项技术通常称为半开扫描 (half-open)。这项技术最大的好处是，很少有系统能够把这记入系统日志。不过，你需要 root 权限来定制 SYN 数据包。</li>
<li>-sF,-sX,-sN 秘密 FIN 数据包扫描、圣诞树 (Xmas Tree)、空 (Null) 扫描模式。这些扫描方式的理论依据是：关闭的端口需要对你的探测包回应 RST 包，而打开的端口必需忽略有问题的包（参考 RFC 793 第 64 页）。</li>
<li>-sP ping 扫描，用 ping 方式检查网络上哪些主机正在运行。当主机阻塞 ICMP echo 请求包是 ping 扫描是无效的。nmap 在任何情况下都会进行 ping 扫描，只有目标主机处于运行状态，才会进行后续的扫描。</li>
<li>-sU UDP 的数据包进行扫描，如果你想知道在某台主机上提供哪些 UDP（用户数据报协议，RFC768) 服务，可以使用此选项。</li>
<li>-sA ACK 扫描，这项高级的扫描方法通常可以用来穿过防火墙。 -sW 滑动窗口扫描，非常类似于 ACK 的扫描。</li>
<li>-sR RPC 扫描，和其它不同的端口扫描方法结合使用。 -b FTP 反弹攻击 (bounce attack)，连接到防火墙后面的一台 FTP 服务器做代理，接着进行端口扫描。</li>
</ul>
<h2 id="扫描参数"><a class="header" href="#扫描参数">扫描参数</a></h2>
<ul>
<li>-P0 在扫描之前，不 ping 主机。</li>
<li>-PT 扫描之前，使用 TCP ping 确定哪些主机正在运行。</li>
<li>-PS 对于 root 用户，这个选项让 nmap 使用 SYN 包而不是 ACK 包来对目标主机进行扫描。</li>
<li>-PI 设置这个选项，让 nmap 使用真正的 ping(ICMP echo 请求）来扫描目标主机是否正在运行。</li>
<li>-PB 这是默认的 ping 扫描选项。它使用 ACK(-PT) 和 ICMP(-PI) 两种扫描类型并行扫描。如果防火墙能够过滤其中一种包，使用这种方法，你就能够穿过防火墙。</li>
<li>-O 这个选项激活对 TCP/IP 指纹特征 (fingerprinting) 的扫描，获得远程主机的标志，也就是操作系统类型。</li>
<li>-I 打开 nmap 的反向标志扫描功能。</li>
<li>-f 使用碎片 IP 数据包发送 SYN、FIN、XMAS、NULL。包增加包过滤、入侵检测系统的难度，使其无法知道你的企图。</li>
<li>-v 冗余模式。强烈推荐使用这个选项，它会给出扫描过程中的详细信息。</li>
<li>-S <IP> 在一些情况下，nmap 可能无法确定你的源地址 (nmap 会告诉你）。在这种情况使用这个选项给出你的 IP 地址。</li>
<li>-g port 设置扫描的源端口。一些天真的防火墙和包过滤器的规则集允许源端口为 DNS(53) 或者 FTP-DATA(20) 的包通过和实现连接。显然，如果攻击者把源端口修改为 20 或者 53，就可以摧毁防火墙的防护。</li>
<li>-oN 把扫描结果重定向到一个可读的文件 logfilename 中。</li>
<li>-oS 扫描结果输出到标准输出。</li>
<li>--host_timeout 设置扫描一台主机的时间，以毫秒为单位。默认的情况下，没有超时限制。</li>
<li>--max_rtt_timeout 设置对每次探测的等待时间，以毫秒为单位。如果超过这个时间限制就重传或者超时。默认值是大约 9000 毫秒。</li>
<li>--min_rtt_timeout 设置 nmap 对每次探测至少等待你指定的时间，以毫秒为单位。</li>
<li>-M count 置进行 TCP connect() 扫描时，最多使用多少个套接字进行并行的扫描。</li>
</ul>
<h2 id="端口状态"><a class="header" href="#端口状态">端口状态</a></h2>
<ul>
<li>Open（开放的）意味着目标机器上的应用程序正在该端口监听连接 / 报文。</li>
<li>filtered（被过滤的） 意味着防火墙，过滤器或者其它网络障碍阻止了该端口被访问，Nmap 无法得知 它是 open（开放的） 还是 closed（关闭的）。</li>
<li>closed（关闭的） 端口没有应用程序在它上面监听，但是他们随时可能开放。</li>
<li>unfiltered（未被过滤的）当端口对 Nmap 的探测做出响应，但是 Nmap 无法确定它们是关闭还是开放时 open filtered 开放或者被过滤的 closed filtered 关闭或者被过滤的</li>
</ul>
<h2 id="扫描实例"><a class="header" href="#扫描实例">扫描实例</a></h2>
<blockquote>
<p>阿里云服务器网段大全：<a href="https://blog.csdn.net/nxuu01/article/details/102779652">CSDN博客</a> <a href="https://blog.csdn.net/eagle_min/article/details/82260622">CSDN-eagle_min大佬</a></p>
<p>腾讯云 ip 段：<a href="https://blog.csdn.net/eagle_min/article/details/82260611">CSDN-eagle_min大佬</a></p>
</blockquote>
<ol>
<li>用 nmap 扫描该网段开放的 888 端口保存在 pma.txt 文件 格式要求：ip:port<br />
<code>nmap -vv -n --open -p 888 网段 | awk -F'[ /]' '/Discovered open port/{print $NF&quot;:&quot;$4}' &gt;&gt; pma.txt</code></li>
</ol>
<h1 id="hydra-弱密码破解"><a class="header" href="#hydra-弱密码破解">Hydra 弱密码破解</a></h1>
<h2 id="安装-2"><a class="header" href="#安装-2">安装</a></h2>
<p><code>sudo apt-get install hydra</code></p>
<blockquote>
<p>Hydra 是一款<strong>非常强大的暴力破解工具</strong>，它是由著名的黑客组织 THC 开发的一款<strong>开源暴力破解工具</strong>。Hydra 是一个验证性质的工具，主要目的是：展示安全研究人员从<strong>远程获取一个系统认证权限</strong>。</p>
</blockquote>
<h2 id="常见参数"><a class="header" href="#常见参数">常见参数</a></h2>
<ul>
<li>-R: 继续从上一次进度接着破解</li>
<li>-S: 大写，采用 SSL 链接</li>
<li>-s <PORT>： 小写，可通过这个参数指定非默认端口</li>
<li>-l <LOGIN>： 指定破解的用户，对特定用户破解</li>
<li>-L <FILE>： 指定用户名字典</li>
<li>p <PASS>： 小写，指定密码破解，少用，一般是采用密码字典</li>
<li>-P <FILE>： 大写，指定密码字典</li>
<li>-e <ns>： 可选选项，n：空密码试探，s：使用指定用户和密码试探</li>
<li>-C <FILE>： 使用冒号分割格式，例如“登录名: 密码”来代替 -L/-P 参数</li>
<li>-M <FILE>： 指定目标列表文件一行一条</li>
<li>o <FILE>： 指定结果输出文件</li>
<li>-f ： 在使用 -M 参数以后，找到第一对登录名或者密码的时候中止破解</li>
<li>-t <TASKS>： 同时运行的线程数，默认为 16</li>
<li>-w <TIME>： 设置最大超时的时间，单位秒，默认是 30s</li>
<li>-v / -V： 显示详细过程</li>
<li>server： 目标 ip</li>
<li>service： 指定服务名，支持的服务和协议</li>
<li>OPT： 可选项</li>
</ul>
<hr />
<h2 id="实例分析"><a class="header" href="#实例分析">实例分析</a></h2>
<h3 id="1破解-ssh"><a class="header" href="#1破解-ssh">1.破解 Ssh</a></h3>
<p><code>hydra -M sship.txt ssh -L user.txt -P passwd.txt -e ns -f -vV -t 4 -o ssh.txt</code></p>
<blockquote>
<p>-M 指定目标列表文件 一条一行</p>
<p>-L 指定用户字典</p>
<p>-P 指定密码字典</p>
<p>-e ns 空密码试探</p>
<p>-f 当破解一个成功密码就停止</p>
<p>-o 把成功的输出到 ssh.txt 文件</p>
<p>-vV 显示详细信息</p>
</blockquote>
<h3 id="2破解-3389-远程登录"><a class="header" href="#2破解-3389-远程登录">2.破解 3389 远程登录</a></h3>
<p><code>hydra -M rdpip.txt rdp -L user.txt -P passwd.txt -e ns -f -vV -t 16 -o rdp.txt</code></p>
<h3 id="3破解-mysql-数据库"><a class="header" href="#3破解-mysql-数据库">3.破解 MySQL 数据库</a></h3>
<p><code>hydra -M mysqlip.txt rdp -L user.txt -P passwd.txt -e ns -f -vV -t 16 -o mysql.txt</code></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: 😜 树莓派折腾手册 (二)——手动搭建LNMP网站服务器环境 🙏
date: 2021-06-18 19:37:48
updated: 2021-06-18 19:37:48
categories: Linux
tags: [Respi, Linux]
description:
thumbnail: http://oss.whaleluo.top/blog/old/20210619154345.jpg
banner_img: http://oss.whaleluo.top/blog/old/20210619154345.jpg</p>
<hr />
<h1 id="-树莓派折腾手册-二手动搭建-lnmp-网站服务器环境-"><a class="header" href="#-树莓派折腾手册-二手动搭建-lnmp-网站服务器环境-">😜 树莓派折腾手册 (二)——手动搭建 LNMP 网站服务器环境 🙏</a></h1>
<blockquote>
<p>前言：这个东西我折腾了很久，试过一键部署脚本: <a href="https://lnmp.org/auto.html">https://lnmp.org/auto</a> 但是我想在局域网 +frp 穿透的外网，访问树莓派的网站，但是只能绑定一个域名，反正用多了就出各种问题，可能我不会用</p>
</blockquote>
<pre><code class="language-shell">sudo apt-get update   #好习惯，安装软件前先更新源列表 
</code></pre>
<h2 id="1安装-php73"><a class="header" href="#1安装-php73"><strong>1.安装 PHP7.3</strong></a></h2>
<blockquote>
<p><strong>这里跳了很多坑，后来查文档才发现 Debian 10 buster 只能安装 PHP7.0 以上的版本</strong></p>
</blockquote>
<pre><code class="language-shell">sudo apt install -y -t buster php7.3-fpm php7.3-curl php7.3-gd php7.3-intl php7.3-mbstring php7.3-mysql php7.3-imap php7.3-opcache php7.3-sqlite3 php7.3-xml php7.3-xmlrpc php7.3-zip 
</code></pre>
<p>通过命令 <code>php -v</code> 能够看到 PHP 版本号 7.3，说明安装完成:</p>
<blockquote>
<p>输出显示配置文件在/etc/php/7.3/cli/php.ini。注意，实际上配置文件有两个，另外一个在/etc/php/7.3/fpm/php.ini。通过命令行调用 php 时，会使用第一个配置文件；通过 fpm 调用 php（例如 nginx）会使用第二个配置文件。</p>
</blockquote>
<p>php-fpm 常用管理命令:</p>
<pre><code class="language-shell">开启php-fpm:
sudo systemctl start php7.3-fpm 
关闭php-fpm: 
sudo systemctl stop php7.3-fpm 
重启php-fpm: 
sudo systemctl restart php7.3-fpm 
编辑php-fpm配置文件:
sudo nano /etc/php/7.3/fpm/php.ini 
</code></pre>
<h2 id="2安装-nginx"><a class="header" href="#2安装-nginx"><strong>2.安装 nginx:</strong></a></h2>
<pre><code class="language-shell">sudo apt-get install nginx
</code></pre>
<blockquote>
<p>安装完成后，会自动开启 nginx。在浏览器输入树莓派的 IP 地址，可以看到“Welcome to nginx!”</p>
</blockquote>
<p><strong>nginx 常用管理命令：</strong></p>
<pre><code class="language-shell">启动nginx: sudo systemctl start nginx 
关闭nginx：sudo systemctl stop nginx 
设置nginx开机启动：sudo systemctl enable nginx 
重启nginx：sudo systemctl restart nginx 
#配置文件的位置： 
默认的网站根目录：/var/www/html 
nginx配置文件目录：/etc/nginx/ 
nginx主配置文件位置：/etc/nginx/nginx.conf 
</code></pre>
<h2 id="3配置-nginx-解析-php-关键"><a class="header" href="#3配置-nginx-解析-php-关键">3.配置 Nginx 解析 Php (关键)</a></h2>
<ul>
<li>编辑配置 nginx 文件:</li>
</ul>
<pre><code class="language-shell">sudo nano /etc/nginx/sites-enabled/default 
</code></pre>
<p>找到 <code># pass PHP scripts to FastCGI server</code> 后面的 <code>location</code> ，删除注释。修改后如下：</p>
<blockquote>
<p>PHP 的默认路径转发有问题导致的,因为很多 nginx 的默认 PHP 配置文件的写法为 <strong>location ~ ​</strong>​<strong>php</strong> 要改成 <strong>location~.<strong>​</strong>*php(<em><strong>​</strong></em>.<em><strong>​</strong>)</em>$</strong></p>
</blockquote>
<pre><code class="language-shell">index index.php index.html index.htm index.nginx-debian.html; 
location ~ .*\.php(\/.*)*$ { 
include snippets/fastcgi-php.conf; 
# 
# # With php-fpm (or other unix sockets): 
    fastcgi_pass unix:/run/php/php7.3-fpm.sock; 
# # With php-cgi (or other tcp sockets): 
#fastcgi_pass 127.0.0.1:9000; 
} 
</code></pre>
<ul>
<li>保存后重启 nginx：</li>
</ul>
<pre><code class="language-shell">sudo systemctl restart nginx
</code></pre>
<p><strong>重启无报错则修改成功啦:</strong><br />
<img src="http://oss.whaleluo.top/blog/old/20210619152804.png-picsmall" alt="" /></p>
<ul>
<li>在网站根目录创建一个 php 文件：</li>
</ul>
<pre><code class="language-shell">sudo nano /var/www/html/index.php 
</code></pre>
<p>写入以下 php 代码并保存：</p>
<pre><code class="language-shell">&lt;?php phpinfo(); 
</code></pre>
<p>在浏览器中输入树莓派的 IP 地址即可看到 phpinfo:<br />
<img src="http://oss.whaleluo.top/blog/old/20210619152811.png-picsmall" alt="" /></p>
<h2 id="4安装-mariadb-数据库"><a class="header" href="#4安装-mariadb-数据库"><strong>4.安装 mariaDB 数据库</strong></a></h2>
<ul>
<li>使用以下命令安装 <code>mariadb</code>:</li>
</ul>
<pre><code class="language-shell">sudo apt-get install mariadb-server mariadb-client 
</code></pre>
<ul>
<li>执行数据库初始化安装:</li>
</ul>
<pre><code class="language-shell">sudo mysql_secure_installation 
</code></pre>
<blockquote>
<p>根据提示设置数据库 <code>root用户密码</code>、<code>是否允许外网访问</code> 等，建议用<strong>翻译软件</strong>，一步步翻译。 <code>回车 n Y n Y Y</code></p>
</blockquote>
<ul>
<li>尝试用<strong>普通用户 pi</strong>登录数据库:<br />
<code>mysql -u root -p</code><br />
输入上一步设置的密码，发现无法登录，错误提示如下:</li>
</ul>
<blockquote>
<p>ERROR 1698 (28000): Access denied for user ‘root’@’localhost’</p>
</blockquote>
<p>原因: 数据库默认使用<strong>特权用户 root 登录</strong>，需要修改为<strong>普通用户使用密码登录</strong></p>
<ul>
<li>尝试用<strong>特权用户 root</strong>登录数据库:</li>
</ul>
<pre><code class="language-shell">sudo mysql -u root# 登入数据库后，依次执行以下SQL： use mysql;update user set plugin='mysql_native_password';flush privileges;exit;
</code></pre>
<p><img src="http://oss.whaleluo.top/blog/old/20210619152818.png-picsmall" alt="" /></p>
<p>再次使用普通用户 pi <code>mysql -u root -p</code> 即可通过密码登录数据库，无需 root 权限执行:</p>
<p><img src="http://oss.whaleluo.top/blog/old/20210619152823.png-picsmall" alt="" /></p>
<ul>
<li>设置<strong>数据库密码</strong><br />
<strong>依次执行以下 SQL：</strong></li>
</ul>
<pre><code class="language-sql">use mysql;   UPDATE user SET password=password('123456') WHERE user='root';   flush privileges;   exit; 
</code></pre>
<ul>
<li>设置<strong>mariaDB 数据库</strong> <em><strong>外部网络访问权限</strong></em></li>
</ul>
<blockquote>
<p>根据官方的说法， MariaDB 为了<strong>提高安全性</strong>，默认只监听 127.0.0.1 中的 3306 端口并且禁止了远程的 TCP 链接，我们可以通过下面两步来开启<strong>MySQL 的远程服务</strong></p>
</blockquote>
<ol>
<li>打开文件 <code>sudo nano /etc/mysql/mariadb.conf.d/50-server.cnf</code>，注释掉 bind-address 项，如下:<br />
<img src="http://oss.whaleluo.top/blog/old/20210619152829.png-picsmall" alt="" /></li>
<li>开启了<strong>MySQL 监听远程连接</strong>的选项，接下来需要给对应的<strong>MySQL 账户分配权限</strong>，允许使用该账户<strong>远程连接</strong>到 MySQL:<br />
查看<strong>用户账号信息</strong>：</li>
</ol>
<pre><code class="language-sql">select User,host from mysql.user;
</code></pre>
<p><img src="http://oss.whaleluo.top/blog/old/20210619152834.png-picsmall" alt="" /><br />
<strong>root 账户</strong>中的 host 项是<strong>localhost</strong>表示该账号只能进行<strong>本地登录</strong>，我们需要<strong>修改权限</strong>，执行 MySQL 命令:</p>
<pre><code class="language-sql">GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;FLUSH PRIVILEGES;exit;
</code></pre>
<p><img src="http://oss.whaleluo.top/blog/old/20210619152851.png-picsmall" alt="" /></p>
<blockquote>
<p>这个时候发现相比之前<strong>多了一项</strong>，它的<strong>host 项是%</strong>，这个时候说明配置成功了，我们可以用该账号进行<strong>远程访问</strong>了</p>
</blockquote>
<ul>
<li><strong>mariadb 配置文件</strong>保存在多个位置:</li>
</ul>
<pre><code class="language-shell">/etc/mysql/mariadb.cnf /etc/mysql/mariadb.conf.d/ /etc/mysql/conf.d/ 
</code></pre>
<ul>
<li><strong>mariadb 常用</strong>命令:</li>
</ul>
<pre><code class="language-shell">#启动mariadb: sudo systemctl start mariadb #关闭/开启/重启 mariadb：systemctl stop/start/restart mariadb #设置mariadb开机启动：sudo systemctl enable mariadb 
</code></pre>
<ul>
<li><strong>连接 MySQL</strong>数据库命令:</li>
</ul>
<pre><code class="language-shell">mysql -h主机地址 -u用户名 －p用户密码
</code></pre>
<blockquote>
<p><strong>(注:u 与 root 可以不用加空格，其它也一样)</strong></p>
</blockquote>
<h2 id="5安装-phpmyadmin-可视化-mysql-管理工具"><a class="header" href="#5安装-phpmyadmin-可视化-mysql-管理工具">5.安装 <code>phpmyadmin</code> 可视化 MySQL 管理工具</a></h2>
<blockquote>
<p><strong>官方网站</strong>: <a href="https://www.phpmyadmin.net/">phpmyadmin官网</a></p>
<ul>
<li>用<strong>wget</strong>下载源码包包到 web 目录<br />
(请自行到官网获取最新下载链接)，截至 2020/8/4 版本为:<br />
<strong>phpMyAdmin-5.0.2-all-languages.zip</strong></li>
</ul>
</blockquote>
<pre><code class="language-shell">wget https://gproxy.cn/https://github.com/phpmyadmin/phpmyadmin/archive/RELEASE_5_0_4.zip
</code></pre>
<ul>
<li><strong>解压 zip 格式</strong>源码包包到<strong>web 目录</strong></li>
</ul>
<pre><code class="language-shell">sudo chmod 777 -R /var/www/html/unzip -d /var/www/html/ ~/phpMyAdmin-5.0.2-all-languages.zip 
</code></pre>
<blockquote>
<p>若 unzip 不受支持请安装<br />
<strong>sudo apt-get install unzip</strong></p>
</blockquote>
<ul>
<li><strong>重命名文件夹并修改参数</strong></li>
</ul>
<pre><code class="language-shell">cd /var/www/html/mv phpMyAdmin-5.0.2-all-languages phpmyadmincd phpmyadminmv config.sample.inc.php config.inc.phpnano config.inc.php$cfg['AllowArbitraryServer'] = true;
</code></pre>
<p>编辑 <code>config.inc.php</code> 文件，修改密钥字段:<br />
<img src="http://oss.whaleluo.top/blog/old/20210619152859.png-picsmall" alt="" /></p>
<blockquote>
<p>修改<strong>blowfish_secret</strong>字段，后面的密钥无仅仅用于加密而已，<strong>尽量足够长</strong>。<strong>当然偷偷插入</strong>​**<del>喜欢的女孩子</del><strong>​</strong>名字也是可以的哦**</p>
</blockquote>
<ul>
<li>把<strong>config.inc.php 文件权限修改</strong>为 744</li>
</ul>
<pre><code class="language-shell">sudo chmod 744 config.inc.php
</code></pre>
<ul>
<li>尝试访问 <a href="http://%E4%BD%A0%E7%9A%84%E6%A0%91%E8%8E%93%E6%B4%BEip/phpmyadmin">http://你的树莓派ip/phpmyadmin</a><br />
<img src="http://oss.whaleluo.top/blog/old/20210619152752.png-picsmall" alt="" /><br />
<strong>启动高级功能</strong> 会新建一个 phpmyadmin 数据库<br />
<img src="http://oss.whaleluo.top/blog/old/20210619152912.png-picsmall" alt="" /><br />
<strong>安装成功！</strong><br />
<img src="http://oss.whaleluo.top/blog/old/20210619152920.png-picsmall" alt="" /></li>
</ul>
<h2 id="6搭建多个-nginx-虚拟主机"><a class="header" href="#6搭建多个-nginx-虚拟主机">6.搭建多个 <code>nginx</code> 虚拟主机</a></h2>
<blockquote>
<p>有时候我们要在主机的<strong>不同端口</strong>搭建不同用处的<strong>web 服务</strong>，这时就需要多个新建多个 nginx 虚拟主机的啦~</p>
</blockquote>
<ul>
<li>
<p>打开 <code>nginx</code> 主配置文件</p>
<pre><code class="language-shell">sudo nano /etc/nginx/nginx.conf
</code></pre>
<p><img src="http://oss.whaleluo.top/blog/old/20210619152925.png-picsmall" alt="image-20200805160257592" /></p>
</li>
</ul>
<p>找到 <code>include</code> 字段就是每个<strong>虚拟主机配置文件</strong>，为了方便管理，我们在<strong>用户家目录</strong>新建一个 <code>nginx-conf</code> 存放我们的<strong>nginx 虚拟主机文件</strong></p>
<pre><code class="language-shell"># 在配置文件插入include /home/pi/nginx-conf/*;
</code></pre>
<p><img src="http://oss.whaleluo.top/blog/old/20210619152933.png-picsmall" alt="image-20200805160615360" /></p>
<pre><code class="language-shell">mkdir /home/pi/nginx-confnano /home/pi/nginx-conf/kodbox.conf
</code></pre>
<p>写入以下内容: <em><strong>(贴出一份完整的 nginx 虚拟主机配置，需要自行修改两个参数)</strong></em></p>
<pre><code class="language-shell"># 监听端口 两个都要改server { listen 88 default_server; listen [::]:88 default_server; # SSL configuration # # listen 443 ssl default_server; # listen [::]:443 ssl default_server; # # include snippets/snakeoil.conf; root /home/pi/kodbox; #网站根目录位置 # Add index.php to the list if you are using PHP index index.php index.html index.htm index.nginx-debian.html; server_name _; location / {  try_files $uri $uri/ =404; } # pass PHP scripts to FastCGI server # location ~ .*\.php(\/.*)*$ {  include snippets/fastcgi-php.conf;  fastcgi_pass unix:/run/php/php7.3-fpm.sock; }}
</code></pre>
<p>重启 <code>nginx</code>，愿一切安好:</p>
<pre><code class="language-shell">sudo systemctl restart nginxwget --content-disposition https://packagecloud.io/headmelted/codebuilds/packages/debian/stretch/code-oss_1.45.0-1586135971_arm64.deb/download.deb
</code></pre>
<h2 id="7-树莓派-php-调优"><a class="header" href="#7-树莓派-php-调优">7. 树莓派 <code>PHP</code> 调优</a></h2>
<blockquote>
<h4 id="lnmp-默认环境部署完成后进行调优以应对多并发复杂任务的情景"><a class="header" href="#lnmp-默认环境部署完成后进行调优以应对多并发复杂任务的情景"><strong>lnmp 默认环境</strong>部署完成后，进行调优以应对<strong>多并发，复杂任务的情景</strong></a></h4>
</blockquote>
<ul>
<li>
<p>部署<strong>PHP 探针</strong>以测试</p>
<blockquote>
<p>部署服务器探针推荐 X 探针，GitHub 项目地址：</p>
<p><a href="https://github.com/kmvan/x-prober">GitHub X刘海探针</a></p>
</blockquote>
</li>
</ul>
<pre><code class="language-shell">#克隆项目到www目录cd /var/www/htmlwget https://github.com/kmvan/x-prober/raw/master/dist/prober.php#删除默认页rm index.phpmv prober.php index.phpsudo chmod 777 index.php
</code></pre>
<p><strong>尝试</strong>访问 <code>http://树莓派ip</code> :</p>
<p><img src="http://oss.whaleluo.top/blog/old/20210619152940.png-picsmall" alt="image-20200807132503823" /></p>
<blockquote>
<p>可以看到这些参数都是好 <strong>鸡肋的</strong></p>
</blockquote>
<ul>
<li>修改<strong>php.ini</strong> 仔细看好喽~</li>
</ul>
<pre><code class="language-shell">sudo nano /etc/php/7.3/fpm/php.ini
</code></pre>
<p>修改 <em><strong>post 方式提交的数据大小</strong></em>，查找：<code>post_max_size</code> <strong>酌情修改为 2000M</strong></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210619152945.png-picsmall" alt="image-20200807133234597" /></p>
<p>修改 <em><strong>运行超时秒数</strong></em> ，查找：<code>max_execution_time</code> <strong>酌情修改为 3600s</strong></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210619152950.png-picsmall" alt="image-20200807133453326" /></p>
<p>修改 <em><strong>上传文件限制</strong></em> ，查找：<code>upload_max_filesize</code> <strong>酌情修改为 2000M</strong></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210619152956.png-picsmall" alt="image-20200807133741086" /></p>
<p>修改 <em><strong>运行内存限制</strong></em> ，查找：<code>memory_limit</code> <strong>酌情修改为 2000M</strong></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210619153003.png-picsmall" alt="image-20200807133917750" /></p>
<p>开启 <em><strong>文件上传</strong></em> ,查找：<code>file_uploads</code> 更改为 <code>On</code></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210619153007.png-picsmall" alt="image-20200807134107318" /></p>
<ul>
<li>
<p>更改完成后重启 <code>nginx+php-fpm</code></p>
<pre><code>max_input_time = 3600;sudo systemctl restart nginxsudo systemctl restart php7.3-fpm
</code></pre>
</li>
</ul>
<p><strong>更改后的探针页面</strong>：</p>
<p><img src="http://oss.whaleluo.top/blog/old/20210619153012.png-picsmall" alt="image-20200807134706542" /></p>
<h2 id="8搭建-kodbox-云私有云盘"><a class="header" href="#8搭建-kodbox-云私有云盘">8.搭建 <code>kodbox</code> 云私有云盘</a></h2>
<blockquote>
<h1 id="下载安装"><a class="header" href="#下载安装">下载安装</a></h1>
<h4 id="即刻下载开启私有云盘之旅"><a class="header" href="#即刻下载开启私有云盘之旅">即刻下载，开启私有云盘之旅</a></h4>
<p><strong>官网:<strong>​</strong></strong></p>
</blockquote>
<ul>
<li><strong>下载源码</strong></li>
</ul>
<pre><code class="language-shell">cd ~mkdir kodboxcd kodboxwget http://static.kodcloud.com/update/download/kodbox.1.11.zipunzip kodbox.1.11.zipunzip kodbox.1.11.ziprm kodbox.1.11.zipchmod 777 ~/kodbox
</code></pre>
<p>尝试访问 **** :</p>
<p><img src="http://oss.whaleluo.top/blog/old/20210619153018.png-picsmall" alt="image-20200805163537543" /></p>
<blockquote>
<p>除了 PHP 版本外其他都可以通过哒~</p>
</blockquote>
<ul>
<li>
<p>安装系统缓存 <code>Redis</code></p>
<pre><code>sudo apt-get install redis php-redis
</code></pre>
<p><img src="http://oss.whaleluo.top/blog/old/20210619153025.png-picsmall" alt="image-20200805164115135" /></p>
</li>
</ul>
<p><strong>redis 服务会自动运行自动添加开机启动项，省心！！！</strong></p>
<p><strong>编辑</strong>​<code>sudo nano /etc/php/7.3/fpm/php.ini</code> 文件加入：</p>
<p><img src="http://oss.whaleluo.top/blog/old/20210619153032.png-picsmall" alt="image-20200807211906533" /></p>
<pre><code>extension=redis.so#重启php-fpmsudo systemctl restart php7.3-fpm 
</code></pre>
<p><img src="http://oss.whaleluo.top/blog/old/20210619153038.png-picsmall" alt="image-20200805164305612" /></p>
<blockquote>
<h4 id="数据库选择mysql填入自己的密码"><a class="header" href="#数据库选择mysql填入自己的密码">数据库选择<strong>MySQL</strong>，填入自己的密码</a></h4>
<h4 id="系统缓存类型选择-redis"><a class="header" href="#系统缓存类型选择-redis">系统缓存类型选择 Redis</a></h4>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: 玩客云帮助手册
date: 2021-12-19 19:37:48
updated: 2021-12-19 19:37:48
categories: Linux
tags: [WKY, Linux]
description:
thumbnail: http://oss.whaleluo.top/blog/old/20220329204745.png
banner_img: http://oss.whaleluo.top/blog/old/20220329204745.png</p>
<hr />
<h1 id="学校玩客云修复计划"><a class="header" href="#学校玩客云修复计划">学校玩客云修复计划</a></h1>
<h2 id="重新烧写玩客云"><a class="header" href="#重新烧写玩客云">重新烧写玩客云</a></h2>
<ol>
<li>
<p>带螺丝批，拆机短接，<strong>双公 ​</strong>​**<code>USB</code>** 连接一体机烧写 <code>Armbian5.67直刷包带宝塔.7z</code></p>
</li>
<li>
<p>玩客云通过网线直连一体机，参考：<a href="https://zhuanlan.zhihu.com/p/37761024">树莓派使用网线直连电脑的方法 - 知乎 (zhihu.com)</a></p>
<ul>
<li>
<p>手机开热点一体机连接</p>
</li>
<li>
<p>Win10 可以直接从【设置 -&gt;网络和 Internet-&gt;状态 -&gt;更改适配器设置】进入可以看到，我们的本地网络连接方式有 <strong>WLAN 无线连接</strong> 和 <strong>以太网有线连接</strong> 两种方式。</p>
</li>
<li>
<p>记录当前我们的网络连接状况：<code>arp -a</code></p>
</li>
<li>
<p><strong>共享 WLAN 网络给以太网</strong></p>
<p>更改适配器设置 界面中选择修改 WLAN 属性。选择共享，设置共享网络给以太网。（其他选项全部选择）</p>
</li>
<li>
<p><strong>查询树莓派的 IP 地址</strong></p>
<p>将树莓派的网线插到一体机的 PC 端口后再查询一次：<code>arp -a</code></p>
</li>
</ul>
</li>
<li>
<p>利用 <strong>Putty</strong> 连接玩客云。</p>
<p>SSH 远程账号 <code>root</code> ：密码 1234<br />
宝塔账号 <code>onecloud</code> ：密码 123456</p>
</li>
</ol>
<h2 id="玩客云配置"><a class="header" href="#玩客云配置">玩客云配置</a></h2>
<ol>
<li>
<p><strong>换源</strong></p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/qq_42877824/article/details/119332805">玩客云刷armbian更新源报错The repository ‘http://apt.armbian.com stretch Release‘ does not have a Release file</a></p>
</blockquote>
<p><strong>修改源配置文件</strong></p>
</li>
</ol>
<pre><code class="language-shell">vim /etc/apt/sources.list

deb http://mirrors.tuna.tsinghua.edu.cn/debian/ stretch main contrib non-free
deb-src http://mirrors.tuna.tsinghua.edu.cn/debian/ stretch main contrib non-free
deb http://mirrors.tuna.tsinghua.edu.cn/debian/ stretch-updates main contrib non-free
deb-src http://mirrors.tuna.tsinghua.edu.cn/debian/ stretch-updates main contrib non-free
deb http://mirrors.tuna.tsinghua.edu.cn/debian/ stretch-backports main contrib non-free
deb-src http://mirrors.tuna.tsinghua.edu.cn/debian/ stretch-backports main contrib non-free
deb http://mirrors.tuna.tsinghua.edu.cn/debian-security/ stretch/updates main contrib non-free
deb-src http://mirrors.tuna.tsinghua.edu.cn/debian-security/ stretch/updates main contrib non-free

vim /etc/apt/sources.list.d/armbian.list
deb [trusted=yes] http://apt.armbian.com bionic main bionic-utils bionic-desktop

# 更新源
sudo apt update
sudo apu upgrade
</code></pre>
<ol>
<li>
<p><strong>卸载自带的宝塔面板</strong></p>
<pre><code class="language-shell">apt-get install wget git nginx -y
wget http://download.bt.cn/install/bt-uninstall.sh
sh bt-uninstall.sh
</code></pre>
</li>
<li>
<p><strong>部署 ​</strong>​**<code>Frpc</code><strong>​</strong>​ 内网穿透**</p>
<p><strong>下载并解压</strong></p>
<pre><code class="language-shell">cd ~
wget https://hub.fastgit.org/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_linux_arm.tar.gz
tar -xzvf frp_0.38.0_linux_arm.tar.gz
</code></pre>
<p><strong>拷贝配置文件：</strong></p>
<pre><code class="language-ini">[common]
server_addr = frps.420400150.xyz
server_port = 7000
token = 12345678
user = whalefall
login_fail_exit = false
protocol = tcp
tcp_mux = true
dns_server = 114.114.114.114
tls_enable = true

[ssh_tcp]
type = tcp
local_ip = 127.0.0.1
local_port = 22
remote_port = 42202
use_encryption = false
use_compression = true

[pi_vpn]
type = tcp
local_ip = 127.0.0.1
local_port = 1194
remote_port = 41194
use_encryption = false
use_compression = true
</code></pre>
<p><strong>配置 systemctl 服务并设置开机自启动</strong></p>
<p>systemctl 配置文件夹在 <code>/etc/systemd/system/frpc.service</code> 目录下</p>
<p>配置文件：</p>
<pre><code class="language-ini">[Unit]
Description=Frp Client Service
After=network.target

[Service]
Type=simple
User=root
Restart=on-failure
RestartSec=5s
ExecStart=/root/frp/frpc -c /root/frp/frpc.ini
ExecReload=/root/frp/frpc reload -c /root/frp/frpc.ini
LimitNOFILE=1048576

[Install]
WantedBy=multi-user.target
</code></pre>
<p>启动：</p>
<pre><code class="language-shell">sudo systemctl start frpc # 开启
sudo systemctl status frpc  # 查看状态
sudo systemctl enable frpc  # 设置开机自启
</code></pre>
</li>
<li>
<p><strong>Python</strong> 调优</p>
<p><strong>Python</strong> 更换国内 <code>pip</code> 源：</p>
<pre><code class="language-shell">mkdir ~/.pip
nano ~/.pip/pip.conf

#写入
[global]
timeout = 5000
index-url = https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple
[install]
use-mirrors = true
mirrors = https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple

python3 -m pip install --upgrade pip  # 更新pip
pip3 install httpx  # 测试
</code></pre>
</li>
<li>
<p>部署<strong>校园网自动登录 ​</strong>​**<code>FRPC</code><strong>​</strong>​ 配置自动获取脚本**</p>
<blockquote>
<p>项目地址：<a href="https://github.com/AdminWhaleFall/rpi-ping">AdminWhaleFall/rpi-ping: 树莓派自动上传信息工具. (github.com)</a></p>
</blockquote>
<pre><code class="language-shell">cd ~
git clone https://hub.fastgit.org/AdminWhaleFall/rpi-ping
chmod 777 -R rpi-ping

cd rpi-ping
pip3 install -r req... (Tab补全)
python3 main.py  # 测试运行
</code></pre>
<p>脚本设置为 systemctl 服务：</p>
<p>新建 <code>/etc/systemd/system/rpi.service</code> ：</p>
<pre><code class="language-ini">[Unit]
Description=Python Task Service
After=network.target

[Service]
Type=simple
User=root
Group=root
ExecStart=/usr/bin/python3 /root/rpi-ping/main.py
Restart=always
RestartSec=2
PrivateTmp=true

[Install]
WantedBy=multi-user.target
</code></pre>
</li>
</ol>
<h2 id="玩客云网络配置重要"><a class="header" href="#玩客云网络配置重要">玩客云网络配置（重要）</a></h2>
<ol>
<li>
<p>设置静态 ip：</p>
<blockquote>
<p>我们学校的校园网没有 dhcp 服务器，要手动设置 IP，教学楼的网段是：<strong>192.168.5.0/24</strong></p>
</blockquote>
<pre><code class="language-shell">nano /etc/network/interfaces

# 注释掉
# iface eth0 inet dhcp
# 添加静态IP
iface eth0 inet static
address 192.168.5.12
netmask 255.255.255.0
gateway 192.168.5.1
dns-nameservers 114.114.114.114 192.168.3.3

# address: 地址；netmask: 子网掩码；gateway:路由
systemctl restart NetworkManager  # 重启网络服务
</code></pre>
<p>然后把玩客云插到讲台下面的网线处.访问 <code>192.168.5.12</code> 测试</p>
</li>
<li>
<p>永久修改 dns：</p>
<p>禁用 dhcp 分配的 dns 服务器：</p>
<pre><code class="language-shell">nano /etc/dhcp/dhclient.conf

# 最后添加一行
supersede domain-name-servers 114.114.114.114, 8.8.8.8;
dhclient
</code></pre>
<p>在 Resolvconf 中设置永久 DNSNameservers ：</p>
<pre><code class="language-shell">nano /etc/resolvconf/resolv.conf.d/head
# 添加
nameserver 114.114.114.114

systemctl restart resolvconf.service
resolvconf -u
sudo dpkg-reconfigure resolvconf

cat /etc/resolv.conf
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: 抑郁症用药大全对照表
date: 2021-06-18 19:37:48
updated: 2021-06-18 19:37:48
categories: Depression
tags: [Depression, Medicine]
description: 抑郁症所有用药对照表
thumbnail: http://oss.whaleluo.top/blog/old/%E5%89%B2%E8%85%95(%E4%BA%8C%E6%AC%A1%E5%85%83).jpg
banner_img: http://oss.whaleluo.top/blog/old/%E5%89%B2%E8%85%95(%E4%BA%8C%E6%AC%A1%E5%85%83).jpg</p>
<hr />
<h1 id="抑郁症常用药物对照表"><a class="header" href="#抑郁症常用药物对照表">抑郁症常用药物对照表</a></h1>
<p>利用 Python 爬取,项目地址:<a href="https://github.com/WhaleFell/dxyMedicineSpider">WhaleFell/dxyMedicineSpider</a></p>
<h2 id="正文"><a class="header" href="#正文">正文</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">药物名称 (俗名)</th><th>主治</th></tr></thead><tbody>
<tr><td style="text-align: center">圣·约翰草提取物片 (路优泰)</td><td>抑郁症，焦虑和/或烦躁不安。</td></tr>
<tr><td style="text-align: center">马来酸氟伏沙明片 (兰释)</td><td>抑郁发作。强迫症 (OCD)。</td></tr>
<tr><td style="text-align: center">盐酸氟西汀分散片 (百优解)</td><td>抑郁症强迫症 (OCD) 神经性贪食症：作为心理治疗的辅助用药，以减少贪食和导泻行为 中度至重度抑郁发作：8 岁及以上的儿童和青少年强迫症：7 岁及以上的儿童和青少年</td></tr>
<tr><td style="text-align: center">劳拉西泮片 (罗拉)</td><td>适用于焦虑障碍的治疗或用于缓解焦虑症状以及与抑郁症状相关的焦虑的短期治疗。与日常生活压力相关的焦虑或紧张，通常不需要抗焦虑药的治疗。劳拉西泮长期应用的效果即应用 4 个月以上的效果还未经系统的临床研究评估。医师应定期重新评估该药对个体患者的有效性。</td></tr>
<tr><td style="text-align: center">阿戈美拉汀片 (维度新)</td><td>治疗成人抑郁症。本品适用于成人。</td></tr>
<tr><td style="text-align: center">卡马西平片 (卡马西平片)</td><td>癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期 预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经 痛以及疱疹后神经痛。预防或治疗躁狂 - 抑郁症；对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症， 可单用或氯磺丙脲或氯贝丁酯等合用。酒精癖的戒断综合征。</td></tr>
<tr><td style="text-align: center">米氮平片 (瑞美隆®)</td><td>抑郁症的发作</td></tr>
<tr><td style="text-align: center">盐酸度洛西汀肠溶胶囊 (欣百达)</td><td>用于治疗抑郁症； 用于治疗广泛性焦虑障碍； 用于治疗慢性肌肉骨骼疼痛。</td></tr>
<tr><td style="text-align: center">氢溴酸西酞普兰片 (氢溴酸西酞普兰片)</td><td>治疗抑郁症。</td></tr>
<tr><td style="text-align: center">噻奈普汀钠片 (达体朗)</td><td>抑郁发作 (即典型性)。</td></tr>
<tr><td style="text-align: center">圣·约翰草提取物片 (路优泰)</td><td>抑郁症，焦虑和/或烦躁不安。</td></tr>
<tr><td style="text-align: center">马来酸氟伏沙明片 (兰释)</td><td>抑郁发作。强迫症 (OCD)。</td></tr>
<tr><td style="text-align: center">盐酸氟西汀分散片 (百优解)</td><td>抑郁症强迫症 (OCD) 神经性贪食症：作为心理治疗的辅助用药，以减少贪食和导泻行为 中度至重度抑郁发作：8 岁及以上的儿童和青少年强迫症：7 岁及以上的儿童和青少年</td></tr>
<tr><td style="text-align: center">劳拉西泮片 (罗拉)</td><td>适用于焦虑障碍的治疗或用于缓解焦虑症状以及与抑郁症状相关的焦虑的短期治疗。与日常生活压力相关的焦虑或紧张，通常不需要抗焦虑药的治疗。劳拉西泮长期应用的效果即应用 4 个月以上的效果还未经系统的临床研究评估。医师应定期重新评估该药对个体患者的有效性。</td></tr>
<tr><td style="text-align: center">阿戈美拉汀片 (维度新)</td><td>治疗成人抑郁症。本品适用于成人。</td></tr>
<tr><td style="text-align: center">卡马西平片 (卡马西平片)</td><td>癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期 预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经 痛以及疱疹后神经痛。预防或治疗躁狂 - 抑郁症；对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症， 可单用或氯磺丙脲或氯贝丁酯等合用。酒精癖的戒断综合征。</td></tr>
<tr><td style="text-align: center">米氮平片 (瑞美隆®)</td><td>抑郁症的发作</td></tr>
<tr><td style="text-align: center">盐酸度洛西汀肠溶胶囊 (欣百达)</td><td>用于治疗抑郁症； 用于治疗广泛性焦虑障碍； 用于治疗慢性肌肉骨骼疼痛。</td></tr>
<tr><td style="text-align: center">氢溴酸西酞普兰片 (氢溴酸西酞普兰片)</td><td>治疗抑郁症。</td></tr>
<tr><td style="text-align: center">噻奈普汀钠片 (达体朗)</td><td>抑郁发作 (即典型性)。</td></tr>
<tr><td style="text-align: center">盐酸阿米替林片 (阿密替林)</td><td>用于治疗各种抑郁症，本品的镇静作用较强，主要用于治疗焦虑性或激动性抑郁症。</td></tr>
<tr><td style="text-align: center">盐酸帕罗西汀片 (赛乐特)</td><td>本品用于治疗抑郁症、强迫症、伴有或不伴有广场恐怖的惊恐障碍、社交恐怖症/社交焦虑症。 疗效满意后，继续服用本品可防止抑郁症、惊恐障碍和强迫症的复发。</td></tr>
<tr><td style="text-align: center">盐酸文拉法辛缓释胶囊 (怡诺思)</td><td>本品用于治疗抑郁症（包括伴有焦虑的抑郁症）及广泛性焦虑障碍。</td></tr>
<tr><td style="text-align: center">草酸艾司西酞普兰片 (来士普)</td><td>治疗抑郁症。治疗伴有或不伴有广场恐怖症的惊恐障碍。</td></tr>
<tr><td style="text-align: center">盐酸舍曲林片 (左洛复)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。 舍曲林也用于治疗强迫症。疗效满意后，继续服用舍曲林可有效地防止强迫症初始症状的复发。</td></tr>
<tr><td style="text-align: center">阿戈美拉汀片 (维度新)</td><td>治疗成人抑郁症。br/&gt;br/&gt;本品适用于成人。</td></tr>
<tr><td style="text-align: center">盐酸度洛西汀肠溶胶囊 (欣百达)</td><td>用于治疗抑郁症；br/&gt;br/&gt;用于治疗广泛性焦虑障碍。</td></tr>
<tr><td style="text-align: center">盐酸帕罗西汀肠溶缓释片 (赛乐特)</td><td>用于治疗成人抑郁症。 在两项对符合美国精神障碍诊断统计手册（第四版）标准的抑郁症门诊患者进行的 12 周对照临床试验中，确立了盐酸帕罗西汀肠溶缓释片治疗抑郁症发作的有效性。尚未充分研究帕罗西汀对住院抑郁患者的抗抑郁作用。尚未在对照临床试验中对帕罗西汀肠溶缓释片超过 12 周的疗效安全性进行系统的评价；可是，在对照临床试验中证实了帕罗西汀速释片对抑郁症患者的长达 1 年维持治疗的有效性（参见【临床试验】）。 医生如果选择帕罗西汀肠溶缓释片进行长期治疗，应该定期对药物用于个体患者的长期有效性进行再评估。</td></tr>
<tr><td style="text-align: center">盐酸氟西汀胶囊 (艾旭)</td><td>各种抑郁性精神障碍、包括轻性或重性抑郁症、双相情感性精神障碍的抑郁症，心因性抑郁及抑郁性神经症。</td></tr>
<tr><td style="text-align: center">米氮平口腔崩解片 (瑞美隆®)</td><td>抑郁症的发作。对症状如快感缺乏，精神运动性抑制，睡眠欠佳（早醒），以及体重减轻均有疗效。也可用于其它症状如：对事物丧失兴趣，自杀念头以及情绪波动（早上好，晚上差）。本药在用药 1-2 周后起效。</td></tr>
<tr><td style="text-align: center">盐酸文拉法辛胶囊 (博乐欣)</td><td>抑郁症。</td></tr>
<tr><td style="text-align: center">盐酸多塞平片 (多虑平片)</td><td>用于治疗抑郁症及焦虑性神经症。</td></tr>
<tr><td style="text-align: center">氢溴酸西酞普兰片 (氢溴酸西酞普兰片)</td><td>各种类型的抑郁症。</td></tr>
<tr><td style="text-align: center">米氮平片 (瑞美隆)</td><td>用于抑郁症的治疗。</td></tr>
<tr><td style="text-align: center">盐酸帕罗西汀片 (乐友)</td><td>治疗各种类型的抑郁症。包括伴有焦虑的抑郁症及反应性抑郁症。常见的抑郁症状：乏力，睡眠障碍，对日常活动缺乏兴趣和愉悦感，食欲减退。治疗强迫性神经症。常见的强迫症状：感受反复和持续的可引起明显焦虑的思想、冲动或想象，从而导致重复的行为或心理活动。治疗伴有或不伴有广场恐怖的惊恐障碍。常见的惊恐发作症状：心悸，出汗，气短，胸痛，恶心，麻刺感和濒死感。治疗社交恐怖症/社交焦虑症。常见的社交焦虑的症状：心悸，出汗，气短等。通常表现为继发于显著或持续的对一个或多个社交情景或表演场合的畏惧，从而导致回避。治疗疗效满意后，继续服用本品可防止抑郁症、惊恐障碍和强迫症的复发。</td></tr>
<tr><td style="text-align: center">米氮平片 (派迪生)</td><td>抑郁症。</td></tr>
<tr><td style="text-align: center">氢溴酸西酞普兰片 (喜普妙)</td><td>治疗抑郁症。</td></tr>
<tr><td style="text-align: center">草酸艾司西酞普兰片 (百适可)</td><td>治疗抑郁症。治疗伴有或不伴有广场恐怖症的惊恐障碍。</td></tr>
<tr><td style="text-align: center">盐酸帕罗西汀片 (舒坦罗)</td><td>本品用于治疗抑郁症、强迫症、伴有或不伴有广场恐怖的惊恐障碍、社交恐怖症/社交焦虑症。 疗效满意后，继续服用本品可防止抑郁症、惊恐障碍和强迫症的复发。</td></tr>
<tr><td style="text-align: center">盐酸度洛西汀肠溶片 (奥思平)</td><td>用于治疗抑郁症。</td></tr>
<tr><td style="text-align: center">盐酸氟西汀胶囊 (优克)</td><td>各种抑郁性精神障碍，包括轻性或重性抑郁症、双相情感性精神障碍的抑郁症，心因性抑郁及抑郁性神经症。 中度至重度抑郁发作：8 岁及以上的儿童和青少年强迫症：7 岁及以上的儿童和青少年</td></tr>
<tr><td style="text-align: center">盐酸氟西汀片 (开克)</td><td>各种抑郁性精神障碍。包括轻性或重性抑郁症,双相情感性精神障碍的抑郁相,心因性抑郁及抑郁性神经症。 中度至重度抑郁发作：8 岁及以上的儿童和青少年强迫症：7 岁及以上的儿童和青少年</td></tr>
<tr><td style="text-align: center">吗氯贝胺片 (吗氯贝胺片)</td><td>抑郁症。</td></tr>
<tr><td style="text-align: center">舒必利片 (舒必利片)</td><td>对淡漠、退缩、木僵、抑郁、幻觉和妄想症状的效果较好，适用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕</td></tr>
<tr><td style="text-align: center">盐酸氟西汀胶囊 (奥麦伦)</td><td>各种抑郁性精神障碍、包括轻性或重性抑郁症、双相情感性精神障碍的抑郁症，心因性抑郁及抑郁性神经症。 中度至重度抑郁发作：8 岁及以上的儿童和青少年强迫症：7 岁及以上的儿童和青少年</td></tr>
<tr><td style="text-align: center">舒必利片 (舒必利片)</td><td>对淡漠、退缩、木僵、抑郁、幻觉和妄想症状的效果较好，适用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr>
<tr><td style="text-align: center">盐酸氟西汀胶囊 (百优解)</td><td>抑郁症; 强迫症; 神经性贪食症：作为心理治疗的辅助用药，以减少贪食和导泻行为。</td></tr>
<tr><td style="text-align: center">舒必利片 (舒必利片)</td><td>对淡漠、退缩、木僵、抑郁、幻觉和妄想症状的效果较好，适用于精神分裂症单纯型、偏执型、紧张型及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其它用途有止呕。</td></tr>
<tr><td style="text-align: center">盐酸阿米替林片 (盐酸阿米替林片)</td><td>用于治疗各种抑郁症，本品的镇静作用较强，主要用于治疗焦虑性或激动性抑郁症。</td></tr>
<tr><td style="text-align: center">盐酸舍曲林片 (快五优)</td><td>盐酸舍曲林用于治疗抑郁症的相关症状.包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用盐酸舍曲林可有效地防止抑郁症的复发和再发。盐酸舍曲林也用于治疗强迫症，初始治疗有反应后，盐酸舍曲林在治疗强迫症二年的时间内、仍保持它的有效性，安全性和耐受性。</td></tr>
<tr><td style="text-align: center">盐酸氟西汀肠溶片 (金开克)</td><td>本品适用于抑郁症缓解期，用于巩固期治疗和维持期疗效。</td></tr>
<tr><td style="text-align: center">盐酸马普替林片 (路滴美)</td><td>抑郁症内源性抑郁症，迟发性抑郁症（更年期性抑郁症）。精神性抑郁症，反应性和神经性抑郁症、耗竭性抑郁症。</td></tr>
<tr><td style="text-align: center">卡马西平片 (卡马西平片)</td><td>复杂部分性发作 (亦称精神运动性发作或颞叶癫癎)、全身强直 - 阵孪性发作、上述两种混合性发作或其他部分性或全身性发作；对典型或不典型失神发作、肌阵孪或失神张力发作无效。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。预防或治疗躁狂 - 抑郁症；对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。对某些精神疾病包括精神分裂症性情感性疾病，顽固性精神分裂症及与边缘系统功能障碍有关的失控综合征。不宁腿综合征 (Ekbom 综合征)，偏侧面肌痉孪。酒精癖的戒断综合征。</td></tr>
<tr><td style="text-align: center">盐酸多塞平片 (盐酸多塞平片)</td><td>用于治疗抑郁症及焦虑性神经症。</td></tr>
<tr><td style="text-align: center">舒必利片 (舒必利片)</td><td>对淡漠、退缩、木僵、抑郁、幻觉和妄想症状的效果较好，适用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr>
<tr><td style="text-align: center">甲磺酸瑞波西汀胶囊 (甲磺酸瑞波西汀胶囊)</td><td>用于治疗成人抑郁症。</td></tr>
<tr><td style="text-align: center">氯普噻吨片 (氯普噻吨片)</td><td>用于急性和慢性精神分裂症，适用于伴有精神运动性激越、焦虑、抑郁症状的精神障碍。</td></tr>
<tr><td style="text-align: center">盐酸甲氯芬酯胶囊 (特维知®)</td><td>用于改善脑出血、脑手术、脑外伤、脑动脉硬化等引起的意识障碍。亦可用于老年性痴呆、慢性记忆障碍、抑郁症、小儿智力发育迟钝及小儿遗尿症等。</td></tr>
<tr><td style="text-align: center">卡马西平片 (卡马西平片)</td><td>1、癫痫：部分性发作：复杂部分性发作。全身性发作：强直、阵挛、强直阵挛发作。 2、三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 3、预防或治疗躁狂 - 抑郁症；对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。 4、中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 5、酒精癖的戒断综合征。</td></tr>
<tr><td style="text-align: center">阿戈美拉汀片 (阿美宁)</td><td>治疗成人抑郁症。本品适用于成人。</td></tr>
<tr><td style="text-align: center">盐酸米安色林片 (盐酸米安色林片)</td><td>适用于药物治疗的各型抑郁症患者，能解除其抑郁症状。</td></tr>
<tr><td style="text-align: center">盐酸氯米帕明注射液 (氯丙米嗪)</td><td>用于治疗严重抑郁症及难治性抑郁症。</td></tr>
<tr><td style="text-align: center">盐酸安非他酮片 (乐孚亭)</td><td>用于治疗抑郁症。</td></tr>
<tr><td style="text-align: center">甲磺酸瑞波西汀片 (甲磺酸瑞波西汀片)</td><td>用于治疗成人抑郁症。</td></tr>
<tr><td style="text-align: center">盐酸文拉法辛缓释片 (盐酸文拉法辛缓释片)</td><td>本品适用于治疗各种类型抑郁症（包括伴有焦虑的抑郁症）及广泛性焦虑症。</td></tr>
<tr><td style="text-align: center">甲磺酸瑞波西汀片 (佐乐辛)</td><td>用于治疗成人抑郁症。</td></tr>
<tr><td style="text-align: center">盐酸舍曲林片 (唯他停)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。</td></tr>
<tr><td style="text-align: center">米氮平片 (米尔宁)</td><td>用于抑郁症的治疗。</td></tr>
<tr><td style="text-align: center">氢溴酸西酞普兰片 (迈克伟)</td><td>各种类型的抑郁症。</td></tr>
<tr><td style="text-align: center">卡马西平片 (卡马西平片)</td><td>1．癫痫： （1）部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。 （2）全身性发作：强直、阵挛、强直阵挛发作。 2．三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。3．预防或治疗躁狂 - 抑郁症：对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。 4．中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 5．酒精癖的戒断综合征。</td></tr>
<tr><td style="text-align: center">匹莫林片 (匹莫林片)</td><td>用于治疗儿童多动症、轻度抑郁症及发作性睡病。也可用于遗传性过敏性皮炎。</td></tr>
<tr><td style="text-align: center">莫达非尼片 (莫达非尼片)</td><td>抑郁症患者。特发性嗜睡或发作性睡眠症</td></tr>
<tr><td style="text-align: center">盐酸多塞平片 (盐酸多塞平片)</td><td>用于治疗抑郁症及焦虑性神经症。</td></tr>
<tr><td style="text-align: center">盐酸多塞平片 (盐酸多塞平片)</td><td>用于治疗抑郁症及焦虑性神经症。</td></tr>
<tr><td style="text-align: center">盐酸舍曲林片 (乐元)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr>
<tr><td style="text-align: center">盐酸舍曲林片 (西同静)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr>
<tr><td style="text-align: center">盐酸多塞平片 (盐酸多塞平片)</td><td>用于治疗抑郁症及焦虑性神经症。</td></tr>
<tr><td style="text-align: center">马来酸氟伏沙明片 (瑞必乐)</td><td>抑郁症及相关症状的治疗 ；强迫症症状的治疗。</td></tr>
<tr><td style="text-align: center">氯普噻吨片 (氯普噻吨片)</td><td>用于急性和慢性精神分裂症，适用于伴有精神运动性激越、焦虑、抑郁症状的精神障碍。</td></tr>
<tr><td style="text-align: center">阿普唑仑胶囊 (阿普唑仑胶囊)</td><td>催眠镇静药。适用于治疗焦虑症、抑郁症、失眠、恐惧。</td></tr>
<tr><td style="text-align: center">舒必利片 (舒必利片)</td><td>用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr>
<tr><td style="text-align: center">碳酸锂缓释片 (碳酸锂缓释片)</td><td>主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂 - 情感性精神病。</td></tr>
<tr><td style="text-align: center">碳酸锂片 (碳酸锂片)</td><td>主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂 - 情感性精神病。</td></tr>
<tr><td style="text-align: center">氯普噻吨片 (氯普噻吨片)</td><td>用于急性和慢性精神分裂症，适用于伴有精神运动性激越、焦虑、抑郁症状的精神障碍。</td></tr>
<tr><td style="text-align: center">舒必利片 (舒必利片)</td><td>用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr>
<tr><td style="text-align: center">舒必利片 (舒必利片)</td><td>用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr>
<tr><td style="text-align: center">舒必利片 (舒必利片)</td><td>用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr>
<tr><td style="text-align: center">舒必利片 (舒必利片)</td><td>用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr>
<tr><td style="text-align: center">舒必利片 (舒必利片)</td><td>适用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr>
<tr><td style="text-align: center">舒必利片 (舒必利片)</td><td>用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr>
<tr><td style="text-align: center">舒必利片 (舒必利片)</td><td>对淡漠、退缩、木僵、抑郁、幻觉和妄想症状的效果较好，适用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr>
<tr><td style="text-align: center">碳酸锂片 (碳酸锂片)</td><td>主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂 - 情感性精神病。</td></tr>
<tr><td style="text-align: center">碳酸锂片 (碳酸锂片)</td><td>主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂 - 情感性精神病。</td></tr>
<tr><td style="text-align: center">卡马西平片 (卡马西平片)</td><td>（1）癫癎：部分性发作，复杂部分性发作，简单部分性发作和继发性全身发作，全身性发作，全身性发作，强直、阵挛、强直阵挛发作。 （2）三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 （3）预防或治疗躁狂 - 抑郁症；对锂或抗精神病药、抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。 （4）中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 （5）酒精癖的戒断综合征。</td></tr>
<tr><td style="text-align: center">卡马西平片 (卡马西平片)</td><td>癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。 全身性发作：强直、阵挛、强直阵挛发作。 三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 预防或治疗躁狂一抑郁症：对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂一抑郁症，可单用或与锂盐和其它抗抑郁药合用。 中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 酒精癖的戒断综合征。</td></tr>
<tr><td style="text-align: center">卡马西平片 (卡马西平片)</td><td>癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。 三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 预防或治疗躁狂 - 抑郁症：对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。 中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 酒精癖的戒断综合征。</td></tr>
<tr><td style="text-align: center">卡马西平片 (宁新宝)</td><td>（1）癫痫：部分性发作：复杂部分性发作、简单部分发作和继发性全身发作。全身性发作：强直、阵挛、强制性挛发作。 （2）三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 （3）预防或治疗躁狂 - 抑郁症：对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。 （4）中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 （5）酒精癖的戒断综合征。</td></tr>
<tr><td style="text-align: center">卡马西平片 (卡马西平片)</td><td>1.癫痫。部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。 2.三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 3.预防或治疗躁狂 - 抑郁症：对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。 4.中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 5.酒精癖的戒断综合征。</td></tr>
<tr><td style="text-align: center">卡马西平片 (卡马西平片)</td><td>1.癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。 2.三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 3.预防或治疗躁狂 - 抑郁症；对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。 4.中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 5.酒精癖的戒断综合征。</td></tr>
<tr><td style="text-align: center">舒必利片 (舒必利片)</td><td>对淡漠、退缩、木僵、抑郁、幻觉和妄想症状的效果较好，适用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr>
<tr><td style="text-align: center">卡马西平胶囊 (卡马西平胶囊)</td><td>复杂部分性发作 (亦称精神运动性发作或颞叶癫痫)、全身强直 - 阵孪性发作、上述两种混合性发作或其他部分性或全身性发作；对典型或不典型失神发作、肌阵孪或失神张力发作无效。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。预防或治疗躁狂 - 抑郁症；对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。 中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 对某些精神疾病包括精神分裂症性情感性疾病，顽固性精神分裂症及与边缘系统功能障碍有关的失控综合征。 不宁腿综合症（Ekbom 综合征），偏侧面肌痉孪。 酒精癖的戒断综合征。</td></tr>
<tr><td style="text-align: center">卡马西平片 (卡马西平片)</td><td>（1）复杂部分性发作（亦称精神运动性发作或颞叶癫痫）、全身强直 - 阵孪性发作、上述两种混合性发作或其他部分性或全身性发作；对典型或不典型失神发作、肌阵孪或失神张力发作无效。 （2）三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 （3）预防或治疗躁狂 - 抑郁症；对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。 （4）中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 （5）对某些精神疾病包括精神分裂症性情感性疾病，顽固性精神分裂症及与边缘系统功能障碍有关的失控综合征。 （6）不宁腿综合征（Ekbom 综合征），偏侧面肌痉孪。 （7）酒精癖的戒断综合征。</td></tr>
<tr><td style="text-align: center">卡马西平片 (卡马西平片)</td><td>复杂部分性发作（亦称精神运动性发作或颞叶癫癎）、全身强直 - 阵孪性发作、上述两种混合性发作或其他部分性或全身性发作；对典型或不典型失神发作、肌阵孪或失神张力发作无效。 三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 预防或治疗躁狂 - 抑郁症；对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。 中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 对某些精神疾病包括精神分裂症性情感性疾病，顽固性精神分裂症及与边缘系统功能障碍有关的失控综合征。 不宁腿综合征（Ekbom 综合征），偏侧面肌痉挛。 酒精癖的戒断综合征。</td></tr>
<tr><td style="text-align: center">卡马西平片 (卡马西平片)</td><td>复杂部分性发作（亦称精神运动性发作或颞叶癫痫）、全身强直 - 阵孪性发作、上述两种混合性发作或其他部分性或全身性发作；对典型或不典型失神发作、肌阵孪或失神张力发作无效。 三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。 预防或治疗躁狂 - 抑郁症：对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。 中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。 对某些精神疾病包括精神分裂症性情感性疾病，顽固性精神分裂症及与边缘系统功能障碍有关的失控综合征。 不宁腿综合征（Ekbom 综合征），偏侧面肌痉孪。 酒精癖的戒断综合征。</td></tr>
<tr><td style="text-align: center">盐酸舍曲林分散片 (盐酸舍曲林分散片)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑，有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用治疗强迫症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。</td></tr>
<tr><td style="text-align: center">吗氯贝胺片 (恬泰)</td><td>抑郁症。</td></tr>
<tr><td style="text-align: center">吗氯贝胺片 (亚正)</td><td>抑郁症</td></tr>
<tr><td style="text-align: center">米氮平片 (派迪生)</td><td>抑郁症。</td></tr>
<tr><td style="text-align: center">吗氯贝胺胶囊 (贝苏)</td><td>抑郁症。</td></tr>
<tr><td style="text-align: center">盐酸氯米帕明注射液 (盐酸氯米帕明注射液)</td><td>用于治疗严重抑郁症及难治性抑郁症。</td></tr>
<tr><td style="text-align: center">盐酸米那普仑片 (盐酸米那普仑片)</td><td>治疗抑郁症。</td></tr>
<tr><td style="text-align: center">氢溴酸西酞普兰胶囊 (多弗)</td><td>治疗抑郁症。</td></tr>
<tr><td style="text-align: center">氢溴酸西酞普兰片 (一泰纳)</td><td>治疗抑郁症。</td></tr>
<tr><td style="text-align: center">氢溴酸西酞普兰口服溶液 (氢溴酸西酞普兰口服溶液)</td><td>各种类型的抑郁症。</td></tr>
<tr><td style="text-align: center">盐酸安非他酮缓释片 (盐酸安非他酮缓释片)</td><td>用于治疗抑郁症。</td></tr>
<tr><td style="text-align: center">盐酸安非他酮片 (盐酸安非他酮片)</td><td>用于治疗抑郁症。</td></tr>
<tr><td style="text-align: center">氢溴酸西酞普兰片 (望悠)</td><td>各种类型的抑郁症。</td></tr>
<tr><td style="text-align: center">氢溴酸西酞普兰片 (氢溴酸西酞普兰片)</td><td>各种类型的抑郁症。</td></tr>
<tr><td style="text-align: center">盐酸安非他酮缓释片 (盐酸安非他酮缓释片)</td><td>用于治疗抑郁症。</td></tr>
<tr><td style="text-align: center">盐酸安非他酮缓释片 (盐酸安非他酮缓释片)</td><td>用于治疗抑郁症。</td></tr>
<tr><td style="text-align: center">氢溴酸西酞普兰片 (优乐喜)</td><td>各种类型的抑郁症。</td></tr>
<tr><td style="text-align: center">氢溴酸西酞普兰片 (易特安)</td><td>各种类型的抑郁症。</td></tr>
<tr><td style="text-align: center">盐酸氟西汀胶囊 (聚立能)</td><td>用于各种抑郁症的治疗。</td></tr>
<tr><td style="text-align: center">盐酸安非他酮缓释片 (宏发)</td><td>用于治疗抑郁症。</td></tr>
<tr><td style="text-align: center">盐酸安非他酮片 (盐酸安非他酮片)</td><td>用于治疗抑郁症。</td></tr>
<tr><td style="text-align: center">盐酸度洛西汀肠溶胶囊 (奥思平)</td><td>用于治疗抑郁症。</td></tr>
<tr><td style="text-align: center">氢溴酸西酞普兰口服溶液 (氢溴酸西酞普兰口服溶液)</td><td>各种类型的抑郁症。</td></tr>
<tr><td style="text-align: center">米氮平片 (米尔宁®)</td><td>用于治疗抑郁症。</td></tr>
<tr><td style="text-align: center">氢溴酸西酞普兰片 (望悠)</td><td>各种类型的抑郁症。</td></tr>
<tr><td style="text-align: center">氢溴酸西酞普兰片 (氢溴酸西酞普兰片)</td><td>各种类型的抑郁症。</td></tr>
<tr><td style="text-align: center">米氮平片 (米氮平片)</td><td>用于抑郁症的治疗。</td></tr>
<tr><td style="text-align: center">草酸艾司西酞普兰 (草酸艾司西酞普兰)</td><td>治疗抑郁障碍</td></tr>
<tr><td style="text-align: center">盐酸安非他酮缓释片 (盐酸安非他酮缓释片)</td><td>用于治疗抑郁症。</td></tr>
<tr><td style="text-align: center">氢溴酸西酞普兰片 (特林那)</td><td>各种类型的抑郁症。</td></tr>
<tr><td style="text-align: center">盐酸度洛西汀肠溶胶囊 (奥思平)</td><td>用于治疗抑郁症。</td></tr>
<tr><td style="text-align: center">甲磺酸瑞波西汀片 (叶洛抒)</td><td>用于治疗成人抑郁症。</td></tr>
<tr><td style="text-align: center">噻奈普汀钠片 (达体朗)</td><td>抑郁发作（即典型性）</td></tr>
<tr><td style="text-align: center">盐酸舍曲林片 (盐酸舍曲林片)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。 舍曲林也用于治疗强迫症。疗效满意后，继续服用舍曲林可有效地防止强迫症初始症状的复发。</td></tr>
<tr><td style="text-align: center">盐酸文拉法辛胶囊 (盐酸文拉法辛胶囊)</td><td>适用于各种类型抑郁症。</td></tr>
<tr><td style="text-align: center">盐酸文拉法辛胶囊 (盐酸文拉法辛胶囊)</td><td>适用于各种类型抑郁症。</td></tr>
<tr><td style="text-align: center">盐酸文拉法辛胶囊 (盐酸文拉法辛胶囊)</td><td>适用于各种类型抑郁症。</td></tr>
<tr><td style="text-align: center">噻奈普汀片 (达体朗)</td><td>抑郁发作 (即典型性)。</td></tr>
<tr><td style="text-align: center">盐酸文拉法辛胶囊 (盐酸文拉法辛胶囊)</td><td>适用于治疗各种类型抑郁症。</td></tr>
<tr><td style="text-align: center">盐酸文拉法辛胶囊 (盐酸文拉法辛胶囊)</td><td>适用于各种类型抑郁症</td></tr>
<tr><td style="text-align: center">盐酸文拉法辛胶囊 (盐酸文拉法辛胶囊)</td><td>适用于各种类型抑郁症。</td></tr>
<tr><td style="text-align: center">盐酸文拉法辛胶囊 (盐酸文拉法辛胶囊)</td><td>适用于各种类型抑郁症</td></tr>
<tr><td style="text-align: center">盐酸文拉法辛片 (盐酸文拉法辛片)</td><td>适用于治疗各种类型抑郁症。</td></tr>
<tr><td style="text-align: center">吗氯贝胺片 (吗氯贝胺片)</td><td>本品用于治疗抑郁症。</td></tr>
<tr><td style="text-align: center">盐酸安非他酮缓释片 (Ⅱ)(盐酸安非他酮缓释片 (Ⅱ))</td><td>本品用于治疗抑郁症。</td></tr>
<tr><td style="text-align: center">盐酸文拉法辛胶囊 (盐酸文拉法辛胶囊)</td><td>适用于治疗各种类型抑郁症。</td></tr>
<tr><td style="text-align: center">氢溴酸伏硫西汀片 (心达悦 Brintellix)</td><td>本品用于治疗成人抑郁症。</td></tr>
<tr><td style="text-align: center">盐酸舍曲林胶囊 (联环优定)</td><td>舍曲林用于治疗 a class='J-redirect' data-type='18' data-id='127' field-id='2325'&gt;抑郁症/a&gt;的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。br/&gt;br/&gt;舍曲林也用于治疗 a class='J-redirect' data-type='18' data-id='129' field-id='2329'&gt;强迫症/a&gt;，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr>
<tr><td style="text-align: center">盐酸舍曲林胶囊 (盐酸舍曲林胶囊)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。br/&gt;br/&gt;舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr>
<tr><td style="text-align: center">盐酸文拉法辛片 (盐酸文拉法辛片)</td><td>适用于治疗各种类型抑郁症。</td></tr>
<tr><td style="text-align: center">盐酸舍曲林胶囊 (愈朗)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。 疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。 舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr>
<tr><td style="text-align: center">盐酸舍曲林胶囊 (郁洛欣)</td><td>​舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr>
<tr><td style="text-align: center">盐酸舍曲林分散片 (盐酸舍曲林分散片)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr>
<tr><td style="text-align: center">盐酸舍曲林片 (盐酸舍曲林片)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr>
<tr><td style="text-align: center">盐酸舍曲林片 (盐酸舍曲林片)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。 舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr>
<tr><td style="text-align: center">盐酸文拉法辛胶囊 (盐酸文拉法辛胶囊)</td><td>适用于治疗各种类型抑郁症。</td></tr>
<tr><td style="text-align: center">盐酸舍曲林片 (申安)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr>
<tr><td style="text-align: center">盐酸舍曲林片 (贝玉)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr>
<tr><td style="text-align: center">盐酸舍曲林片 (盐酸舍曲林片)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性，安全性和耐受性。</td></tr>
<tr><td style="text-align: center">盐酸多塞平片 (盐酸多塞平片)</td><td>用于治疗抑郁症及焦虑性神经症。</td></tr>
<tr><td style="text-align: center">盐酸舍曲林胶囊 (盐酸舍曲林胶囊)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr>
<tr><td style="text-align: center">盐酸舍曲林胶囊 (盐酸舍曲林胶囊)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr>
<tr><td style="text-align: center">盐酸舍曲林片 (盐酸舍曲林片)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr>
<tr><td style="text-align: center">盐酸舍曲林片 (彼迈乐)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr>
<tr><td style="text-align: center">盐酸舍曲林片 (应思调)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr>
<tr><td style="text-align: center">盐酸舍曲林片 (伊素明)</td><td>舍曲林用于治疗抑郁症的相关症状，包括伴随焦虑、有或无躁狂史的抑郁症。疗效满意后，继续服用舍曲林可有效地防止抑郁症的复发和再发。舍曲林也用于治疗强迫症，初始治疗有反应后，舍曲林在治疗强迫症二年的时间内，仍保持它的有效性、安全性和耐受性。</td></tr>
<tr><td style="text-align: center">盐酸多塞平片 (天平)</td><td>用于治疗抑郁症及焦虑性神经症。</td></tr>
<tr><td style="text-align: center">盐酸多塞平片 (盐酸多塞平片)</td><td>用于治疗抑郁症及焦虑性神经症。</td></tr>
<tr><td style="text-align: center">盐酸多塞平片 (盐酸多塞平片)</td><td>用于治疗抑郁症及焦虑性神经症。</td></tr>
<tr><td style="text-align: center">盐酸多塞平片 (盐酸多塞平片)</td><td>用于治疗抑郁症及焦虑性神经症。</td></tr>
<tr><td style="text-align: center">盐酸曲唑酮片 (舒绪)</td><td>本品适用于抑郁症的治疗，对伴有或不伴有焦虑的患者均有效。</td></tr>
<tr><td style="text-align: center">盐酸曲唑酮片 (宏发)</td><td>本品适用于抑郁症的治疗，对伴有或不伴有焦虑的患者均有效。</td></tr>
<tr><td style="text-align: center">盐酸氟西汀分散片 (盐酸氟西汀分散片)</td><td>抑郁症、强迫症、神经性贪食症：作为心理治疗的辅助用药，以减少贪食和导泻行为。 中度至重度抑郁发作：8 岁及以上的儿童和青少年强迫症：7 岁及以上的儿童和青少年</td></tr>
<tr><td style="text-align: center">盐酸马普替林片 (盐酸马普替林片)</td><td>用于各型抑郁症。对精神分裂症后抑郁也有效。</td></tr>
<tr><td style="text-align: center">盐酸安非他酮缓释片 (盐酸安非他酮缓释片)</td><td>1、用于治疗抑郁症。2、用于辅助戒烟。</td></tr>
<tr><td style="text-align: center">盐酸氟西汀分散片 (盐酸氟西汀分散片)</td><td>抑郁症; 强迫症; 神经性贪食症：作为心理治疗的辅助用药，以减少贪食和导泻行为。 中度至重度抑郁发作：8 岁及以上的儿童和青少年强迫症：7 岁及以上的儿童和青少年</td></tr>
<tr><td style="text-align: center">盐酸马普替林片 (盐酸马普替林片)</td><td>用于各型抑郁症。对精神分裂症后抑郁也有效。</td></tr>
<tr><td style="text-align: center">草酸艾司西酞普兰片 (百洛特)</td><td>治疗抑郁症。治疗伴有或不伴有广场恐怖症的惊恐障碍。</td></tr>
<tr><td style="text-align: center">盐酸曲唑酮片 (舒绪)</td><td>本品适用于抑郁症的治疗，对伴有或不伴有焦虑的患者均有效。</td></tr>
<tr><td style="text-align: center">盐酸帕罗西汀片 (盐酸帕罗西汀片)</td><td>治疗各种类型的抑郁症，包括伴有焦虑的抑郁症及反应性抑郁症。常见的抑郁症状：乏力、睡眠障碍、对日常活动缺乏兴趣和愉悦感、食欲减退。治疗强迫性神经症。常见的强迫症状：感受反复和持续的可引起明显焦虑的思想、冲动或想象，从而导致重复的行为或心理活动。治疗伴有或不伴有广场恐怖的惊恐障碍。常见的惊恐发作症状：心悸、出汗、气短、胸痛、恶心、麻刺感和濒死感。治疗社交恐怖症/社交焦虑症。常见的社交焦虑的症状：心悸、出汗、气短等。通常表现为继发于显著或持续的对一个或多个社交情景或表演场合的畏惧，从而导致回避。治疗疗效满意后，继续服用本品可防止抑郁症、惊恐障碍和强迫症的复发。</td></tr>
<tr><td style="text-align: center">盐酸马普替林片 (盐酸马普替林片)</td><td>用于各型抑郁症。对精神分裂症后抑郁也有效。</td></tr>
<tr><td style="text-align: center">草酸艾司西酞普兰片 (草酸艾司西酞普兰片)</td><td>治疗抑郁症。治疗伴有或不伴有广场恐怖症的惊恐障碍。</td></tr>
<tr><td style="text-align: center">盐酸度洛西汀肠溶胶囊 (盐酸度洛西汀肠溶胶囊)</td><td>用于治疗抑郁症；用于治疗广泛性焦虑障碍。</td></tr>
<tr><td style="text-align: center">盐酸度洛西汀肠溶胶囊 (盐酸度洛西汀肠溶胶囊)</td><td>抑郁症；广泛性焦虑障碍；慢性肌肉骨骼疼痛。</td></tr>
<tr><td style="text-align: center">富马酸喹硫平缓释片 (富马酸喹硫平缓释片)</td><td>本品用于治疗精神分裂症和双相情感障碍的抑郁发作。</td></tr>
<tr><td style="text-align: center">盐酸帕罗西汀片 (盐酸帕罗西汀片)</td><td>治疗各种类型的抑郁症，包括伴有焦虑的抑郁症及反应性抑郁症。常见的抑郁症状：乏力、睡眠障碍、对日常活动缺乏兴趣和愉悦感、食欲减退。治疗强迫性神经症。常见的强迫症状：感受反复和持续的可引起明显焦虑的思想、冲动或想象、从而导致重复的行为或心理活动。治疗伴有或不伴有广场恐怖的惊恐障碍。常见的惊恐发作症状：心悸、出汗、气短、胸痛、恶心、麻刺感和濒死感。治疗社交恐怖症/社交焦虑症。常见的社交焦虑的症状：心悸、出汗、气短等。通常表现为继发于显著或持续的对一个或多个社交情景或表演场合的畏惧，从而导致回避。治疗疗效满意后，继续服用本品可防止抑郁症、惊恐障碍和强迫症的复发。</td></tr>
<tr><td style="text-align: center">草酸艾司西酞普兰片 (草酸艾司西酞普兰片)</td><td>治疗抑郁障碍，治疗伴有或不伴有广场恐怖症的惊恐障碍。</td></tr>
<tr><td style="text-align: center">草酸艾司西酞普兰片 (草酸艾司西酞普兰片)</td><td>治疗抑郁障碍，治疗伴有或不伴有广场恐怖症的惊恐障碍。</td></tr>
<tr><td style="text-align: center">草酸艾司西酞普兰片 (草酸艾司西酞普兰片)</td><td>治疗抑郁障碍，治疗伴有或不伴有广场恐怖症的惊恐障碍。</td></tr>
<tr><td style="text-align: center">盐酸氟西汀胶囊 (盐酸氟西汀胶囊)</td><td>抑郁发作。强迫症。精神性贪食症：可作为心理治疗的补充，用于减少贪食和导泻行为。</td></tr>
<tr><td style="text-align: center">氯普噻吨片 (氯普噻吨片)</td><td>用于急性和慢性精神分裂症，适用于伴有精神运动性激越、焦虑、抑郁症状的精神障碍。</td></tr>
<tr><td style="text-align: center">氯普噻吨片 (氯普噻吨片)</td><td>用于急性和慢性精神分裂症，适用于伴有精神运动性激越、焦虑、抑郁症状的精神障碍。</td></tr>
<tr><td style="text-align: center">富马酸喹硫平缓释片 (思瑞康)</td><td>用于治疗精神分裂症。 用于双相情感障碍的抑郁发作。</td></tr>
<tr><td style="text-align: center">盐酸氯普噻吨注射液 (盐酸氯普噻吨注射液)</td><td>用于急性和慢性精神分裂症，适用于伴有精神运动性激越、焦虑、抑郁症状的精神障碍。</td></tr>
<tr><td style="text-align: center">盐酸帕罗西汀肠溶缓释片 (盐酸帕罗西汀肠溶缓释片)</td><td>用于治疗成人抑郁症。 在两项对符合美国精神障碍诊断统计手册（第四版）标准的抑郁症门诊患者进行的 12 周对照临床试验中，确立了盐酸帕罗西汀肠溶缓释片治疗抑郁症发作的有效性。尚未充分研究帕罗西汀对住院抑郁患者的抗抑郁作用。 尚未在对照临床试验中对帕罗西汀肠溶缓释片超过 12 周的疗效安全性进行系统的评价；可是，在对照临床试验中证实了帕罗西汀速释片对抑郁症患者的长达 1 年维持治疗的有效性（参见【临床试验】）。医生如果选择帕罗西汀肠溶缓释片进行长期治疗，应该定期对药物用于个体患者的长期有效性进行再评估。</td></tr>
<tr><td style="text-align: center">富马酸喹硫平缓释片 (富马酸喹硫平缓释片)</td><td>本品用于治疗精神分裂症和双相情感障碍的抑郁发作。</td></tr>
<tr><td style="text-align: center">舒必利片 (舒必利片)</td><td>用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr>
<tr><td style="text-align: center">舒必利片 (舒必利片)</td><td>用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其它用途有止呕。</td></tr>
<tr><td style="text-align: center">舒必利片 (舒必利片)</td><td>用于精神分裂症单纯型、偏执型、紧张型及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr>
<tr><td style="text-align: center">舒必利注射液 (舒必利注射液)</td><td>用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr>
<tr><td style="text-align: center">盐酸丙米嗪片 (盐酸丙米嗪片)</td><td>用于各种抑郁症。因具有振奋作用，适用于迟钝型抑郁，但不宜用于激越型抑郁或焦虑性抑郁。亦可用于小儿遗尿症。</td></tr>
<tr><td style="text-align: center">巴戟天寡糖胶囊 (巴戟天寡糖胶囊)</td><td>温补肾阳。用于轻中度抑郁症中医辨证属于肾阳虚证者，症见抑郁情绪、心绪低落、失眠多梦、疲倦乏力等。</td></tr>
<tr><td style="text-align: center">盐酸丙米嗪片 (盐酸丙米嗪片)</td><td>用于各种抑郁症。因具有振奋作用，适用于迟钝型抑郁，但不宜用于激越型抑郁或焦虑性抑郁。亦可用于小儿遗尿症。</td></tr>
<tr><td style="text-align: center">舒必利片 (舒必利片)</td><td>用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr>
<tr><td style="text-align: center">舒必利片 (舒必利片)</td><td>用于精神分裂症单纯型、偏执型、紧张型、及慢性精神分裂症的孤僻、退缩、淡漠症状。对抑郁症状有一定疗效。其他用途有止呕。</td></tr>
<tr><td style="text-align: center">盐酸氟西汀胶囊 (盐酸氟西汀胶囊)</td><td>抑郁症：盐酸氟西汀胶囊用于治疗抑郁症状，伴有或不伴有焦虑症状，尤其是不需要镇静作用时。 强迫症。 神经性贪食症：盐酸氟西汀胶囊用于减少贪食和导泻行为。 惊恐障碍：盐酸氟西汀胶囊用于治疗伴有或不伴有广场恐怖症的惊恐障碍。</td></tr>
<tr><td style="text-align: center">槟榔十三味丸 (槟榔十三味丸)</td><td>调节“赫依”。安神止痛。用于心悸，失眠，精神失常，游走刺痛。病名注释：“游走刺痛”：本方指类似于胁间神经痛。 “赫依”本方指失眠健忘、神经衰弱、抑郁症、神经官能症、更年期综合症等。</td></tr>
<tr><td style="text-align: center">卡马西平片 (卡马西平片)</td><td>癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多 发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛 以及疱疹后神经痛。预防或治疗躁狂 - 抑郁症；对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症，可单用或与氯磺丙脲或氯贝丁酯等合用。酒精癖的戒断综合征。</td></tr>
<tr><td style="text-align: center">碳酸锂片 (碳酸锂片)</td><td>主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂 - 情感性精神病。</td></tr>
<tr><td style="text-align: center">奥氮平片 (奥氮平片)</td><td>精神分裂症。双相情感障碍躁狂发作。双相情感障碍抑郁发作。奥氮平初始治疗有效的患者，可用于精神分裂症维持治疗和预防双相情感障碍复发。</td></tr>
<tr><td style="text-align: center">盐酸文拉法辛缓释胶囊 (盐酸文拉法辛缓释胶囊)</td><td>本品适用于各种类型抑郁症，包括伴有焦虑的抑郁症，及广泛性焦虑症。1. 各种类型抑郁症本品推荐用于治疗各种类型抑郁症。 本品治疗符合诊断与统计手册第三版 (修订版)(DSM-III-R) 或诊断与统计手册第四版 (DSM-IV) 诊断标准的门诊成年抑郁症患者的疗效已在 8 周和 12 周的对照研究中得到确定。 一次抑郁发作 (DSM-IV) 是指明显和相对持久 (在 2 周时间内的几乎每一天) 的抑郁情绪伴有对几乎所有活动兴趣减退和愉快感的缺失，与其平时的表现明显不同，同时在 2 周的时间内具有以下 9 项症状中的 5 项：抑郁情绪、日常活动中的明显兴趣减退和愉快感缺失、体重和食欲的明显变化、失眠或睡眠过多、精神运动性激越或迟滞、疲劳、自责自罪或无价值感、思维迟缓和注意力难以集中以及自杀意念和自杀行为。 2. 广泛性焦虑症 (GAD) 本品推荐用于治疗广泛性焦虑症患者。日常应激相关的焦虑和神经质一般不需要应用抗焦虑药。 在为期 8 周和 6 个月的安慰剂对照研究证实本品对符合 DSM-IV 诊断标准的 GAD 患者有效。 广泛性焦虑症 (DSM-IV) 是指维持至少 6 个月难以控制的过分焦虑和担心 (预期)。 至少具有以下 6 项症状中的 3 项：坐立不安和神经质、容易疲劳、难以集中注意力或头脑空白、易怒、肌肉震颤和睡眠障碍。 尽管为期 6 个月的临床研究证实本品对广泛性焦虑症患者有效，但当医生选择本品作为长期治疗时应该定期评估药物对患者的长期疗效 (见 [用法用量])。</td></tr>
<tr><td style="text-align: center">卡马西平片 (卡马西平片)</td><td>1、癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。br/&gt;br/&gt;2、三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。br/&gt;br/&gt;3、预防或治疗躁狂 - 抑郁症：对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其他抗抑郁药合用。br/&gt;br/&gt;4、中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。br/&gt;br/&gt;5、酒精癖的戒断综合征。</td></tr>
<tr><td style="text-align: center">盐酸甲氯芬酯胶囊 (盐酸甲氯芬酯胶囊)</td><td>用于改善脑出血、脑手术、脑外伤、脑动脉硬化等引起的意识障碍。亦可用于老年性痴呆、慢性记忆障碍、抑郁症、小儿智力发育迟钝及小儿遗尿症等。</td></tr>
<tr><td style="text-align: center">盐酸甲氯芬酯胶囊 (健瑙素)</td><td>用于改善脑出血、脑手术、脑外伤、脑动脉硬化等引起的意识障碍。亦可用于老年性痴呆、慢性记忆障碍、抑郁症、小儿智力发育迟钝及小儿遗尿症等。</td></tr>
<tr><td style="text-align: center">碳酸锂片 (碳酸锂片)</td><td>主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂 - 情感性精神病。</td></tr>
<tr><td style="text-align: center">卡马西平片 (卡马西平片)</td><td>癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。预防或治疗躁狂 - 抑郁症；对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。酒精癖的戒断综合征。</td></tr>
<tr><td style="text-align: center">槟榔十三味丸 (槟榔十三味丸)</td><td>调节“赫依”。安神止痛。用于心悸，失眠，精神失常，游走刺痛。病名注释：“游走刺痛”：本方指类似于胁间神经痛。 “赫依”本方指失眠健忘、神经衰弱、抑郁症、神经官能症、更年期综合症等。</td></tr>
<tr><td style="text-align: center">卡马西平片 (卡马西平片)</td><td>癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多 发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛 以及疱疹后神经痛。预防或治疗躁狂 - 抑郁症；对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症，可单用或与氯磺丙脲或氯贝丁酯等合用。酒精癖的戒断综合征。</td></tr>
<tr><td style="text-align: center">碳酸锂片 (碳酸锂片)</td><td>主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂 - 情感性精神病。</td></tr>
<tr><td style="text-align: center">奥氮平片 (奥氮平片)</td><td>精神分裂症。双相情感障碍躁狂发作。双相情感障碍抑郁发作。奥氮平初始治疗有效的患者，可用于精神分裂症维持治疗和预防双相情感障碍复发。</td></tr>
<tr><td style="text-align: center">盐酸文拉法辛缓释胶囊 (盐酸文拉法辛缓释胶囊)</td><td>本品适用于各种类型抑郁症，包括伴有焦虑的抑郁症，及广泛性焦虑症。1. 各种类型抑郁症本品推荐用于治疗各种类型抑郁症。 本品治疗符合诊断与统计手册第三版 (修订版)(DSM-III-R) 或诊断与统计手册第四版 (DSM-IV) 诊断标准的门诊成年抑郁症患者的疗效已在 8 周和 12 周的对照研究中得到确定。 一次抑郁发作 (DSM-IV) 是指明显和相对持久 (在 2 周时间内的几乎每一天) 的抑郁情绪伴有对几乎所有活动兴趣减退和愉快感的缺失，与其平时的表现明显不同，同时在 2 周的时间内具有以下 9 项症状中的 5 项：抑郁情绪、日常活动中的明显兴趣减退和愉快感缺失、体重和食欲的明显变化、失眠或睡眠过多、精神运动性激越或迟滞、疲劳、自责自罪或无价值感、思维迟缓和注意力难以集中以及自杀意念和自杀行为。 2. 广泛性焦虑症 (GAD) 本品推荐用于治疗广泛性焦虑症患者。日常应激相关的焦虑和神经质一般不需要应用抗焦虑药。 在为期 8 周和 6 个月的安慰剂对照研究证实本品对符合 DSM-IV 诊断标准的 GAD 患者有效。 广泛性焦虑症 (DSM-IV) 是指维持至少 6 个月难以控制的过分焦虑和担心 (预期)。 至少具有以下 6 项症状中的 3 项：坐立不安和神经质、容易疲劳、难以集中注意力或头脑空白、易怒、肌肉震颤和睡眠障碍。 尽管为期 6 个月的临床研究证实本品对广泛性焦虑症患者有效，但当医生选择本品作为长期治疗时应该定期评估药物对患者的长期疗效 (见 [用法用量])。</td></tr>
<tr><td style="text-align: center">卡马西平片 (卡马西平片)</td><td>1、癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。br/&gt;br/&gt;2、三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。br/&gt;br/&gt;3、预防或治疗躁狂 - 抑郁症：对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其他抗抑郁药合用。br/&gt;br/&gt;4、中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。br/&gt;br/&gt;5、酒精癖的戒断综合征。</td></tr>
<tr><td style="text-align: center">盐酸甲氯芬酯胶囊 (盐酸甲氯芬酯胶囊)</td><td>用于改善脑出血、脑手术、脑外伤、脑动脉硬化等引起的意识障碍。亦可用于老年性痴呆、慢性记忆障碍、抑郁症、小儿智力发育迟钝及小儿遗尿症等。</td></tr>
<tr><td style="text-align: center">盐酸甲氯芬酯胶囊 (健瑙素)</td><td>用于改善脑出血、脑手术、脑外伤、脑动脉硬化等引起的意识障碍。亦可用于老年性痴呆、慢性记忆障碍、抑郁症、小儿智力发育迟钝及小儿遗尿症等。</td></tr>
<tr><td style="text-align: center">碳酸锂片 (碳酸锂片)</td><td>主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂 - 情感性精神病。</td></tr>
<tr><td style="text-align: center">卡马西平片 (卡马西平片)</td><td>癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。预防或治疗躁狂 - 抑郁症；对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。酒精癖的戒断综合征。</td></tr>
<tr><td style="text-align: center">槟榔十三味丸 (槟榔十三味丸)</td><td>调节“赫依”。安神止痛。用于心悸，失眠，精神失常，游走刺痛。病名注释：“游走刺痛”：本方指类似于胁间神经痛。 “赫依”本方指失眠健忘、神经衰弱、抑郁症、神经官能症、更年期综合症等。</td></tr>
<tr><td style="text-align: center">卡马西平片 (卡马西平片)</td><td>癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多 发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛 以及疱疹后神经痛。预防或治疗躁狂 - 抑郁症；对锂或抗精神病药或抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症，可单用或与氯磺丙脲或氯贝丁酯等合用。酒精癖的戒断综合征。</td></tr>
<tr><td style="text-align: center">碳酸锂片 (碳酸锂片)</td><td>主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂 - 情感性精神病。</td></tr>
<tr><td style="text-align: center">奥氮平片 (奥氮平片)</td><td>精神分裂症。双相情感障碍躁狂发作。双相情感障碍抑郁发作。奥氮平初始治疗有效的患者，可用于精神分裂症维持治疗和预防双相情感障碍复发。</td></tr>
<tr><td style="text-align: center">盐酸文拉法辛缓释胶囊 (盐酸文拉法辛缓释胶囊)</td><td>本品适用于各种类型抑郁症，包括伴有焦虑的抑郁症，及广泛性焦虑症。1. 各种类型抑郁症本品推荐用于治疗各种类型抑郁症。 本品治疗符合诊断与统计手册第三版 (修订版)(DSM-III-R) 或诊断与统计手册第四版 (DSM-IV) 诊断标准的门诊成年抑郁症患者的疗效已在 8 周和 12 周的对照研究中得到确定。 一次抑郁发作 (DSM-IV) 是指明显和相对持久 (在 2 周时间内的几乎每一天) 的抑郁情绪伴有对几乎所有活动兴趣减退和愉快感的缺失，与其平时的表现明显不同，同时在 2 周的时间内具有以下 9 项症状中的 5 项：抑郁情绪、日常活动中的明显兴趣减退和愉快感缺失、体重和食欲的明显变化、失眠或睡眠过多、精神运动性激越或迟滞、疲劳、自责自罪或无价值感、思维迟缓和注意力难以集中以及自杀意念和自杀行为。 2. 广泛性焦虑症 (GAD) 本品推荐用于治疗广泛性焦虑症患者。日常应激相关的焦虑和神经质一般不需要应用抗焦虑药。 在为期 8 周和 6 个月的安慰剂对照研究证实本品对符合 DSM-IV 诊断标准的 GAD 患者有效。 广泛性焦虑症 (DSM-IV) 是指维持至少 6 个月难以控制的过分焦虑和担心 (预期)。 至少具有以下 6 项症状中的 3 项：坐立不安和神经质、容易疲劳、难以集中注意力或头脑空白、易怒、肌肉震颤和睡眠障碍。 尽管为期 6 个月的临床研究证实本品对广泛性焦虑症患者有效，但当医生选择本品作为长期治疗时应该定期评估药物对患者的长期疗效 (见 [用法用量])。</td></tr>
<tr><td style="text-align: center">卡马西平片 (卡马西平片)</td><td>1、癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。br/&gt;br/&gt;2、三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。br/&gt;br/&gt;3、预防或治疗躁狂 - 抑郁症：对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其他抗抑郁药合用。br/&gt;br/&gt;4、中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。br/&gt;br/&gt;5、酒精癖的戒断综合征。</td></tr>
<tr><td style="text-align: center">盐酸甲氯芬酯胶囊 (盐酸甲氯芬酯胶囊)</td><td>用于改善脑出血、脑手术、脑外伤、脑动脉硬化等引起的意识障碍。亦可用于老年性痴呆、慢性记忆障碍、抑郁症、小儿智力发育迟钝及小儿遗尿症等。</td></tr>
<tr><td style="text-align: center">盐酸甲氯芬酯胶囊 (健瑙素)</td><td>用于改善脑出血、脑手术、脑外伤、脑动脉硬化等引起的意识障碍。亦可用于老年性痴呆、慢性记忆障碍、抑郁症、小儿智力发育迟钝及小儿遗尿症等。</td></tr>
<tr><td style="text-align: center">碳酸锂片 (碳酸锂片)</td><td>主要治疗躁狂症，对躁狂和抑郁交替发作的双相情感性精神障碍有很好的治疗和预防复发作用，对反复发作的抑郁症也有预防发作作用。也用于治疗分裂 - 情感性精神病。</td></tr>
<tr><td style="text-align: center">卡马西平片 (卡马西平片)</td><td>癫痫：部分性发作：复杂部分性发作、简单部分性发作和继发性全身发作。全身性发作：强直、阵挛、强直阵挛发作。三叉神经痛和舌咽神经痛发作，亦用作三叉神经痛缓解后的长期预防性用药。也可用于脊髓痨和多发性硬化、糖尿病性周围性神经痛、患肢痛和外伤后神经痛以及疱疹后神经痛。预防或治疗躁狂 - 抑郁症；对锂、抗精神病药、抗抑郁药无效的或不能耐受的躁狂 - 抑郁症，可单用或与锂盐和其它抗抑郁药合用。中枢性部分性尿崩症，可单用或氯磺丙脲或氯贝丁酯等合用。酒精癖的戒断综合征。</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Linux iptables 命令笔记
date: 2022-12-25 22:51:48
updated: 2022-12-25 22:59:48
categories: Linux
tags: [Network, Linux]
description:
thumbnail: http://oss.whaleluo.top/blog/img/Iptables-banner.png-picsmall
banner_img: http://oss.whaleluo.top/blog/img/Iptables-banner.png-picsmall</p>
<hr />
<h1 id="linux-iptables-命令笔记"><a class="header" href="#linux-iptables-命令笔记">Linux Iptables 命令笔记</a></h1>
<p><img src="http://oss.whaleluo.top/blog/img/Iptables-banner.png-picsmall" alt="banner" /></p>
<h2 id="认识"><a class="header" href="#认识">认识</a></h2>
<p><code>iptables</code> 是运行在用户空间的应用软件，通过控制 Linux 内核 netfilter 模块，来管理网络数据包的处理和转发。</p>
<p><code>iptables</code> 操作需要超级用户权限，以上命令通常只用于处理 IPv4 数据包；而对于 IPv6 数据包，则使用类似的 <code>ip6tables</code> 命令。</p>
<h2 id="原理"><a class="header" href="#原理">原理</a></h2>
<p>iptables 的原理主要是对数据包的控制，看下图：</p>
<p><img src="http://oss.whaleluo.top/blog/img/linux-iptables-1.png-picsmall" alt="iptables 原理" /></p>
<ol>
<li>一个数据包进入网卡时，它首先进入 <strong>PREROUTING(预路由)</strong> 链，内核根据数据包目的 IP 判断是否需要转发出去.</li>
<li>如果数据包就是进入本机的，它就会沿着图向下移动，到达 <strong>INPUT</strong> 链。数据包到了 INPUT 链后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包会经过 OUTPUT 链，然后到达 <strong>POSTROUTING(路由后)</strong> 链输出。</li>
<li>如果数据包是要转发出去的，且内核允许转发，数据包就会如图所示向右移动，经过 FORWARD 链，然后到达 POSTROUTING 链输出。</li>
</ol>
<h2 id="规则-表-链"><a class="header" href="#规则-表-链">规则 表 链</a></h2>
<blockquote>
<p>iptables 由链组成,链中有规则</p>
</blockquote>
<p><img src="http://oss.whaleluo.top/blog/img/linux-iptables-2.png-picsmall" alt="iptables 结构" /></p>
<h3 id="规则-rules"><a class="header" href="#规则-rules">规则 (rules)</a></h3>
<p>规则（rules）其实就是网络管理员预定义的条件，规则一般的定义为“如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息包过滤表中，这些规则分别指定了 <strong>源地址、目的地址、传输协议</strong>（如 TCP、UDP、ICMP）和服务类型（如 HTTP、FTP 和 SMTP）等。当数据包与规则匹配时，iptables 就根据规则所定义的方法来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。配置防火墙的主要工作就是添加、修改和删除这些规则。</p>
<h3 id="链-chains"><a class="header" href="#链-chains">链 (chains)</a></h3>
<p>链（chains）是数据包传播的路径，每一条链中可以有一条或数条规则。当一个数据包到达一个链时，iptables 就会从链中第一条规则开始检查，看该数据包是否满足规则所定义的条件。如果满足，系统就会根据该条规则所定义的方法处理该数据包；否则 iptables 将继续检查下一条规则，如果该数据包不符合链中任一条规则，iptables 就会根据该链预先定义的默认策略来处理数据包。</p>
<h3 id="表-tables"><a class="header" href="#表-tables">表 (tables)</a></h3>
<p>表（tables）提供特定的功能，iptables 内置了 4 个表，即 raw 表、filter 表、nat 表和 mangle 表，分别用于实现包过滤，网络地址转换和包重构的功能。</p>
<p>其中 nat filter 表是常用的.</p>
<h4 id="filter-表"><a class="header" href="#filter-表">Filter 表</a></h4>
<p>主要用于过滤数据包，主要利用在 filter 表中指定的规则来实现对数据包的过滤。<strong>Filter 表是默认的表，如果没有指定哪个表，iptables 就默认使用 filter 表来执行所有命令</strong>.</p>
<p>filter 表包含了 INPUT 链（处理进入的数据包），RORWARD 链（处理转发的数据包），OUTPUT 链（处理本地生成的数据包）在 filter 表中只能允许对数据包进行接受,丢弃的操作，而无法对数据包进行更改</p>
<h4 id="nat-表"><a class="header" href="#nat-表">Nat 表</a></h4>
<p><strong>主要用于网络地址转换 NAT,用于端口和/或地址的转换.</strong></p>
<p>NAT 表包含了 PREROUTING 链（修改即将到来的数据包），POSTROUTING 链（修改即将出去的数据包），OUTPUT 链（修改路由之前本地生成的数据包）</p>
<h2 id="iptables-命令"><a class="header" href="#iptables-命令">Iptables 命令</a></h2>
<pre><code class="language-shell">iptables [-t 表名] 命令选项 [链名] [条件匹配] [-j 目标动作或跳转] 
</code></pre>
<h3 id="表名"><a class="header" href="#表名">表名</a></h3>
<p>表名：Filter, NAT, Mangle, Raw</p>
<p>起包过滤功能的为表 Filter，可以不填，不填默认为 Filter</p>
<h3 id="命令选项"><a class="header" href="#命令选项">命令选项</a></h3>
<p>-A 在指定链的末尾添加（--append）一条新的规则</p>
<p>-D 删除（--delete）指定链中的某一条规则，按规则序号或内容确定要删除的规则</p>
<p>-I 在指定链中插入（--insert）一条新的规则，默认在链的开头插入</p>
<p>-R 修改、替换（--replace）指定链中的一条规则，按规则序号或内容确定</p>
<p>-L 列出（--list）指定链中的所有的规则进行查看，默认列出表中所有链的内容</p>
<p>-F 清空（--flush）指定链中的所有规则，默认清空表中所有链的内容</p>
<p>-N 新建（--new-chain）一条用户自己定义的规则链</p>
<p>-X 删除指定表中用户自定义的规则链（--delete-chain）</p>
<p>-P 设置指定链的默认策略（--policy）</p>
<p>-n 用数字形式（--numeric）显示输出结果，若显示主机的 IP 地址而不是主机名</p>
<p>-P 设置指定链的默认策略（--policy）</p>
<p>-v 查看规则列表时显示详细（--verbose）的信息</p>
<p>-V 查看 iptables 命令工具的版本（--Version）信息</p>
<p>-h 查看命令帮助信息（--help）</p>
<p>--line-number 查看规则列表时，同时显示规则在链中的顺序号</p>
<h3 id="链名"><a class="header" href="#链名">链名</a></h3>
<p>可以根据数据流向来确定具体使用哪个链，在 Filter 中的使用情况如下：</p>
<pre><code class="language-shell">INPUT链 – 处理来自外部的数据。 
OUTPUT链 – 处理向外发送的数据。 
FORWARD链 – 将数据转发到本机的其他网卡设备上。
</code></pre>
<h3 id="条件匹配"><a class="header" href="#条件匹配">条件匹配</a></h3>
<p>-p 指定规则协议，如 tcp, udp,icmp 等，可以使用 all 来指定所有协议</p>
<p>-s 指定数据包的源地址参数，可以使 IP 地址、网络地址、主机名</p>
<p>-d 指定目的地址</p>
<p>-i 输入接口</p>
<p>-o 输出接口</p>
<p><img src="http://oss.whaleluo.top/blog/img/linux-iptable-3.jpeg-picsmall" alt="扩展参数1" /></p>
<p><img src="http://oss.whaleluo.top/blog/img/linux-iptables-4.jpeg-picsmall" alt="扩展参数2" /></p>
<h3 id="目标值"><a class="header" href="#目标值">目标值</a></h3>
<p>数据包控制方式包括四种为：</p>
<ol>
<li>ACCEPT：允许数据包通过。</li>
<li>DROP：直接丢弃数据包，不给出任何回应信息。</li>
<li>REJECT：拒绝数据包通过，必须时会给数据发送端一个响应信息。</li>
<li>LOG：在/var/log/messages 文件中记录日志信息，然后将数据包传递给下一条规则。</li>
<li>QUEUE：防火墙将数据包移交到用户空间</li>
<li>RETURN：防火墙停止执行当前链中的后续 Rules，并返回到调用链 (the calling chain)</li>
</ol>
<h2 id="应用-1"><a class="header" href="#应用-1">应用</a></h2>
<h3 id="nat-转发"><a class="header" href="#nat-转发">NAT 转发</a></h3>
<p>实现将本机（192.168.1.7:7410）端口流量转发给（192.168.1.160:9200）。</p>
<h4 id="1-内核允许转发"><a class="header" href="#1-内核允许转发">1. 内核允许转发</a></h4>
<pre><code class="language-shell">vim /etc/sysctl.conf

# 添加如下代码：
net.ipv4.ip_forward=1

# 重启network服务
systemctl restart ****network

# 查看是否修改成功
sysctl net.ipv4.ip_forward
</code></pre>
<h4 id="2-设置-filter-表基础策略允许入包出包转发"><a class="header" href="#2-设置-filter-表基础策略允许入包出包转发">2. 设置 Filter 表基础策略：允许入包/出包/转发</a></h4>
<p>-P 设置链的基础策略</p>
<pre><code class="language-shell">iptables -P INPUT ACCEPT
iptables -P OUTPUT ACCEPT
iptables -P FORWARD ACCEPT
</code></pre>
<h4 id="3-端口转发流量"><a class="header" href="#3-端口转发流量">3. 端口转发流量</a></h4>
<p>建立一个双向映射</p>
<pre><code class="language-shell"># 访问时转发
iptables -t nat -A PREROUTING -d 192.168.1.7/32 -p tcp --dport 7410 -j DNAT --to-destination 192.168.1.160:9200

# 接受来源于远程机器的数据包
# SNAT 地址伪装
iptables -t nat -A POSTROUTING -d 192.168.1.160/32 -p tcp --dport 9200 -j SNAT --to-source 192.168.1.7
</code></pre>
<pre><code class="language-shell">sudo iptables -t nat -I PREROUTING -p tcp -d 10.10.40.40 --dport 3079 -j DNAT --to-destination 10.10.66.12:22
sudo iptables -t nat -I POSTROUTING -p tcp --dport 22 -d 10.10.66.12 -j SNAT --to-source 10.10.40.40
</code></pre>
<h3 id="其他命令"><a class="header" href="#其他命令">其他命令</a></h3>
<p>显示 nat 规则列表：</p>
<pre><code class="language-shell">iptables -t nat -L -n --line-numbers
</code></pre>
<p>删除指定规则：</p>
<pre><code class="language-shell">iptables -t nat -D PREROUTING 1
</code></pre>
<p>允许出站的 DNS 连接:</p>
<pre><code class="language-shell">iptables -A OUTPUT -p udp -o eth0 --dport 53 -j ACCEPT
iptables -A INPUT -p udp -i eth0 --sport 53 -j ACCEPT
</code></pre>
<p>将来自 422 端口的流量全部转到 22 端口:</p>
<p>这意味着我们既能通过 422 端口又能通过 22 端口进行 ssh 连接。启用 DNAT 转发。</p>
<pre><code class="language-shell">iptables -t nat -A PREROUTING -p tcp -d 192.168.102.37 --dport 422 -j DNAT --to 192.168.102.37:22
</code></pre>
<p>除此之外，还需要允许连接到 422 端口的请求:</p>
<pre><code class="language-shell">iptables -A INPUT -i eth0 -p tcp --dport 422 -m state --state NEW,ESTABLISHED -j ACCEPT
iptables -A OUTPUT -o eth0 -p tcp --sport 422 -m state --state ESTABLISHED -j ACCEPT
</code></pre>
<p>本机端口转发:</p>
<pre><code class="language-shell">iptables -t nat -A PREROUTING -p tcp --dport 422 -j REDIRECT --to-ports 22
</code></pre>
<p>注意,在本机请求无法经过 PREROUTING 链,所以本机的 422 端口访问不了 22.</p>
<p>如果需要本机也可以访问，则需要配置 OUTPUT 链</p>
<p>特别注意: 本机访问外网的端口会转发到本地,导致访不到外网.实际上是访问到本地,建议不做 80 端口的转发或者指定目的 -d localhost：</p>
<pre><code class="language-shell">iptables -t nat -A OUTPUT -d localhost -p tcp --dport 80 -j REDIRECT --to-ports 8080
</code></pre>
<p>原因：外网访问需要经过 PREROUTING 链，但是 localhost 不经过该链，因此需要用 OUTPUT。</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>title: Openwrt LEDE 固件自定义编译笔记
date: 2023-07-15 14:49:21
updated: 2023-07-15 14:49:21
categories: OpenWRT
tags: [OpenWRT, Linux]
description: 
thumbnail: 
banner_img:</h2>
<h1 id="openwrt-lede-固件自定义编译笔记"><a class="header" href="#openwrt-lede-固件自定义编译笔记">Openwrt LEDE 固件自定义编译笔记</a></h1>
<p>LEDE 有些软件 Openwrt 没有。比如我认为很重要的硬解 nat。lean 对国内用户也比较友善。</p>
<p>LEDE 项目地址：<a href="https://github.com/coolsnowwolf/lede">GitHub - coolsnowwolf/lede: Lean's LEDE source</a></p>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<p><a href="https://sspai.com/post/61463">看完这篇，自定义 OpenWrt/LEDE 路由固件不求人 - 少数派</a></p>
<h2 id="编译前的准备"><a class="header" href="#编译前的准备">编译前的准备</a></h2>
<p>Dedian11、Ubantu18 以上的系统，根据文档安装好依赖。保持使用 Clash Tun 模式进行代理，在 Vmare 虚拟机上进行。</p>
<pre><code class="language-shell"># 测试编译环境

make defconfig
</code></pre>
<h2 id="自定义固件"><a class="header" href="#自定义固件">自定义固件</a></h2>
<h3 id="根据菜单自定义"><a class="header" href="#根据菜单自定义">根据菜单自定义</a></h3>
<pre><code class="language-shell">make menuconfig
</code></pre>
<pre><code class="language-text">Target System (x86)  ---&gt;   目标系统（x86）  
Subtarget (x86_64)  ---&gt;   子目标（x86_64）  
Target Profile (Generic)  ---&gt;目标配置文件（通用）  
Target Images  ---&gt; 保存目标镜像的格式  
Global build settings  ---&gt;      全局构建设置  
Advanced configuration options (for developers)  ---- 高级配置选项（适用于开发人员）  
Build the OpenWrt Image Builder 构建OpenWrt图像生成器  
Build the OpenWrt SDK  构建OpenWrt SDK  
Package the OpenWrt-based Toolchain 打包基于OpenWrt的工具链  
Image configuration  ---&gt;图像配置  
Base system  ---&gt;     基本系统  
Administration  ---&gt;     管理  
Boot Loaders  ---&gt; 引导加载程序  
Development  ---&gt;   开发  
Extra packages  ---&gt;  额外包  
Firmware  ---&gt;固件  
Fonts  ---&gt;字体  
Kernel modules  ---&gt;  内核模块  
Languages  ---&gt;语言  
Libraries  ---&gt;  图书馆  
LuCI  ---&gt;      LuCI  
Mail  ---&gt; 邮件  
Multimedia  ---&gt;多媒体  
Network  ---&gt;网络  
Sound  ---&gt; 声音  
Utilities  ---&gt;实用程序  
Xorg  ---&gt;Xorg
</code></pre>
<pre><code class="language-shell">## 选择系统(以 x86_64 为例)
Target System -&gt; x86
Subtarget -&gt; x86_64

## 选择固件的文件系统
## https://openwrt.org/docs/techref/filesystems
Target Images -&gt; squashfs

## 选择构建X86_X64的GRUB固件
Target Images -&gt; Build GRUB images (Linux x86 or x86_64 host only) 

## 选择更小的压缩格式固件，方便复制
Target Images -&gt; GZip images

## 修改软件包可用空间，默认安装会占用100M左右，建议修改扩大，为后续安装其他软件打基础
Target Images -&gt; Root filesystem partition size

## 添加web界面(y键选择n键排除)
LuCI &gt; Collections -&gt; Luci

## 添加兼容性依赖
LuCI &gt; Modules -&gt; luci-compat

## 添加中文
LuCI &gt; Modules -&gt; Translations -&gt; Chinese Simplified

## 添加openclash
LuCI &gt; Applications -&gt; luci-app-openclash  

## 添加主题
LuCI -&gt; Themes

## 添加wget
Nerwork -&gt; File Transfer -&gt; wget-ssl

## 添加kmod-tun，TUN模式必须
Kernel modules -&gt; Network Support -&gt; kmod-tun

## 排除dnsmasq，由于默认会安装dnsmasq-full，这里需要排除dnsmasq，否则会冲突报错。
Base system -&gt; dnsmasq 

</code></pre>
<p>选择 docker</p>
<p>Base system<br />
取消选中 dnsmasq<br />
选中 dnsmasq-full<br />
因为 dnsmasq-full 支持 ipset 功能，对于基于域名的 xx 很有用。</p>
<p>Network-&gt;File Transfer 中选中 ssh ntp<br />
curl<br />
wget<br />
【两个下载工具】</p>
<p>Network-&gt;IP Addresses and Names 中选中<br />
bind-dig<br />
ddns-scripts_No-IP_com。（用来支持 no-ip.com 的 ddns 服务）<br />
一个是测试工具；另一个是某个 ddns 支持，还有其他 ddns 支持，也可以酌情选中。</p>
<p>Network-&gt;Routing and Rediction 中选中<br />
ip-full<br />
这个很关键。<br />
Network 中选中<br />
iperf3<br />
ipset<br />
一个是测试工具；<br />
另一个是 ipset，用于支持基于域名的 xx。</p>
<p>Network-&gt;Web Servers/Proxies 选中那些 SS，如果您需要使用 SS 的话。<br />
Utilities-&gt;Editors 中选<br />
nano （也可以选 vim）<br />
Utilities-&gt;Shells 中选中<br />
bash<br />
点击 Save，保存为.config。<br />
一路 Exit 退出。在输入 make 开始编译。</p>
<h3 id="源码修改"><a class="header" href="#源码修改">源码修改</a></h3>
<p>修改默认语言主题：<br />
修改 vim feeds/luci/modules/luci-base/root/etc/config/luci 文件:</p>
<pre><code class="language-yaml">config core main
        option lang &quot;zh_cn&quot;
        option mediaurlbase /luci-static/material
        option resourcebase /luci-static/resources
               
config internal languages
        option zh_cn &quot;普通话 (Chinese)&quot;
</code></pre>
<p>修改主机名，设定时区，IP 地址:</p>
<p>vim package/base-files/files/bin/config_generate</p>
<pre><code class="language-yaml">generate_static_system() {
uci -q batch &lt;&lt;-EOF
delete system.@system[0]
add system system
set system.@system[-1].hostname='LEDE'
set system.@system[-1].timezone='CST-8'                      #东八区
set system.@system[-1].zonename='Asia/Shanghai'       #这句话要加上，不然还是UTC
lan) ipad=${ipaddr:-&quot;192.168.8.1&quot;} ;;       #修改默认IP
</code></pre>
<p>SSH/TELNET 显示信息修改方式:<br />
vim package/base-files/files/etc/banner</p>
<p>修改路由连接数<br />
vim package/base-files/files/etc/sysctl.conf<br />
net.netfilter.nf_conntrack_max=65535</p>
<p><a href="https://www.jianshu.com/p/27c424562de7">Openwrt 编译，修改lan、wan口，ip，拨号 - 简书</a><br />
拨号</p>
<h3 id="编译-openclash-小猫咪"><a class="header" href="#编译-openclash-小猫咪">编译 OpenClash 小猫咪</a></h3>
<p><a href="https://lhy.life/20200531-openwrt+openclash/">编译带 OpenClash 的 OpenWrt 固件 | 心底的河流</a></p>
<h2 id="行为管控"><a class="header" href="#行为管控">行为管控</a></h2>
<pre><code class="language-shell">cd /home/user/lede/package
git clone https://github.com/destan19/OpenAppFilter.git

# 去除加速模块
rm package/lean/luci-app-flowoffload -fr
rm package/lean/shortcut-fe/ -fr
rm package/lean/luci-app-sfe/ -fr
</code></pre>
<h2 id="编译"><a class="header" href="#编译">编译</a></h2>
<p><a href="http://www.laoxu.date/html/202204/1912.html">openwrt编译openclash-老徐小屋</a></p>
<pre><code class="language-shell">./scripts/feeds update -a
./scripts/feeds install -a

make defconfig

</code></pre>
<h2 id="使用-github-action"><a class="header" href="#使用-github-action">使用 GitHub Action</a></h2>
<p>使用 p3terx 大佬的脚本。</p>
<p><a href="https://p3terx.com/archives/build-openwrt-with-github-actions.html">GitHub Actions 在线云编译 OpenWrt 固件 - P3TERX ZONE</a></p>
<p>编译时空间不足问题：</p>
<p><a href="https://github.com/coolsnowwolf/lede/issues/11159">OpenWRT在Actions编译过程中因磁盘空间不足从而编译失败，如何清理磁盘空间？ · Issue #11159 · coolsnowwolf/lede · GitHub</a></p>
<p><a href="https://github.com/coolsnowwolf/lede/issues/7004">减少编译所用空间 · Issue #7004 · coolsnowwolf/lede · GitHub</a></p>
<p>缓存 cache 加速编译：</p>
<p><a href="https://github.com/coolsnowwolf/lede/pull/7796">使用github actions cache缓存工具链， 加速你的云编译项目，让你做更快的男人 by stupidloud · Pull Request #7796 · coolsnowwolf/lede · GitHub</a></p>
<h2 id="自定义编译"><a class="header" href="#自定义编译">自定义编译</a></h2>
<p><a href="https://github.com/VIKINGYFY/OpenWRT-CI">GitHub - VIKINGYFY/OpenWRT-CI: 云编译OpenWRT固件</a></p>
<h2 id="官方源"><a class="header" href="#官方源">官方源</a></h2>
<pre><code class="language-shell">src/gz openwrt_koolshare_mod_core http://downloads.openwrt.org/snapshots/targets/x86/64/packages
src/gz openwrt_koolshare_mod_base http://downloads.openwrt.org/snapshots/packages/x86_64/base
src/gz openwrt_koolshare_mod_luci http://downloads.openwrt.org/snapshots/packages/x86_64/luci
src/gz openwrt_koolshare_mod_packages http://downloads.openwrt.org/snapshots/packages/x86_64/packages
src/gz openwrt_koolshare_mod_routing http://downloads.openwrt.org/snapshots/packages/x86_64/routing
src/gz openwrt_koolshare_mod_telephony http://downloads.openwrt.org/snapshots/packages/x86_64/telephony
</code></pre>
<h2 id="openclash-定时任务"><a class="header" href="#openclash-定时任务">OpenClash 定时任务</a></h2>
<pre><code class="language-shell"># 定时重启
0 0 * * * sh /usr/share/openclash/openclash_rule.sh
0 7 * * * sh /usr/share/openclash/openclash_ipdb.sh
0 4 * * * sh /usr/share/openclash/openclash_geosite.sh
0 8 * * * sh /usr/share/openclash/openclash_geoip.sh
0 9 * * * sh /usr/share/openclash/openclash_chnroute.sh
*/10 * * * * sh /usr/share/openclash/openclash.sh
00 5 * * * sleep 5 &amp;&amp; touch /etc/banner &amp;&amp; reboot
</code></pre>
<h2 id="openclash-docs"><a class="header" href="#openclash-docs">OpenClash Docs</a></h2>
<p><a href="https://github.com/Fndroid/clash_for_windows_pkg/wiki/DNS%E6%B1%A1%E6%9F%93%E5%AF%B9Clash%EF%BC%88for-Windows%EF%BC%89%E7%9A%84%E5%BD%B1%E5%93%8D">DNS污染对Clash（for Windows）的影响 · Fndroid/clash_for_windows_pkg Wiki · GitHub</a></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: 服务器备忘录✨
date: 2022-03-20 19:37:48
updated: 2022-03-20 19:37:48
categories: Server
tags: [Server, Linux]
thumbnail: https://images.samsung.com/is/image/samsung/p5/semiconductor/solutions/applications/server/3-kf-energy-efficiency-mobile.jpg?$ORIGIN_JPG$
banner_img: https://images.samsung.com/is/image/samsung/p5/semiconductor/solutions/applications/server/3-kf-energy-efficiency-mobile.jpg?$ORIGIN_JPG$</p>
<hr />
<h1 id="服务器备忘录"><a class="header" href="#服务器备忘录">服务器备忘录</a></h1>
<blockquote>
<p><strong>2022 年 3 月 19 日</strong> Update.</p>
</blockquote>
<h1 id="落落家-x86"><a class="header" href="#落落家-x86">落落家 X86</a></h1>
<h2 id="服务器配置"><a class="header" href="#服务器配置">服务器配置</a></h2>
<ul>
<li>
<p>**运行内存 (RAM)：**4GB（笔记本 ddr3 内存条）</p>
</li>
<li>
<p>**CPU：**4 x Intel(R) Atom(TM) CPU D2550 @ 1.86GHz / 512 KB cache <a href="https://www.intel.cn/content/www/cn/zh/products/sku/65470/intel-atom-processor-d2550-1m-cache-1-86-ghz/specifications.html">英特尔凌动® 处理器 D2550 (intel.cn)</a> 2 核 4 线程</p>
</li>
<li>
<p><strong>服务器系统</strong>：Ubuntu 18.04 Server</p>
<p>Linux whalefall 4.15.0-171-generic #180-Ubuntu SMP Wed Mar 2 17:25:05 UTC 2022 x86_64</p>
</li>
<li>
<p>**硬盘：**​<code>df -h</code></p>
<pre><code class="language-shell">Filesystem      Size  Used Avail Use% Mounted on
/dev/sdb2       146G   18G  122G  13% /  # 系统盘 150GB
/dev/sda1       299G  294G  5.0G  99% /mnt/disk  # 3.5寸硬盘1 300GB (跑wx)
/dev/sdc1       466G  129G  338G  28% /mnt/mainDisk  # 2.5寸硬盘2 500GB (NAS)
</code></pre>
</li>
<li>
<p><strong>网络：</strong> <code>ifconfig</code></p>
<pre><code class="language-shell">enp2s0:  # 主网卡 
        inet 192.168.5.123  netmask 255.255.255.0  broadcast 192.168.5.255
enp1s0:  # 副网卡
        inet 192.168.5.124  netmask 255.255.255.0  broadcast 192.168.5.255
</code></pre>
<ul>
<li>enp2s0：主网卡，跑 <strong>qBittorrent</strong></li>
<li>enp1s0：副网卡，docker network —— macnet （openwrt），网心云 docker</li>
</ul>
</li>
</ul>
<h2 id="运行服务"><a class="header" href="#运行服务">运行服务</a></h2>
<h3 id="nginx-1"><a class="header" href="#nginx-1">Nginx</a></h3>
<blockquote>
<p>配置文件：<code>/etc/nginx/conf.d</code>; <code>/etc/nginx/sites-enabled</code></p>
<p>默认配置：<a href="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Server-all.html#Nginx-default-config">Nginx默认配置</a></p>
</blockquote>
<ol>
<li>
<p>Port: 80</p>
<p>Desc: 运行探针服务。</p>
<p>Path: <code>/var/www/html</code></p>
</li>
<li>
<p>Port: 86</p>
<p>Desc: python3-cookbook 3.0.0 文档。</p>
<p>Path: <code>/www/openvpn_admin/</code></p>
</li>
<li>
<p>Port: 88</p>
<p>Desc: 可道云 Kodcloud.</p>
<p>Path: <code>/www/kodcloud</code></p>
</li>
<li>
<p>Port: 89</p>
<p>Desc: AiraNg 下载器。（已反向代理 Aira2 6800）<a href="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Server-all.html#AiraNg-download-config">配置文件</a></p>
<p>Path: <code>/www/kodcloud</code></p>
</li>
</ol>
<h3 id="docker-2"><a class="header" href="#docker-2">Docker</a></h3>
<ol>
<li>
<p>Port：9090</p>
<p>Desc：Portainer web admin</p>
<p>command：<a href="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Server-all.html#run-portainer-command">source</a></p>
</li>
<li>
<p>Port：8989</p>
<p>Desc：qBittorrent download</p>
<p>command：<a href="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Server-all.html#run-qbittorrent-command">source</a></p>
</li>
<li>
<p>Port：18888</p>
<p>Desc：网心云（容器魔方）</p>
<p>command：<a href="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Server-all.html#run-wxedge-command">source</a></p>
</li>
<li>
<p>network：macnet</p>
<p>ip：192.168.5.66</p>
<p>Desc：openwrt 软路由</p>
<p>command：<a href="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Server-all.html#run-openwrt-by-docker">source</a></p>
</li>
</ol>
<h1 id="部分配置文件"><a class="header" href="#部分配置文件">部分配置文件</a></h1>
<h2 id="nginx_default_config"><a class="header" href="#nginx_default_config">Nginx_default_config</a></h2>
<pre><code class="language-shell">server {
        listen 80 default_server;
        listen [::]:80 default_server;
        root /www/;
        index index.php index.html index.htm index.nginx-debian.html;
        server_name _;
        location / {
                try_files $uri $uri/ =404;
        }
        location ~ .*\.php(\/.*)*$ {
                include snippets/fastcgi-php.conf;
                # With php-fpm (or other unix sockets):
                fastcgi_pass unix:/var/run/php/php7.4-fpm.sock;
                # With php-cgi (or other tcp sockets):
        #       fastcgi_pass 127.0.0.1:9000;
        }
}
</code></pre>
<h2 id="airang_download_config"><a class="header" href="#airang_download_config">AiraNg_download_config</a></h2>
<pre><code>server {
        listen 89 default_server;
        listen [::]:89 default_server;
        root /www/AiraNg/;
        index index.php index.html index.htm index.nginx-debian.html;
        server_name _;
        location / {
                try_files $uri $uri/ =404;
        }
        location ~ .*\.php(\/.*)*$ {
                include snippets/fastcgi-php.conf;
                # With php-fpm (or other unix sockets):
                fastcgi_pass unix:/var/run/php/php7.4-fpm.sock;
                # With php-cgi (or other tcp sockets):
        #       fastcgi_pass 127.0.0.1:9000;
        }
        # 反向代理 Aria ws
        location /jsonrpc {
        proxy_redirect off;
        proxy_pass http://127.0.0.1:6800/jsonrpc;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection &quot;upgrade&quot;;
        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
}
</code></pre>
<h3 id="run-qbittorrent-command"><a class="header" href="#run-qbittorrent-command">Run qBittorrent Command</a></h3>
<pre><code class="language-shell"># 运行 qbittorrent docker 版
 docker create \
    --name=qbittorrent \
    -e QB_WEBUI_PORT=8989 \
    -e QB_EE_BIN=false \
    -e UID=0 \
    -e GID=0 \
    -e QB_TRACKERS_UPDATE_AUTO=true \
    -e QB_TRACKERS_LIST_URL=https://trackerslist.com/all.txt \
    -e TZ=Asia/Shanghai \
    -e UMASK=022 \
    -p 6881:6881 \
    -p 6881:6881/udp \
    -p 8989:8989 \
    -v /root/qb_config:/config \
    -v /mnt/mainDisk/download/:/Downloads \
    --restart unless-stopped \
    johngong/qbittorrent:latest
</code></pre>
<h3 id="run_portainer_command"><a class="header" href="#run_portainer_command">run_portainer_command</a></h3>
<pre><code class="language-shell"># 运行汉化版 Portainer
docker run -d -p 9000:9000 
--name portainer \ 
--restart always \ 
-v /var/run/docker.sock:/var/run/docker.sock \ 
-v portainer_data:/data \ 
-v /root/public:/public \ 
portainer/portainer
</code></pre>
<h3 id="run_wxedge_command"><a class="header" href="#run_wxedge_command">run_wxedge_command</a></h3>
<pre><code class="language-shell">docker run -d --name=wxedge --restart=always --privileged --net=host  --tmpfs /run --tmpfs /tmp -v /mnt/disk/wxedge_storage:/storage:rw -e NIC=enp2s0  onething1/wxedge
</code></pre>
<blockquote>
<p>-e NIC：指定网卡</p>
</blockquote>
<h3 id="run_openwrt_by_docker"><a class="header" href="#run_openwrt_by_docker">run_openwrt_by_docker</a></h3>
<pre><code class="language-shell"># 新建一个网络 指定网卡
docker network create -d macvlan --subnet=192.168.5.0/24 --gateway=192.168.5.1 -o parent=enp2s0 macnet

# 运行 openwrt 镜像 指定ip
docker run --restart always --name openwrt -d --network macnet --ip=192.168.5.66 --privileged openwrt_myself:latest

# 进入容器命令行，修改 /etc/network/config
config interface 'loopback'
        option proto 'static'
        option ipaddr '127.0.0.1'
        option netmask '255.0.0.0'
        option device 'lo'

config interface 'lan'
        option type 'bridge'
        option ifname 'eth0'
        option proto 'static'
        option netmask '255.255.255.0'
        option gateway '192.168.5.1'
        option dns '192.168.5.1'
        option ipaddr '192.168.5.66'
        
# openwrt 防火墙自定义规则添加
iptables -t nat -I POSTROUTING -o eth0 -jMASQUERADE
</code></pre>
<h3 id="run_ttnode_by_docker"><a class="header" href="#run_ttnode_by_docker">run_ttnode_by_docker</a></h3>
<pre><code class="language-shell">sudo docker run -d \
  -v /tiptime_dir:/mnt/data/ttnode \
  -v /var/run/docker.sock:/var/run/docker.sock \
  --name ttnode \
  --hostname ttnode \
  --net=host \
  --restart=always \
  tiptime/ttnode:latest
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: 【业余无线电】中国业余电台常用频率(短波) 
date: 2023-05-06 16:37:48
updated: 2023-05-06 16:37:48
categories: Radio
tags: [业余无线电, 短波, SW, 收音机]
description:
thumbnail:
banner_img:</p>
<hr />
<h1 id="中国业余电台常用频率-短波"><a class="header" href="#中国业余电台常用频率-短波">中国业余电台常用频率 (短波)</a></h1>
<p><a href="https://www.short-wave.info/index.php">短波查询 https://www.short-wave.info/index.php</a></p>
<h2 id="波段"><a class="header" href="#波段">波段</a></h2>
<p>80m 波段:3.840MHz 3.843MHz 3.850MHz 3.855MHz<br />
40m 波段:7.030MHz(CW) 7.050MHz 7.O53MHz 7.055MHz 7.060MHz 7.068MHz<br />
20m 波段:14.180MHz 14.225MHz 14.270MHz 14.330MHz<br />
15m 波段:21.400MHz<br />
10m 波段:29.600MHz(FM)</p>
<blockquote>
<p>14.180MHz 是 &quot;B NET&quot; 工作频率.每天 8:00 开始.经常有老业余家出现 14.330MHz 是 &quot;CRSA NET&quot; 的工作频率.每周二 10:00 开始.</p>
</blockquote>
<h2 id="国内比较热闹的短波频点"><a class="header" href="#国内比较热闹的短波频点">国内比较热闹的短波频点</a></h2>
<h3 id="7050mhz-lsb-单边带"><a class="header" href="#7050mhz-lsb-单边带">7.050MHZ LSB 单边带</a></h3>
<p>主要是早上和晚上很热闹，传播好的时候，比本地的中继台信号还要好，国内 HAM 默认的公用呼叫频率，大家常在 7.050 呼叫到对方后，都喜欢转到 7.055、7.060、7.065、7.070、7.080 做通联 QSO。</p>
<h3 id="14270mhz-usb-单边带"><a class="header" href="#14270mhz-usb-单边带">14.270MHZ USB 单边带</a></h3>
<p>主要是白天很热闹，传播好的时候，比本地的中继台信号还要好，国内 HAM 默认的公用呼叫频率，大家常在 14.270 呼叫到对方后，都喜欢转到 14.270、14.275、14.280、14.265 做通联 QSO。</p>
<h3 id="14180mhz-usb-单边带"><a class="header" href="#14180mhz-usb-单边带">14.180MHZ USB 单边带</a></h3>
<p>主要是早上 9 点前热闹，传播好的时候，比本地的中继台信号还要好，国内 1 级 BA 大哥和 2 级 BD 大哥 HAM 默认的公用呼叫频率，大家可以在早上收听他们的通联，可以学到更多的知识。</p>
<h3 id="14330mhz-usb-单边带"><a class="header" href="#14330mhz-usb-单边带">14.330MHZ USB 单边带</a></h3>
<p>中国无线电运动协会台网专用频点，每周二 10 点有 BY1PK 主持，发布总部的通知和点名，大家可以收听哦。</p>
<h3 id="21400mhz-usb-单边带"><a class="header" href="#21400mhz-usb-单边带">21.400MHZ USB 单边带</a></h3>
<p>传播特点：白天有传播，偶尔晚上的传播非常好,你的日文好，级别是 2 级的话，可以到 21.200---21.300MHZ 之间，可以和日本的友台通联，日本的 HAM 有很多使用 21MHZ 的 5W 手持机，你随时可以呼叫日本友台，毫不费力！</p>
<h3 id="29600mhz-模式fm"><a class="header" href="#29600mhz-模式fm">29.600MHZ 模式：FM</a></h3>
<p>白天有传播，特别是下午 2 点到旁晚的 6 点传播，比打电话还清楚，4 级火腿可以在这频段上合法使用，很有挑战性哦</p>
<h2 id="短波传播判别心得"><a class="header" href="#短波传播判别心得">短波传播判别心得</a></h2>
<p>晚上我常在 14.195、14.200、14.202、14.210 等频点收听国外电台 每天晚上很多不同国家的无线电爱好者活跃在这里 也听到了很有趣的不同国家版本的英语口语！</p>
<h3 id="10-米波-29600mhz-模式fm"><a class="header" href="#10-米波-29600mhz-模式fm">10 米波 29.600MHZ 模式：FM</a></h3>
<p>常常是下午和旁晚才有传播，当然偶尔上午和晚上 12 点前的传播厉害到 5W 可以呼叫全球任何地区的电台，通话质量比本地台还清楚。我常常在呼叫前，收听 29.600 附近的鱼船电台，若能清楚收听到他们的通话时，说明这时 29.600 有传播了，你就可以呼叫全球电台了，成功率很高哦！哈哈，但是 10 米波的传播时间持续时间可能很短哦，大家要抓紧时间通联，重要的是把对方的呼号抄下。功率嘛，不需要大功率，我常常使用 5W，都很好质量了。</p>
<h3 id="20-米波-14270mhz-模式usb"><a class="header" href="#20-米波-14270mhz-模式usb">20 米波 14.270MHZ 模式：USB</a></h3>
<p>白天传播好，有无传播，可以收听广州的 13.149MHZ，海事中转台，它使用率很高，能清楚收听的话，这时你的通话质量一定好，野外白天设台通联，主要就是使用这个波段和 21MHZ</p>
<h3 id="40-米波-7050mhz-模式lsb"><a class="header" href="#40-米波-7050mhz-模式lsb">40 米波 7.050MHZ 模式；LSB</a></h3>
<p>早晚上传播好，早上 5：30-8：30 前是最热闹的，通话质量很好，象听本地 FM 调频广播电台无线电短波电台是呼叫远方电台的主要工具，常常用来呼叫全球电台，晚上传播好的时候，频率上是密密麻麻的信号，只要你的级别允许你使用的频率范围，都可以用英文呼叫国外电台，是无线电通联技术训练和英语学习的好伙伴。晚上主要在 14.150---14.250MHZ 之间，很多国外电台都在此呼叫，是练习英语口语和听力的好机会，凌晨主要在 7MHZ 上，很是热闹的。</p>
<h2 id="ssb-固定频率"><a class="header" href="#ssb-固定频率">SSB 固定频率</a></h2>
<p>广州海岸电台：8782 8716 13107 13149 13149 13182 17398 22735<br />
天津海岸台：13092<br />
上海海岸台：8773<br />
烟台海岸台：13077 17332 8764 4381<br />
湛江海岸台：2182 6501 6200<br />
舟山海翔船务公司：12408<br />
厦门海岸台：8453 4314 12876<br />
美军夏威夷、关岛电台：13362 10320（白天）5765 6350（夜晚）<br />
冰岛电台：13855<br />
东亚太平洋航空天气台：8828<br />
国际海事通讯波段：8195-8815 12330-13200</p>
<h2 id="业余电台无线电主要波段"><a class="header" href="#业余电台无线电主要波段">业余电台无线电主要波段</a></h2>
<p>80 米 3500-3900<br />
40 米 7000-7100（LSB）<br />
20 米 14000-14350<br />
15 米 21000-21450<br />
10 米 28000-29700</p>
<p>SSTV 图象 USB 信号：<br />
日本气象：13597 9970<br />
台湾气象：13900<br />
日本报纸：12745</p>
<h2 id="短波以下频率的划分和常用频点"><a class="header" href="#短波以下频率的划分和常用频点">短波以下频率的划分和常用频点</a></h2>
<p>中国业余电台常用频率:</p>
<p>80m 波段:3.840MHZ 3.843MHZ  3.850MHZ 3.855MHZ<br />
40m 波段:7.030MHZ(CW) 7.050MHZ  7.O53MHZ 7.055MHZ 7.060MHZ  7.068MHZ<br />
20m 波段:14.180MHZ 14.225MHZ 14.270MHZ 14.330MHZ<br />
15m 波段:21.400MHZ<br />
10m 波段:29.600MHZ(FM)<br />
14.180MHZ 是 &quot;B?NET&quot; 的工作频率.每天 8:00 开始.经常有老业余家出现<br />
14.330MHZ 是 &quot;CRSA?NET&quot; 的工作频率.每周二 10:00 开始.</p>
<h2 id="部分-freedom-台频率表"><a class="header" href="#部分-freedom-台频率表">部分 Freedom 台频率表</a></h2>
<h3 id="自由亚洲电台-rfa"><a class="header" href="#自由亚洲电台-rfa">自由亚洲电台 RFA</a></h3>
<p><a href="https://www.rfa.org/mandarin/about/frequencies.html">自由亚洲电台普通话节目</a></p>
<p>A23 频率表 （更新于 2023 年 3 月 25 日）</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">时间</th><th style="text-align: center">频率</th></tr></thead><tbody>
<tr><td style="text-align: center">11:00-12:00</td><td style="text-align: center">11570 11895 11985 17800</td></tr>
<tr><td style="text-align: center">12:00-13:00</td><td style="text-align: center">11895 13750 17800 21505</td></tr>
<tr><td style="text-align: center">13:00-14:00</td><td style="text-align: center">11895 17800 21690</td></tr>
<tr><td style="text-align: center">14:00-15:00</td><td style="text-align: center">11895 13790 17800 17810</td></tr>
<tr><td style="text-align: center">23:00-24:00</td><td style="text-align: center">9940 11675 13810</td></tr>
<tr><td style="text-align: center">24:00-01:00</td><td style="text-align: center">7540 11610 13570 13810</td></tr>
<tr><td style="text-align: center">01:00-02:00</td><td style="text-align: center">9360 9970</td></tr>
<tr><td style="text-align: center">02:00-03:00</td><td style="text-align: center">9360 9970 11760</td></tr>
<tr><td style="text-align: center">03:00-04:00</td><td style="text-align: center">9360 9720</td></tr>
<tr><td style="text-align: center">04:00-05:00</td><td style="text-align: center">6080 9360 9535</td></tr>
<tr><td style="text-align: center">05:00-06:00</td><td style="text-align: center">7435 9685</td></tr>
<tr><td style="text-align: center">07:00-08:00</td><td style="text-align: center">9535 9720 15555</td></tr>
</tbody></table>
</div>
<h3 id="美国之声-voa"><a class="header" href="#美国之声-voa">美国之声 VOA</a></h3>
<p><a href="https://www.voachinese.com/p/6022.html">广播频率表(2023年3月26日–2023年10月28日)​</a></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">时间</th><th style="text-align: center">频率</th></tr></thead><tbody>
<tr><td style="text-align: center">上午 6-7 点</td><td style="text-align: center">5875, 9625</td></tr>
<tr><td style="text-align: center">上午 8-9 点</td><td style="text-align: center">9600, 11660, 15340, 17560</td></tr>
<tr><td style="text-align: center">下午 5-7 点</td><td style="text-align: center">11785, 11825, 13755, 17485, 21695</td></tr>
<tr><td style="text-align: center">晚上 7-8 点</td><td style="text-align: center">7470, 9460, 11785, 11825, 15250</td></tr>
<tr><td style="text-align: center">晚上 8-9 点</td><td style="text-align: center">7470, 11785, 11825, 15250</td></tr>
<tr><td style="text-align: center">晚上 9-10 点</td><td style="text-align: center">6115, 11785, 15130, 15165</td></tr>
<tr><td style="text-align: center">晚上 10-11 点</td><td style="text-align: center">6115, 9465, 11900, 15110</td></tr>
</tbody></table>
</div>
<h2 id="航空-hf"><a class="header" href="#航空-hf">航空 HF</a></h2>
<h3 id="高空-hf-航管khz"><a class="header" href="#高空-hf-航管khz">高空 HF 航管:KHZ</a></h3>
<p>6616(8-20).5481(20-8),备用 11306 中国全境 (以下除外)<br />
6616(9-21).5481(21-9),备用 11306 乌鲁木齐 FIR<br />
11396(8-20).3485(20-8),备用 5655 三亚 FIR<br />
8873(8-20).6682(20-8),备用 8831 拉萨管制区</p>
<h3 id="低空-hf-航管-khz"><a class="header" href="#低空-hf-航管-khz">低空 HF 航管: KHZ</a></h3>
<p>5493(8-20).3449(20-8),备用 6622 上海,广州,武汉,三亚 FIR<br />
5598(8-20).3437(20-8),备用 8816 北京,渖阳 FIR<br />
6565(8-20).3464(20-8),备用 8960 昆明,兰州 FIR<br />
5553(9-21).3464(21-9),备用 8960 乌鲁木齐 FIR</p>
<h3 id="volmethf-航空气象-345856738849132858-24khz"><a class="header" href="#volmethf-航空气象-345856738849132858-24khz">VOLMET(HF 航空气象): 3458.5673.8849.13285(8-24)KHZ</a></h3>
<p>H+01-06,H+31-36: 福州.汕头.南昌.宁波.深圳<br />
H+06-11,H+36-41: 广州.桂林.海口.厦门.南宁.三亚<br />
H+11-16,H+41-46: 长沙.武汉.成都.昆明.重庆.贵阳<br />
H+16-21,H+46-51: 北京.天津.太原.呼和浩特.渖阳.哈尔滨<br />
H+21-26,H+51-56: 西安.兰州.洛阳.长春.乌鲁木齐<br />
H+26-31,H+56-01: 上海.杭州.南京.合肥.宁波.青岛</p>
<h3 id="ldochf-航务通讯"><a class="header" href="#ldochf-航务通讯">LDOC(HF 航务通讯):</a></h3>
<p>3007.4687.6637.8921.8930.10072.11342.11351.<br />
13324.13333.13342.13351.17916.17922.17934.17940.21949.21970</p>
<h3 id="航路管理-24h"><a class="header" href="#航路管理-24h">航路管理: (24H)</a></h3>
<p>130.45 京广航路 AOC,备用 130.95<br />
130.30 京沪航路 AOC,备用 130.95<br />
130.15 沪穗航路 AOC,备用 130.95</p>
<p>全国军民航协调联络: 130.0<br />
国际航空应急频率 (EMG): 121.5(主频), 243.0(军用)<br />
航空专用空对空通信: 123.1<br />
国际 inter-pilot 通讯: 123.45<br />
VHF 数据链路 (DCL,ACARS): 131.45 调制模式为 FM<br />
机场通讯常用航管频率: (步进频率=25kHz)<br />
TWR 塔台 118.xx<br />
GND 地面 121.xx<br />
DLY 放行 121.xx<br />
ATIS 气象 126.xx, 127.xx, 128.xx<br />
D-ATIS 气象数据 131.45<br />
AOC(OP) 机场航务 129.xx, 130.xx, 131.xx</p>
<h2 id="reference"><a class="header" href="#reference">Reference</a></h2>
<p>短波电台频率表： <a href="https://bd6mm.cn/blog/tag/frequency-table">频率表 – BD6MM's Blog</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python"><a class="header" href="#python">Python</a></h1>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Python asyncio 异步协程百万并发
date: 2021-08-18 19:37:48
updated: 2021-08-18 19:37:48
categories: Python
tags: [Python, Coding]
description: Python 异步协程百万并发
thumbnail: http://oss.whaleluo.top/blog/img/Python-Asyncio-banner.png-picsmall
banner_img: http://oss.whaleluo.top/blog/img/Python-Asyncio-banner.png-picsmall
excerpt: Python 异步百万并发全文最详细笔记！！</p>
<hr />
<p><img src="http://oss.whaleluo.top/blog/img/Python-Asyncio-banner.png-picsmall" alt="banner" /></p>
<h1 id="python-asyncio-异步协程百万并发"><a class="header" href="#python-asyncio-异步协程百万并发">Python Asyncio 异步协程百万并发</a></h1>
<h2 id="协程coroutine"><a class="header" href="#协程coroutine">协程（coroutine）</a></h2>
<p>本质就是一个 <strong>函数</strong></p>
<h2 id="事件循环event_loop"><a class="header" href="#事件循环event_loop">事件循环——(event_loop)</a></h2>
<p><strong>协程函数</strong>，不是像普通函数那样直接调用运行的，必须<strong>添加到事件循环</strong>中，然后由<strong>事件循环</strong>去运行，单独运行协程函数是不会有结果的，看一个简单的例子：</p>
<pre><code class="language-python">import time
import asyncio
async def say_after_time(delay,what):
        await asyncio.sleep(delay)
        print(what)
 
async def main():
        print(f&quot;开始时间为： {time.time()}&quot;)
        await say_after_time(1,&quot;hello&quot;)
        await say_after_time(2,&quot;world&quot;)
        print(f&quot;结束时间为： {time.time()}&quot;)
 
loop=asyncio.get_event_loop()    #创建事件循环对象
# loop=asyncio.new_event_loop()   #与上面等价，创建新的事件循环
loop.run_until_complete(main())  #通过事件循环对象运行协程函数
loop.close()
</code></pre>
<p>在 python3.6 版本中，如果我们单独像执行普通函数那样执行一个协程函数，只会返回一个 coroutine 对象（python3.7）如下所示：</p>
<pre><code class="language-python">&gt;&gt;&gt; main()
&lt;coroutine object main at 0x1053bb7c8&gt;
</code></pre>
<h3 id="获取事件循环对象的几种方式"><a class="header" href="#获取事件循环对象的几种方式">获取事件循环对象的几种方式</a></h3>
<pre><code>loop = asyncio.get_event_loop()
</code></pre>
<p>它是 python3.7 中新添加的，<strong>获得一个事件循环</strong>，如果当前线程<strong>还没有事件循环</strong>，则<strong>创建一个新的事件循环 loop；</strong></p>
<h3 id="通过事件循环运行协程函数的两种方式"><a class="header" href="#通过事件循环运行协程函数的两种方式">通过事件循环运行协程函数的两种方式</a></h3>
<ol>
<li>
<p>创建事件循环对象 loop，即 <code>asyncio.get_event_loop()</code>，<strong>通过事件循环运行协程函数</strong>.</p>
</li>
<li>
<p>直接通过 <code>asyncio.run(function_name)</code> 运行<strong>协程函数。</strong></p>
<blockquote>
<p><strong>但是需要注意的是，首先 run 函数是 python3.7 版本新添加的，前面的版本是没有的；</strong></p>
</blockquote>
</li>
</ol>
<p>其次，这个 run 函数总是<strong>会创建一个新的事件循环并在 run 结束之后关闭事件循环</strong>，所以，如果在<strong>同一个线程</strong>中已经有了一个事件循环，则<strong>不能再使用这个函数</strong>了，因为<strong>同一个线程不能有两个事件循环</strong>，而且这个 run 函数<strong>不能同时运行两次</strong>，因为他已经创建一个了。即<strong>同一个线程中是不允许有多个事件循环 loop 的</strong>。</p>
<h2 id="task-任务"><a class="header" href="#task-任务">Task 任务</a></h2>
<h3 id="创建任务两种方法"><a class="header" href="#创建任务两种方法">创建任务（两种方法）</a></h3>
<ol>
<li>
<p><code>task = asyncio.create_task(coro())</code></p>
<blockquote>
<p><strong>这是 3.7 版本新添加的</strong>,<strong>可以传协程函数</strong></p>
</blockquote>
</li>
<li>
<p><code>task = asyncio.ensure_future(coro())</code></p>
</li>
<li>
<p>也可以：</p>
<pre><code class="language-python">loop.create_future()
loop.create_task(coro)
</code></pre>
</li>
</ol>
<h3 id="获取某一个任务的方法"><a class="header" href="#获取某一个任务的方法">获取某一个任务的方法</a></h3>
<ol>
<li>
<p><code>task=asyncio.current_task(loop=None)</code></p>
<blockquote>
<p>返回在某一个指定的 loop 中，<strong>当前正在运行的任务</strong>，<strong>如果没有任务正在运行，则返回 None</strong>；<br />
如果 loop 为 None，<strong>则默认为在当前的事件循环中获取</strong>.</p>
</blockquote>
</li>
<li>
<p><code>asyncio.all_tasks(loop=None)</code></p>
<blockquote>
<p>返回某一个<strong>loop 中还没有结束的任务</strong></p>
</blockquote>
</li>
</ol>
<h2 id="异步函数的结果获取"><a class="header" href="#异步函数的结果获取">异步函数的结果获取</a></h2>
<p>对于异步编程、异步函数而言，最重要的就是<strong>异步函数调用结束之后，获取异步函数的返回值</strong>，我们可以有以下几种方式<strong>来获取函数的返回值</strong>，第一是直接通过 <code>Task.result()</code> 来获取；第二种是<strong>绑定一个回调函数</strong>来获取，<strong>即函数执行完毕后调用一个函数来获取异步函数的返回值。</strong></p>
<ol>
<li>
<p>直接通过 <code>result</code> 来获取.</p>
<pre><code class="language-python">import asyncio
import time


async def hello1(a,b):
    print(&quot;Hello world 01 begin&quot;)
    await asyncio.sleep(3)  #模拟耗时任务3秒
    print(&quot;Hello again 01 end&quot;)
    return a+b

coroutine=hello1(10,5)
loop = asyncio.get_event_loop()                #第一步：创建事件循环
task = asyncio.ensure_future(coroutine)         #第二步:将多个协程函数包装成任务列表
loop.run_until_complete(task)                  #第三步：通过事件循环运行
print('-------------------------------------')
print(task.result())
loop.close() 

'''运行结果为
Hello world 01 begin
Hello again 01 end
-------------------------------------
15
'''
</code></pre>
</li>
<li>
<p>通过定义<strong>回调函数</strong>来获取</p>
</li>
</ol>
<pre><code class="language-python">import asyncio
import time
   
  async def hello1(a,b):
      print(&quot;Hello world 01 begin&quot;)
      await asyncio.sleep(3)  #模拟耗时任务3秒
      print(&quot;Hello again 01 end&quot;)
    return a+b
   
def callback(future):   #定义的回调函数,需要传future参数
    print(future.result())
 
loop = asyncio.get_event_loop()                #第一步：创建事件循环
task=asyncio.ensure_future(hello1(10,5))       #第二步:将多个协程函数包装成任务
task.add_done_callback(callback)                      #并被任务绑定一个回调函数，默认传入结果参数
 
loop.run_until_complete(task)                  #第三步：通过事件循环运行
loop.close()                                   #第四步：关闭事件循环
 
 
'''运行结果为：
Hello world 01 begin
Hello again 01 end
15
'''
</code></pre>
<blockquote>
<p><strong>注意：<strong>​<strong><strong>所谓的</strong></strong>​</strong>回调函数</strong>，就是指协程函数 coroutine<strong>执行结束时候会调用回调函数</strong>。并通过<strong>参数 future 获取协程执行的结果</strong>。我们创建的<strong>task 和回调里的 future 对象</strong>，实际上是<strong>同一个对象</strong>，因为 task 是 future 的子类。</p>
</blockquote>
<h2 id="asyncio-异步编程的基本模板"><a class="header" href="#asyncio-异步编程的基本模板">Asyncio 异步编程的基本模板</a></h2>
<h3 id="第一步构造事件循环"><a class="header" href="#第一步构造事件循环">第一步：构造事件循环</a></h3>
<ol>
<li>
<p><code>loop = asyncio.get_running_loop()</code></p>
<blockquote>
<p>返回（获取）在当前线程中<strong>正在运行的事件循环</strong>，如果没有正在运行的事件循环，则会显示错误；它是<strong>python3.7 中新添加的</strong></p>
</blockquote>
</li>
<li>
<p><code>loop = asyncio.get_event_loop()</code></p>
<blockquote>
<p><strong>获得一个事件循环</strong>，如果当前线程还没有事件循环，则<strong>创建一个新的事件循环 loop</strong>；</p>
</blockquote>
</li>
<li>
<p><code>loop=asyncio.set_event_loop(thread)</code></p>
<blockquote>
<p>设置一个事件循环<strong>为当前线程的事件循环</strong>；</p>
</blockquote>
</li>
<li>
<p><code>loop=asyncio.new_event_loop()</code></p>
<blockquote>
<p><strong>创建一个新的事件循环</strong></p>
</blockquote>
</li>
</ol>
<h3 id="第二步将一个或者是多个协程函数包装成任务-task"><a class="header" href="#第二步将一个或者是多个协程函数包装成任务-task">第二步：将一个或者是多个协程函数包装成任务 Task</a></h3>
<ol>
<li>
<p><code>task = asyncio.create_task(coro(参数列表))</code></p>
<blockquote>
<p><strong>这是 3.7 版本新添加的</strong></p>
</blockquote>
</li>
<li>
<p><code>task = asyncio.ensure_future(coro(参数列表))</code></p>
</li>
</ol>
<blockquote>
<p>需要注意的是，在使用 <code>Task.result()</code> 获取<strong>协程函数结果</strong>的时候，使用 <code>asyncio.create_task()</code> 却会显示错，但是使用 <code>asyncio.ensure_future</code> 却正确</p>
</blockquote>
<h3 id="第三步通过事件循环运行"><a class="header" href="#第三步通过事件循环运行">第三步：通过事件循环运行</a></h3>
<ol>
<li>
<p><code>loop.run_until_complete(asyncio.wait(tasks))</code></p>
<blockquote>
<p>通过 <code>asyncio.wait()</code>​<strong>整合多个 task</strong></p>
</blockquote>
</li>
<li>
<p><code>loop.run_until_complete(asyncio.gather(tasks))</code></p>
<blockquote>
<p>通过 <code>asyncio.gather()</code>​<strong>整合多个 task</strong></p>
</blockquote>
</li>
<li>
<p><code>loop.run_until_complete(task_1)</code></p>
<blockquote>
<p><strong>单个任务则不需要整合</strong></p>
</blockquote>
</li>
<li>
<p><del>loop.run_forever()</del></p>
<blockquote>
<p><del>但是这个方法在新版本已经取消，不再推荐使用，因为使用起来不简洁</del></p>
</blockquote>
</li>
</ol>
<h4 id="使用-gather-和-wait-整合-task-注册多个服务"><a class="header" href="#使用-gather-和-wait-整合-task-注册多个服务">使用 <code>gather</code> 和 <code>wait</code> 整合 Task 注册多个服务</a></h4>
<ol>
<li>
<h4 id="参数形式不一样"><a class="header" href="#参数形式不一样"><strong>参数形式不一样</strong></a></h4>
<p><strong>gather</strong>的参数为 coroutines_or_futures,即如这种形式：</p>
<pre><code class="language-python">tasks = asyncio.gather(*[task1,task2,task3])
tasks = asyncio.gather(task1,task2,task3)
loop.run_until_complete(tasks)
</code></pre>
<p><strong>wait</strong>的参数为<strong>列表或者集合</strong>的形式，如下:</p>
<pre><code class="language-python">tasks = asyncio.wait([task1,task2,task3])
loop.run_until_complete(tasks)
</code></pre>
</li>
<li>
<p><strong>返回的值不一样</strong></p>
<p><strong>gather 返回的是每一个任务运行的结果</strong>：</p>
<blockquote>
<h6 id="要以传入一个列表可变参数"><a class="header" href="#要以传入一个列表可变参数">要以传入一个列表可变参数</a></h6>
</blockquote>
<p><strong>可变参数允许在调用参数的时候传入多个参数,这些参数在调用时被自动组装为一个 tuple</strong></p>
<p><code>results = await asyncio.gather(*[tasks])</code></p>
<p><code>results = await asyncio.gather(task1,task2,task3)</code></p>
<p><strong>wait 返回 dones 是已经完成的任务，pending 是未完成的任务，都是集合类型</strong>：<br />
<code>done, pending = yield from asyncio.wait(fs)</code></p>
</li>
</ol>
<blockquote>
<p>简单来说：<strong>async.wait 会返回两个值:done 和 pending</strong>，done 为已完成的协程 Task，pending 为超时未完成的协程 Task，<strong>需通过 future.result 调用 Task 的 result。</strong></p>
<p>而 <code>async.gather</code> 返回的是<strong>已完成 Task 的 result</strong>。</p>
</blockquote>
<h3 id="第四步关闭事件循环"><a class="header" href="#第四步关闭事件循环">第四步：关闭事件循环</a></h3>
<pre><code class="language-python">loop.close()
# 以上示例都没有调用 loop.close，好像也没有什么问题。所以到底要不要调 loop.close 呢？
</code></pre>
<h2 id="注意"><a class="header" href="#注意">注意</a></h2>
<h3 id="协程阻塞问题"><a class="header" href="#协程阻塞问题">协程阻塞问题</a></h3>
<p><strong>异步方式依然会有阻塞的</strong>，当我们定义的很多个异步方法<strong>彼此之间有一来</strong>的时候，比如，我必须要等到函数 1 执行完毕，<strong>函数 2 需要用到函数 1 的返回值</strong>，就会造成<strong>阻塞</strong>，这也是异步编程的难点之一，如何合理配置这些资源，尽量<strong>减少函数之间的明确依赖</strong>，这是很重要的。</p>
<p><strong>结论</strong>：在有<strong>很多个异步方式</strong>的时候，一定要尽量避免这种<strong>异步函数的直接调用</strong>，这和同步是没什么区别的，一定要<strong>通过事件循环 loop</strong>，<strong>“让事件循环在各个异步函数之间不停游走”</strong>，这样才不会造成阻塞。</p>
<h2 id="代码片段"><a class="header" href="#代码片段">代码片段</a></h2>
<h3 id="使用-gather-同时注册多个任务实现并发"><a class="header" href="#使用-gather-同时注册多个任务实现并发">使用 Gather 同时注册多个任务，实现并发</a></h3>
<pre><code class="language-python">import asyncio
import time
async def hello1(a,b):
    print(&quot;Hello world 01 begin&quot;)
    await asyncio.sleep(3)  #模拟耗时任务3秒
    print(&quot;Hello again 01 end&quot;)
    return a+b
 
async def hello2(a,b):
    print(&quot;Hello world 02 begin&quot;)
    await asyncio.sleep(2)   #模拟耗时任务2秒
    print(&quot;Hello again 02 end&quot;)
    return a-b
 
async def hello3(a,b):
    print(&quot;Hello world 03 begin&quot;)
    await asyncio.sleep(4)   #模拟耗时任务4秒
    print(&quot;Hello again 03 end&quot;)
    return a*b
 
async def main():  #封装多任务的入口函数
    # 用列表表达式创建任务
    tasks = [
        asyncio.ensure_future(hello1(10,5))
        for i in range(10)
    ]
    results = await asyncio.gather(tasks)   
    for result in results:    #通过迭代获取函数的结果，每一个元素就是相对应的任务的返回值，顺序都没变
        print(result)
 
 
loop = asyncio.get_event_loop()               
loop.run_until_complete(main())
loop.close()
</code></pre>
<h3 id="异步--多线程"><a class="header" href="#异步--多线程">异步 + 多线程</a></h3>
<pre><code class="language-python">import asyncio 
import asyncio,time,threading
 
#需要执行的耗时异步任务
async def func(num):
    print(f'准备调用func,大约耗时{num}')
    await asyncio.sleep(num)
    print(f'耗时{num}之后,func函数运行结束')
 
#定义一个专门创建事件循环loop的函数，在另一个线程中启动它
def start_loop(loop):
    asyncio.set_event_loop(loop)
    # 启动事件循环并持续运行
    loop.run_forever()
 
#定义一个main函数
def main():
    coroutine1 = func(3)
    coroutine2 = func(2)
    coroutine3 = func(1)
 
    new_loop = asyncio.new_event_loop()                        #在当前线程下创建时间循环，（未启用），在start_loop里面启动它
    t = threading.Thread(target=start_loop,args=(new_loop,))   #通过当前线程开启新的线程去启动事件循环
    t.start()
 
    asyncio.run_coroutine_threadsafe(coroutine1,new_loop)  #这几个是关键，代表在新线程中事件循环不断“游走”执行
    asyncio.run_coroutine_threadsafe(coroutine2,new_loop)
    asyncio.run_coroutine_threadsafe(coroutine3,new_loop)
 
    for i in &quot;iloveu&quot;:
        print(str(i)+&quot;    &quot;)
 
if __name__ == &quot;__main__&quot;:
    main()
 
'''运行结果为：
i    准备调用func,大约耗时3
l    准备调用func,大约耗时2
o    准备调用func,大约耗时1
v
e
u
耗时1之后,func函数运行结束
耗时2之后,func函数运行结束
耗时3之后,func函数运行结束
'''
</code></pre>
<h3 id="httpx-aiohttp-之异步请求"><a class="header" href="#httpx-aiohttp-之异步请求">Httpx Aiohttp 之异步请求</a></h3>
<ul>
<li><strong>aiohttp 实现</strong></li>
</ul>
<pre><code class="language-python">import aiohttp
import asyncio
 
async def main():
    async with aiohttp.ClientSession() as client:
         async with client.get('http://httpbin.org/get') as resp:
              assert resp.status == 200
              html= await resp.text()
              print(html)
</code></pre>
<ul>
<li><strong>httpx 实现</strong></li>
</ul>
<pre><code class="language-python">async with httpx.AsyncClient() as client:
    resp = await client.get('http://httpbin.org/get')
    assert resp.status_code == 200
    html = resp.text
</code></pre>
<p>感觉总体上比较 <code>aiohttp</code> 写起来舒服多了**，少写很多异步代码。**</p>
<blockquote>
<p>之前使用 aiohttp 中的 resp.status 来获取状态码的时候写了 status_code，应该是使用 requests 习惯了吧，这下好了使用 httpx 不用担心这个写错的问题了。</p>
</blockquote>
<h1 id="深入理解-python-协程"><a class="header" href="#深入理解-python-协程">深入理解 Python 协程</a></h1>
<blockquote>
<p>参考: <a href="https://docs.python.org/zh-cn/3/library/asyncio.html">Python Asyncio 文档</a></p>
</blockquote>
<h2 id="协程"><a class="header" href="#协程">协程</a></h2>
<pre><code class="language-python">import asyncio
import time

# 协程函数返回的是一个协程对象
async def say_after(delay, what):
    await asyncio.sleep(delay)
    print(what)

async def main():
    print(f&quot;started at {time.strftime('%X')}&quot;)

    # 等待1s后再等待2s,不能做到并行运行
    await say_after(1, 'hello') # await 等待协程运行结束
    await say_after(2, 'world')

    print(f&quot;finished at {time.strftime('%X')}&quot;)

# asyncio.run() 函数用来运行最高层级的入口点 &quot;main()&quot; 函数
asyncio.run(main())
</code></pre>
<p><code>asyncio.create_task()</code> 函数用来运行作为 <code>asyncio</code> 任务的多个协程。</p>
<pre><code class="language-python">async def main():
    task1 = asyncio.create_task(
        say_after(1, 'hello'))

    task2 = asyncio.create_task(
        say_after(2, 'world'))

    print(f&quot;started at {time.strftime('%X')}&quot;)

    # 等待两个 task 完成,并行运行,只需要 2s.
    await task1
    await task2

    print(f&quot;finished at {time.strftime('%X')}&quot;)
</code></pre>
<h2 id="可等待对象"><a class="header" href="#可等待对象">可等待对象</a></h2>
<p>如果一个对象可以在 <code>await</code> 语句中使用，那么它就是 <strong>可等待</strong> 对象。</p>
<blockquote>
<p>可等待对象有三种主要类型: <strong>协程</strong>, <strong>任务</strong> 和 <strong>Future</strong>.</p>
</blockquote>
<h3 id="协程-1"><a class="header" href="#协程-1">协程</a></h3>
<p><strong>协程函数</strong>: 定义形式为 <code>async def</code> 的函数;<br />
<strong>协程对象</strong>: 调用 <strong>协程函数</strong> 所返回的对象。</p>
<pre><code class="language-python">import asyncio

# 协程函数
async def nested():
    return 42

async def main():
    # 调用协程函数返回的是协程对象(coroutine object),不能运行
    nested()

    # 协程通过 await 可等待的方式运行
    print(await nested())

asyncio.run(main())
</code></pre>
<h3 id="任务"><a class="header" href="#任务">任务</a></h3>
<p><strong>任务</strong>: 被用来 “并行的” 调度协程<br />
当一个协程通过 <code>asyncio.create_task(coro,*,name=None)</code> 等函数被封装为一个任务，该协程会被 <strong>自动调度</strong> 执行:</p>
<p>该任务会在 <code>get_running_loop()</code> 返回的循环中执行，如果当前线程没有在运行的循环则会引发 <strong>RuntimeError</strong>。</p>
<p><code>task.add_done_callback(func)</code> 设置任务完成的回调函数</p>
<pre><code class="language-python">import asyncio

async def nested():
    return 42

async def main():
    # 将协程封装成一个任务
    task = asyncio.create_task(nested())

    # 等待直到它完成
    await task

asyncio.run(main())
</code></pre>
<p><code>create_task</code> 会把可等待对象被封装为一个任务,该协程会被 <strong>自动调度</strong> 执行,所以不用 <code>await</code></p>
<pre><code class="language-python">import asyncio

async def wait(times: int):
    print(f&quot;等待{times}s&quot;)
    await asyncio.sleep(times)
    print(&quot;等待结束!&quot;)

async def main():
    # asyncio.wait_for(wait(3), 2) 不 await 就出错: RuntimeWarning: coroutine 'wait_for' was never awaited

    # create_task 会把可等待对象被封装为一个任务，该协程会被 **自动调度** 执行,
    # 所以不用 await 也能执行, await 了就表示等待这个任务执行完成!

    asyncio.create_task(asyncio.sleep(5))
    await asyncio.create_task(wait(100))  # 可用于堵塞事件循环,不退出

if __name__ == &quot;__main__&quot;:
    asyncio.run(main())
</code></pre>
<h3 id="futures"><a class="header" href="#futures">Futures</a></h3>
<p><code>Future</code> 是一种特殊的 低层级 可等待对象，表示一个异步操作的 <strong>最终结果</strong>。</p>
<p><strong>通常情况下没有必要在应用层级的代码中创建 ​</strong>​**<code>Future</code><strong>​</strong>​ 对象。**</p>
<h2 id="运行-asyncio-协程"><a class="header" href="#运行-asyncio-协程">运行 Asyncio 协程</a></h2>
<p><code>asyncio.run(coro, *, debug=False)</code><br />
执行 <code>coroutine coro</code> 并返回结果。<br />
此函数会运行传入的协程，负责管理 asyncio 事件循环，终结异步生成器，并关闭线程池。</p>
<p>当有其他 <code>asyncio</code> 事件循环在同一线程中运行时，此函数不能被调用。</p>
<p>如果 debug 为 True，事件循环将以调试模式运行。</p>
<p><strong>此函数总是会创建一个新的事件循环并在结束时关闭之。它应当被用作 asyncio 程序的主入口点，理想情况下应当只被调用一次。</strong></p>
<h2 id="并发运行任务"><a class="header" href="#并发运行任务">并发运行任务</a></h2>
<p><code>asyncio.gather(*aws, return_exceptions=False)</code></p>
<p>并发运行 aws 序列中的可等待对象。<br />
如果 aws 中的某个可等待对象为协程，它将自动被作为一个任务 (asyncio.create_task) 调度。</p>
<p>如果 <code>return_exceptions</code> 为 False (默认)，所引发的首个异常会立即传播给<strong>等待 gather() 的任务</strong>。aws 序列中的其他可等待对象 不会被取消 并将继续运行。</p>
<p>如果 return_exceptions 为 True，异常会和成功的结果一样处理，并聚合至结果列表。</p>
<pre><code class="language-python">import asyncio


async def factorial(name, number):
    &quot;&quot;&quot;计算 number! 阶乘并返回
    example: 3!=1*2*3
    &quot;&quot;&quot;
    # 测试如果出现异常
    if name == &quot;error&quot;:
        print(f&quot;任务名:{name} 出现异常!&quot;)
        raise EOFError
    f = 1
    for i in range(2, number + 1):
        print(f&quot;任务名:{name}:计算阶乘({number}), i={i}...&quot;)
        await asyncio.sleep(1)  # await 使协程等待,让出给其他协程使用
        f *= i
    print(f&quot;任务名{name}: {number}! = {f}&quot;)
    return f

async def main():
    # gather 一起执行可等待对象,并按调用顺序返回
    # gather 会阻塞直到 gather 中的所有可等待对象完成
    print(&quot;async start!&quot;)
    L = await asyncio.gather(
        factorial(&quot;error&quot;, None),
        factorial(&quot;A&quot;, 2),
        factorial(&quot;B&quot;, 3),
        factorial(&quot;C&quot;, 4), return_exceptions=False
    )
    # 当 return_exceptions 为 False 时引发的首个异常会传播给 gather 可等待对象列表的任务
    # 整个程序停摆,未执行完的可等待对象也会取消

    # 当 return_exceptions 为 True，异常会和成功的结果一样处理，并聚合至结果列表。
    # 并不会引发整个程序的异常
    print(f&quot;async result:{L}&quot;)
    print(&quot;async end....&quot;)
asyncio.run(main())
</code></pre>
<p>如果 gather 本身被取消，则无论 <code>return_exceptions</code> 取值为何，消息都会被传播。</p>
<pre><code class="language-python">if name == &quot;error&quot;:
    print(f&quot;任务名:{name} 出现异常!&quot;)
    gather_waiting_object.cancel()  # 取消 gather
# 错误: asyncio.exceptions.CancelledError
</code></pre>
<h2 id="超时"><a class="header" href="#超时">超时</a></h2>
<p>协程 (可等待对象) <code>asyncio.wait_for(aw, timeout)</code></p>
<p>等待 aw 可等待对象 完成，指定 <code>timeout</code> 秒数后超时。<br />
如果 aw 是一个协程，它将自动被作为任务 ((asyncio.create_task)) 调度。<br />
<code>timeout</code> 可以为 None，也可以为 float 或 int 型数值表示的等待秒数。如果 timeout 为 None，则等待直到完成。</p>
<p>如果发生超时，任务将取消并引发 asyncio.TimeoutError.</p>
<p>要避免任务 取消，可以加上 shield()。</p>
<p>此函数将等待直到 Future 确实被取消，所以总等待时间可能超过 timeout。 如果在取消期间发生了异常，异常将会被传播。</p>
<p>如果等待被取消，则 aw 指定的对象也会被取消。</p>
<h2 id="简单等待"><a class="header" href="#简单等待">简单等待</a></h2>
<p>coroutine <code>asyncio.wait(aws, *, timeout=None, return_when=ALL_COMPLETED)</code></p>
<p>并发地运行 aws 可迭代对象中的 <code>可等待对象</code>(不能直接传入协程对象需要转换为 Task) 并进入阻塞状态直到满足 return_when 所指定的条件。</p>
<p>return_when 指定此函数应在何时返回:</p>
<ul>
<li>FIRST_COMPLETED: 在第一个可等待对象运行完毕后返回</li>
<li>FIRST_EXCEPTION: 在任意可等待对象抛出异常后返回,不会结束其他可等待对象,并在程序结束最后抛出异常</li>
<li>ALL_COMPLETED(默认): 在所有可等待对象执行完毕后返回</li>
</ul>
<p>aws 可迭代对象必须不为空。 返回两个 Task/Future 集合: (done, pending)</p>
<p><code>(done, panding)</code>: done: 已完成的协程;panding: 正在等待的协程; 支持通过 <code>if</code> 判断</p>
<pre><code class="language-python">import asyncio


async def wait(name, times: int):
    if name == &quot;A&quot;:
        raise EOFError
    print(f&quot;{name}等待{times}s&quot;)
    await asyncio.sleep(times)
    print(f&quot;{name}等待结束!&quot;)
    return times


async def main():

    task, pending = await asyncio.wait(
        (
            wait(&quot;A&quot;, 3),
            wait(&quot;B&quot;, 2),
            wait(&quot;C&quot;, 1)
        ), return_when=asyncio.FIRST_COMPLETED
    )
    print(&quot;已完成:&quot;, task, &quot;\n等待:&quot;, pending)
    await asyncio.sleep(5)
    print(&quot;抛出异常&quot;)

if __name__ == &quot;__main__&quot;:
    asyncio.run(main())
</code></pre>
<p>(和男朋友出去喝奶茶了,未完待续,可能会继续写一些应用场景,或者和 Golang 的 Goruntine 进行对比)……..<br />
2022/8/24 18:34</p>
<p>所谓「异步 IO」，就是你发起一个 IO 操作，却不用等它结束，你可以继续做其他事情，当它结束时，你会得到通知。</p>
<p>Asyncio 是并发（concurrency）的一种方式。对 Python 来说，并发还可以通过线程（threading）和多进程（multiprocessing）来实现。</p>
<p>Asyncio 并不能带来真正的并行（parallelism）。当然，因为 GIL（全局解释器锁）的存在，Python 的多线程也不能带来真正的并行。</p>
<p>可交给 asyncio 执行的任务，称为协程（coroutine）。一个协程可以放弃执行，把机会让给其它协程（即 <code>yield from</code> 或 <code>await</code>）。`</p>
<h2 id="定义协程"><a class="header" href="#定义协程">定义协程</a></h2>
<p>协程的定义，需要使用 <code>async def</code> 语句。</p>
<p>async def do_some_work(x): pass</p>
<p><code>do_some_work</code> 便是一个协程。<br />
准确来说，<code>do_some_work</code> 是一个协程函数，可以通过 <code>asyncio.iscoroutinefunction</code> 来验证：</p>
<p>print(asyncio.iscoroutinefunction(do_some_work)) # True</p>
<p>这个协程什么都没做，我们让它睡眠几秒，以模拟实际的工作量 ：</p>
<p>async def do_some_work(x):<br />
print(&quot;Waiting &quot; + str(x))<br />
await asyncio.sleep(x)</p>
<p>在解释 <code>await</code> 之前，有必要说明一下协程可以做哪些事。协程可以：</p>
<ul>
<li>等待一个 future 结束</li>
<li>等待另一个协程（产生一个结果，或引发一个异常）</li>
<li>产生一个结果给正在等它的协程</li>
<li>引发一个异常给正在等它的协程</li>
</ul>
<p><code>asyncio.sleep</code> 也是一个协程，所以 <code>await asyncio.sleep(x)</code> 就是等待另一个协程。可参见 <code>asyncio.sleep</code> 的文档：</p>
<p>sleep(delay, result=None, *, loop=None)<br />
Coroutine that completes after a given time (in seconds).</p>
<h2 id="运行协程"><a class="header" href="#运行协程">运行协程</a></h2>
<p>调用协程函数，协程并不会开始运行，只是返回一个协程对象，可以通过 <code>asyncio.iscoroutine</code> 来验证：</p>
<p>print(asyncio.iscoroutine(do_some_work(3))) # True</p>
<p>此处还会引发一条警告：</p>
<p>async1.py:16: RuntimeWarning: coroutine 'do_some_work' was never awaited<br />
print(asyncio.iscoroutine(do_some_work(3)))</p>
<p>要让这个协程对象运行的话，有两种方式：</p>
<ul>
<li>在另一个已经运行的协程中用 <code>await</code> 等待它</li>
<li>通过 <code>ensure_future</code> 函数计划它的执行</li>
</ul>
<p>简单来说，只有 loop 运行了，协程才可能运行。<br />
下面先拿到当前线程缺省的 loop ，然后把协程对象交给 <code>loop.run_until_complete</code>，协程对象随后会在 loop 里得到运行。</p>
<p>loop = asyncio.get_event_loop()<br />
loop.run_until_complete(do_some_work(3))</p>
<p><code>run_until_complete</code> 是一个阻塞（blocking）调用，直到协程运行结束，它才返回。这一点从函数名不难看出。<br />
<code>run_until_complete</code> 的参数是一个 future，但是我们这里传给它的却是协程对象，之所以能这样，是因为它在内部做了检查，通过 <code>ensure_future</code> 函数把协程对象包装（wrap）成了 future。所以，我们可以写得更明显一些：</p>
<p>loop.run_until_complete(asyncio.ensure_future(do_some_work(3)))</p>
<p>完整代码：</p>
<p>import asyncio</p>
<p>async def do_some_work(x):<br />
print(&quot;Waiting &quot; + str(x))<br />
await asyncio.sleep(x)</p>
<p>loop = asyncio.get_event_loop()<br />
loop.run_until_complete(do_some_work(3))</p>
<p>运行结果：</p>
<p>Waiting 3<br />
&lt;三秒钟后程序结束&gt;</p>
<h2 id="回调"><a class="header" href="#回调">回调</a></h2>
<p>假如协程是一个 IO 的读操作，等它读完数据后，我们希望得到通知，以便下一步数据的处理。这一需求可以通过往 future 添加回调来实现。</p>
<p>def done_callback(futu):<br />
print('Done')</p>
<p>futu = asyncio.ensure_future(do_some_work(3))<br />
futu.add_done_callback(done_callback)</p>
<p>loop.run_until_complete(futu)</p>
<h2 id="多个协程"><a class="header" href="#多个协程">多个协程</a></h2>
<p>实际项目中，往往有多个协程，同时在一个 loop 里运行。为了把多个协程交给 loop，需要借助 <code>asyncio.gather</code> 函数。</p>
<p>loop.run_until_complete(asyncio.gather(do_some_work(1), do_some_work(3)))</p>
<p>或者先把协程存在列表里：</p>
<p>coros = [do_some_work(1), do_some_work(3)]<br />
loop.run_until_complete(asyncio.gather(*coros))</p>
<p>运行结果：</p>
<p>Waiting 3<br />
Waiting 1<br />
&lt;等待三秒钟&gt;<br />
Done</p>
<p>这两个协程是并发运行的，所以等待的时间不是 1 + 3 = 4 秒，而是以耗时较长的那个协程为准。</p>
<p>参考函数 <code>gather</code> 的文档：</p>
<blockquote>
<p>gather(*coros_or_futures, loop=None, return_exceptions=False)<br />
Return a future aggregating results from the given coroutines or futures.</p>
</blockquote>
<p>发现也可以传 futures 给它：</p>
<p>futus = [asyncio.ensure_future(do_some_work(1)),<br />
asyncio.ensure_future(do_some_work(3))]</p>
<p>loop.run_until_complete(asyncio.gather(*futus))</p>
<p><code>gather</code> 起聚合的作用，把多个 futures 包装成单个 future，因为 <code>loop.run_until_complete</code> 只接受单个 future。</p>
<h2 id="run_until_complete-和-run_forever"><a class="header" href="#run_until_complete-和-run_forever">run_until_complete 和 run_forever</a></h2>
<p>我们一直通过 <code>run_until_complete</code> 来运行 loop ，等到 future 完成，<code>run_until_complete</code> 也就返回了。</p>
<pre><code class="language-python">async def do_some_work(x):
    print('Waiting ' + str(x))
    await asyncio.sleep(x)
    print('Done')

loop = asyncio.get_event_loop()

coro = do_some_work(3)
loop.run_until_complete(coro)
</code></pre>
<p>输出：</p>
<pre><code class="language-test">Waiting 3
&lt;等待三秒钟&gt;
Done
&lt;程序退出&gt;
</code></pre>
<p>现在改用 <code>run_forever</code>：</p>
<pre><code class="language-python">async def do_some_work(x):  
    print('Waiting ' + str(x))  
    await asyncio.sleep(x)  
    print('Done')

loop = asyncio.get_event_loop()

coro = do_some_work(3)  
asyncio.ensure_future(coro)

loop.run_forever()
</code></pre>
<p>输出：</p>
<pre><code class="language-text">Waiting 3  
&lt;等待三秒钟&gt;  
Done  
&lt;程序没有退出&gt;
</code></pre>
<p>三秒钟过后，future 结束，但是程序并不会退出。<code>run_forever</code> 会一直运行，直到 <code>stop</code> 被调用，但是你不能像下面这样调 <code>stop</code>：</p>
<p>loop.run_forever()<br />
loop.stop()</p>
<p><code>run_forever</code> 不返回，<code>stop</code> 永远也不会被调用。所以，只能在协程中调 <code>stop</code>：</p>
<pre><code class="language-python">async def do_some_work(loop, x):  
    print('Waiting ' + str(x))  
    await asyncio.sleep(x)  
    print('Done')  
    loop.stop()
</code></pre>
<p>这样并非没有问题，假如有多个协程在 loop 里运行：</p>
<pre><code class="language-python">asyncio.ensure_future(do_some_work(loop, 1))  
asyncio.ensure_future(do_some_work(loop, 3))

loop.run_forever()
</code></pre>
<p>第二个协程没结束，loop 就停止了——被先结束的那个协程给停掉的。<br />
要解决这个问题，可以用 <code>gather</code> 把多个协程合并成一个 future，并添加回调，然后在回调里再去停止 loop。</p>
<pre><code class="language-python">async def do_some_work(loop, x):  
    print('Waiting ' + str(x))  
    await asyncio.sleep(x)  
    print('Done')

def done_callback(loop, futu):  
    loop.stop()

loop = asyncio.get_event_loop()

futus = asyncio.gather(do_some_work(loop, 1), do_some_work(loop, 3))  
futus.add_done_callback(functools.partial(done_callback, loop))

loop.run_forever()
</code></pre>
<p>其实这基本上就是 <code>run_until_complete</code> 的实现了，<code>run_until_complete</code> 在内部也是调用 <code>run_forever</code>。</p>
<h2 id="close-loop"><a class="header" href="#close-loop">Close Loop?</a></h2>
<p>以上示例都没有调用 <code>loop.close</code>，好像也没有什么问题。所以到底要不要调 <code>loop.close</code> 呢？<br />
简单来说，loop 只要不关闭，就还可以再运行。：</p>
<pre><code class="language-python">loop.run_until_complete(do_some_work(loop, 1))  
loop.run_until_complete(do_some_work(loop, 3))  
loop.close()
</code></pre>
<p>但是如果关闭了，就不能再运行了：</p>
<pre><code class="language-python">loop.run_until_complete(do_some_work(loop, 1))  
loop.close()  
loop.run_until_complete(do_some_work(loop, 3)) # 此处异常
</code></pre>
<p>建议调用 <code>loop.close</code>，以彻底清理 loop 对象防止误用。</p>
<h2 id="gather-vs-wait"><a class="header" href="#gather-vs-wait">Gather vs. wait</a></h2>
<p><code>asyncio.gather</code> 和 <code>asyncio.wait</code> 功能相似。</p>
<pre><code class="language-python">coros = [do_some_work(loop, 1), do_some_work(loop, 3)]  
loop.run_until_complete(asyncio.wait(coros))
</code></pre>
<p>具体差别可请参见 StackOverflow 的讨论：<a href="https://stackoverflow.com/questions/42231161/asyncio-gather-vs-asyncio-wait">python - Asyncio.gather vs asyncio.wait - Stack Overflow</a>)。</p>
<p>抓住异步的异常：</p>
<pre><code class="language-python">results = await asyncio.gather(*coros, return_exceptions=True)
for result_or_exc in results:
    if isinstance(result_or_exc, Exception):
        print(&quot;I caught:&quot;, repr(result_or_exc))
</code></pre>
<h2 id="timer"><a class="header" href="#timer">Timer</a></h2>
<p>C++ Boost.Asio 提供了 IO 对象 timer，但是 Python 并没有原生支持 timer，不过可以用 <code>asyncio.sleep</code> 模拟。</p>
<pre><code class="language-python">async def timer(x, cb):  
    futu = asyncio.ensure_future(asyncio.sleep(x))  
    futu.add_done_callback(cb)  
    await futu

t = timer(3, lambda futu: print('Done'))  
loop.run_until_complete(t)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Python 并发编程笔记
date: 2021-06-18 19:37:48
updated: 2021-06-18 19:37:48
categories: Python
tags: [Python, Coding]
description: Python并发编程(多线程,多进程,多协程)
thumbnail: http://oss.whaleluo.top/blog/old/20210630201524.png
banner_img: http://oss.whaleluo.top/blog/old/20210630201524.png</p>
<hr />
<h1 id="python-并发编程"><a class="header" href="#python-并发编程">Python 并发编程</a></h1>
<h2 id="各并发技术"><a class="header" href="#各并发技术">各并发技术</a></h2>
<p><img src="http://oss.whaleluo.top/blog/old/20210630200927.png-picsmall" alt="" /></p>
<h2 id="1-多线程-threadthreading"><a class="header" href="#1-多线程-threadthreading">1. 多线程 Thread（threading）</a></h2>
<blockquote>
<ul>
<li>
<p>优点：<strong>相比进程，更轻量级、占用资源少.</strong></p>
</li>
<li>
<p>缺点：</p>
<ul>
<li>相比进程：多线程只能<strong>并发执行</strong>，<strong>不能利用多 CPU（GIL）</strong></li>
<li>相比协程：启动数目<strong>有限制</strong>，占用内存资源，<strong>有线程切换开销</strong></li>
</ul>
</li>
<li>
<p>适用于：<strong>IO 密集型计算</strong>、同时运行的任务数目要求不多</p>
</li>
</ul>
</blockquote>
<h3 id="多进程普通写法"><a class="header" href="#多进程普通写法">多进程普通写法</a></h3>
<pre><code class="language-python">import threading
threads = [] # 线程列表

# 为每个url创建一个线程对象并加入线程列表里
# target: 函数名 args: 函数参数(元组格式)
for url in urls:
    threads.append(
        threading.Thread(target=craw, args=(url,))
    )

# 遍历线程列表启动线程
for thread in threads:
    thread.start()

# 等待线程结束再执行主线程
for thread in threads:
    thread.join()
</code></pre>
<h3 id="利用线程池技术"><a class="header" href="#利用线程池技术">利用线程池技术</a></h3>
<blockquote>
<p>好处: 新建线程系统需要<strong>分配资源</strong>、终止线程系统需要回收资源,线程池可以<strong>重用线程</strong>，则可以<strong>减去新建/终止的开销</strong></p>
</blockquote>
<ul>
<li>
<p>原理</p>
<p><img src="http://oss.whaleluo.top/blog/old/20210630204323.png-picsmall" alt="" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210630204353.png-picsmall" alt="" /></p>
</li>
<li>
<p>代码实现</p>
<ol>
<li><strong>map 方式提交</strong></li>
</ol>
<blockquote>
<p><code>map</code> 的结果和入参是顺序对应的,且 map 传入函数参数时要传入<strong>参数列表</strong></p>
</blockquote>
<blockquote>
<p><a href="https://www.runoob.com/python3/python3-func-zip.html">Python Zip()函数</a>
&gt;&gt;
&gt;&gt;</p>
<blockquote>
<p><strong>zip()</strong> 函数用于将<strong>可迭代的对象作为参数</strong>，将对象中<strong>对应的元素打包成一个个元组</strong>，然后返回由这些<strong>元组组成的对象</strong>，这样做的好处是<strong>节约了不少的内存</strong>。</p>
<p>我们可以使用 <code>list()</code> 转换来输出列表。</p>
<p><strong>元素个数与最短的列表一致</strong>.</p>
<p>如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 ***** 号操作符，可以将元组解压为列表。</p>
</blockquote>
</blockquote>
</li>
</ul>
<blockquote>
<p><img src="http://oss.whaleluo.top/blog/old/20210630211154.png-picsmall" alt="&quot;形象&quot;" /></p>
</blockquote>
<pre><code class="language-python">
from concurrent.futures import ThreadPoolExecutor
# 可以设置线程数
with ThreadPoolExecutor(max_workers=10) as pool:
    # map 向线程池提交任务,传入方法名,以及参数列表
    htmls = pool.map(craw, urls)
    # htmls urls(列表) 都是可迭代对象,可以用 zip 函数将他们打包成一个元组
    htmls = list(zip(urls, htmls))
    # 结果和入参是顺序对应的
    for url, html in htmls:
        print(url, len(html))
</code></pre>
<ol>
<li><strong>submit 方式提交</strong></li>
</ol>
<blockquote>
<p><strong>future 模式，更强大</strong>,注意如果用 <code>as_completed</code> 顺序是不定的</p>
</blockquote>
<blockquote>
<p><a href="https://www.runoob.com/python3/python3-att-dictionary-items.html">Python3 字典 items方法</a></p>
<blockquote>
<p>Python 字典 items() 方法以列表<strong>返回视图对象</strong>，是一个<strong>可遍历的 key/value 对</strong>。</p>
</blockquote>
<p>将: <code>{'Name': 'Runoob', 'Age': 7}</code> 变为: <code>[('Age', 7), ('Name', 'Runoob')]</code></p>
</blockquote>
<ul>
<li>
<p><strong>方法一</strong></p>
<pre><code class="language-python">from concurrent.futures import ThreadPoolExecutor,as_completed
with ThreadPoolExecutor() as pool:
    # 利用线程列表启动
    futures=[
        pool.submit(craw,url)
        for url in urls
    ]

    # 通过遍历线程列表取出结果(要等所有结果运行完才有)
    for future in futures:
        print(future.result())

    # as_completed 不需要等待所有结果运行完才输出结果
    # 一旦有结果运行完就会输出
    for future in as_completed(futures):
        print(future.result())
</code></pre>
</li>
<li>
<p><strong>方法二</strong></p>
<blockquote>
<p><strong>适合需要与某一个量一一对应建立联系</strong></p>
</blockquote>
<pre><code class="language-python">from concurrent.futures import ThreadPoolExecutor
with ThreadPoolExecutor() as pool:
    futures = {}  # 字典,便于一一对应
    # htmls格式: ([],[],[],..)
    # 遍历元组的每个列表,把列表中的两个参数赋值给 url,html
    for url, html in htmls:
        # submwit 提交,传入方法名和单个参数
        future = pool.submit(parse, html)
        # 使用字典 将 future 对象与链接一一对应
        futures[future] = url

    # 将转化为元组的字典遍历出来
    # future-&gt;线程对象 url-&gt;线程对应的url
    for future,url in futures.items():
        # 线程对象通过 result 取出运行结果
        print(url,future.result())
</code></pre>
</li>
</ul>
<h3 id="生产者消费者模型--producer-consumer"><a class="header" href="#生产者消费者模型--producer-consumer">生产者消费者模型 ( Producer, Consumer)</a></h3>
<ol>
<li>
<p>多组件的 <code>Pipeline</code> 技术架构</p>
<blockquote>
<p>复杂的事情一般都不会一下子做完，而是会分<strong>很多中间步骤一步步完成</strong></p>
</blockquote>
<p><img src="http://oss.whaleluo.top/blog/old/20210703065209.png-picsmall" alt="" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210703065255.png-picsmall" alt="" /></p>
</li>
<li>
<p><strong>多线程数据通信的</strong>​**<code>queue.Queue</code>**</p>
<blockquote>
<p><code>queue.Queue</code> 可以用于<strong>多线程之间</strong>的、<strong>线程安全</strong>的数据通信</p>
<p><strong>多个线程</strong> 可以 <strong>同时</strong> 读取 <strong>同一个队列</strong></p>
</blockquote>
<pre><code class="language-python"># 1、导入类库
import queue
# 2、创建Queue
q = queue.Queue()
# 3、添加元素
q.put(item)
# 4、获取元素
item = q.get()
# 5、查询状态
# 查看元素的多少
q.qsize()
# 判断是否为空
q.empty()
# 判断是否已满
q.full()
</code></pre>
</li>
<li>
<p>实例:</p>
<pre><code class="language-python">import threading
import queue
import random,time

# 传入 url 队列 和 Html 队列
def do_craw(url_queue: queue.Queue, html_queue: queue.Queue):
    while True:
        # 从 Url 队列里获取一个链接
        url = url_queue.get()
        html = blog_spider.craw(url)
        # 将获取到的 html 内容放入 html 队列
        html_queue.put(html)
        # current_thead: 当前线程 .name: 获取线程的名字
        print(threading.current_thread().name, f&quot;craw {url}&quot;,
              &quot;url_queue.size=&quot;, url_queue.qsize())
        time.sleep(random.randint(1, 2))


def do_parse(html_queue: queue.Queue, fout):
    while True:
        html = html_queue.get()
        results = blog_spider.parse(html)
        for result in results:
            fout.write(str(result) + &quot;\n&quot;)
        print(threading.current_thread().name, f&quot;results.size&quot;, len(results),
              &quot;html_queue.size=&quot;, html_queue.qsize())
        time.sleep(random.randint(1, 2))


if __name__ == &quot;__main__&quot;:
    url_queue = queue.Queue() # 链接队列
    html_queue = queue.Queue() # Html 文件队列
    # 将所有链接添加到链接队列里面
    for url in urls:
        url_queue.put(url)

    # 创建链接访问线程
    for idx in range(3):
        t = threading.Thread(target=do_craw, args=(url_queue, html_queue),
                             name=f&quot;craw{idx}&quot;)
        t.start()

    # 创建 HTML 解析线程
    fout = open(&quot;02.data.txt&quot;, &quot;w&quot;)
    for idx in range(2):
        # name: 设置线程的名字.
        t = threading.Thread(target=do_parse, args=(html_queue, fout),
                             name=f&quot;parse{idx}&quot;)
        t.start()

</code></pre>
</li>
</ol>
<h2 id="2-多进程-multiprocess"><a class="header" href="#2-多进程-multiprocess">2. 多进程 (MultiProcess)</a></h2>
<h3 id="全局解释器锁-python-的大缺点"><a class="header" href="#全局解释器锁-python-的大缺点">全局解释器锁 (Python 的大缺点)</a></h3>
<ol>
<li><strong>任何时刻仅有一个线程</strong>在执行。</li>
<li>在<strong>多核心处理器上</strong>，使用 GIL 的解释器也只允许同一时间执行一个线程</li>
<li>GIL 目的：为了解决多线程之间<strong>数据完整性</strong>和状态同步问题</li>
<li>GIL 带来的<strong>问题</strong></li>
</ol>
<ul>
<li>即使使用了多线程，同一时刻也只有<strong>单个线程使用 CPU</strong>，导致多核 CPU 的浪费</li>
<li>GIL 只会对<strong>CPU 密集型</strong>的程序产生影响</li>
<li>如果程序主要是在做<strong>I/O 操作</strong>，比如<strong>处理网络连接</strong>，那么<strong>多线程技术</strong>常常是一个明智的选择</li>
</ul>
<ol>
<li><strong>规避 GIL</strong>的方法</li>
</ol>
<ul>
<li>规避方法 2： 使用 <code>multiprocessing</code> 多进程，对 CPU 密集型计算，单独启动子进程解释器去执行</li>
<li>规避方法 2： ﻿将计算密集型的任务转移到<strong>C 语言</strong>中，因为 C 语言比 Python 快得多，注意要在 C 语言中自己释放 GIL</li>
</ul>
<p><img src="http://oss.whaleluo.top/blog/old/20210701000441.png-picsmall" alt="" /></p>
<blockquote>
<h3 id="多进程适用于-cpu-密集型计算"><a class="header" href="#多进程适用于-cpu-密集型计算">多进程适用于 CPU 密集型计算</a></h3>
<p>多进程的 API 与 <strong>多线程的实现十分类似</strong></p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">语法条目</th><th style="text-align: center">多线程</th><th style="text-align: center">多进程</th></tr></thead><tbody>
<tr><td style="text-align: left">引入模块</td><td style="text-align: center">from threading import Thread</td><td style="text-align: center">from multiprocessing import Process</td></tr>
<tr><td style="text-align: left">新建  启动  等待结束</td><td style="text-align: center">t=Thread(target=func, args=(100, ))  t.start()  t.join()</td><td style="text-align: center">p = Process(target=f, args=('bob',))  p.start()  p.join()</td></tr>
<tr><td style="text-align: left">数据通信</td><td style="text-align: center">import queue  q = queue.Queue()  q.put(item)  item = q.get()</td><td style="text-align: center">from multiprocessing import Queue  q = Queue()  q.put([42, None, 'hello'])  item = q.get()</td></tr>
<tr><td style="text-align: left">线程安全加锁</td><td style="text-align: center">from threading import Lock  lock = Lock()  with lock:      # do something</td><td style="text-align: center">from multiprocessing import Lock  lock = Lock()  with lock:      # do something</td></tr>
<tr><td style="text-align: left">池化技术</td><td style="text-align: center">from concurrent.futures import  ThreadPoolExecutor    with ThreadPoolExecutor() as executor:      # 方法 1      results = executor.map(func, [1,2,3])        # 方法 2      future = executor.submit(func, 1)      result = future.result()</td><td style="text-align: center">from concurrent.futures import ProcessPoolExecutor    with ProcessPoolExecutor() as executor:      # 方法 1      results = executor.map(func, [1,2,3])        # 方法 2      future = executor.submit(func, 1)      result = future.result()</td></tr>
</tbody></table>
</div>
<h3 id="利用进程池技术实现多进程"><a class="header" href="#利用进程池技术实现多进程"><strong>利用进程池技术实现多进程</strong></a></h3>
<pre><code class="language-python">from concurrent.futures import ProcessPoolExecutor
import time

def test(lover):
    print(&quot;我喜欢:&quot;, lover)
    time.sleep(1)

# 任何池化技术都需要写程序入口
if __name__ == &quot;__main__&quot;:
    # 喜欢的人列表
    lovers = [&quot;颖怡&quot;, &quot;菲菲&quot;, &quot;詹天佑&quot;]
    start_time = time.time()
    # 1. 使用 map 方式提交
    with ProcessPoolExecutor(max_workers=10) as pool:
        # map 方式提交进程池需要传入函数名和多参数元组
        pool.map(test, lovers)

    # 2. 使用 submit 方式提交
    with ProcessPoolExecutor() as pool:
        # 利用进程列表启动
        futures=[
            pool.submit(test,lover)
            for lover in lovers
        ]

    end_time = time.time()
    print(&quot;cost Time:&quot;, end_time-start_time)
</code></pre>
<h2 id="3-并发锁-concurrent-lock"><a class="header" href="#3-并发锁-concurrent-lock">3. 并发锁 (Concurrent Lock)</a></h2>
<blockquote>
<p><strong>线程安全</strong>指某个函数、函数库在<strong>多线程环境</strong>中被调用时，能够正确地处理多个线程之间的<strong>共享变量</strong>，使程序功能正确完成。</p>
<p>由于<strong>线程的执行随时会发生切换</strong>，就造成了不可预料的结果，出现<strong>线程不安全</strong>(简单来说就是程序串行)</p>
</blockquote>
<p><img src="http://oss.whaleluo.top/blog/old/20210702130844.png-picsmall" alt="" /></p>
<pre><code class="language-python">import threading
# 实例化锁对象
lock = threading.Lock()
# 上锁
lock.locked()
# 释放锁
lock.release()
</code></pre>
<h3 id="用法-1-try-finally-模式"><a class="header" href="#用法-1-try-finally-模式">用法 1: <code>try-finally</code> 模式</a></h3>
<pre><code class="language-python">import threading
lock = threading.Lock()
lock.acquire()
try:
    # do something
finally:
    lock.release()
</code></pre>
<h3 id="用法-2-with-模式-推荐这种方式"><a class="header" href="#用法-2-with-模式-推荐这种方式">用法 2: <code>with</code> 模式 <strong>(推荐这种方式)</strong></a></h3>
<pre><code class="language-python">import threading
lock = threading.Lock()
with lock:
    # do something
</code></pre>
<h3 id="什么时候需要上锁"><a class="header" href="#什么时候需要上锁">什么时候需要上锁</a></h3>
<blockquote>
<p><strong>多人读,不需要|一读一写要加|多人写要加</strong></p>
</blockquote>
<p>只是操作<strong>共享变量</strong>部分的代码要<strong>上锁</strong>,而不是多线程中所有代码都要上锁,并<strong>不影响多线程</strong>的执行效果.</p>
<p><img src="http://oss.whaleluo.top/blog/old/20210702143102.png-picsmall" alt="image-20210702143100587" /></p>
<h2 id="4-异步协程"><a class="header" href="#4-异步协程">4. 异步协程</a></h2>
<h3 id="原理-1"><a class="header" href="#原理-1">原理</a></h3>
<blockquote>
<p>同步：执行 IO 操作时，<strong>必须等待执行完成才得到返回结果</strong>。<br />
异步：执行 IO 操作时，<strong>不必等待执行就能得到返回结果</strong>。</p>
</blockquote>
<p><img src="http://oss.whaleluo.top/blog/old/20210702150837.jpeg-picsmall" alt="" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210702143833.png-picsmall" alt="image-20210702143832079" /></p>
<blockquote>
<p>注意：要用在<strong>异步 IO 编程中</strong>,依赖的<strong>库必须支持异步 IO 特性.</strong></p>
<p>爬虫引用中：<code>requests</code> 不支持异步|需要用 <code>aiohttp</code></p>
</blockquote>
<h3 id="补充"><a class="header" href="#补充">补充</a></h3>
<h4 id="1-什么是协程异步"><a class="header" href="#1-什么是协程异步">1. 什么是协程、异步</a></h4>
<p>举个例子：假设有 1 个洗衣房，里面有 10 台洗衣机，有一个洗衣工在负责这 10 台洗衣机。那么<strong>洗衣房就相当于 1 个进程</strong>，洗衣工就相当<strong>1 个线程</strong>。如果有 10 个洗衣工，就相当于<strong>10 个线程</strong>，<strong>1 个进程是可以开多线程的</strong>。这就是多线程！</p>
<p>那么协程呢？先不急。大家都知道，洗衣机洗衣服是<strong>需要等待时间</strong>的，如果 10 个洗衣工，1 人负责 1 台洗衣机，这样效率肯定会提高，但是不觉得<strong>浪费资源</strong>吗？明明 1 个人能做的事，却要 10 个人来做。只是把衣服放进去，打开开关，<strong>就没事做</strong>了，等衣服洗好再拿出来就可以了。就算很多人来洗衣服，<strong>1 个人也足以应付了</strong>，开好第一台洗衣机，在等待的时候去<strong>开第二台洗衣机，再开第三台</strong>，……直到有衣服洗好了，就回来把衣服取出来，接着<strong>再取另一台</strong>的（哪台洗好先就取哪台，所以<strong>协程是无序的</strong>）。这就是计算机的协程！洗衣机就是<strong>执行的方法</strong>。</p>
<p>当你程序中方法需要等待时间的话，就可以用<strong>协程</strong>，<strong>效率高，消耗资源少。</strong></p>
<p><strong>洗衣房 ==&gt; 进程 | 洗衣工 ==&gt; 线程 | 洗衣机 ==&gt; 方法 (函数)</strong></p>
<h4 id="2-async--await-的使用"><a class="header" href="#2-async--await-的使用">2. <code>async</code> \ <code>await</code> 的使用</a></h4>
<p>正常的函数在执行时是<strong>不会中断</strong>的，所以你要写一个<strong>能够中断</strong>的函数，就需要添加 <code>async</code> 关键字。</p>
<p><code>async</code> 用来声明一个函数为异步函数，异步函数的特点是<strong>能在函数执行过程中挂起，去执行其他异步函数</strong>，等到<strong>挂起条件</strong>（假设挂起条件是 sleep(5)）消失后，也就是 5 秒到了<strong>再回来执行</strong>。</p>
<p><code>await</code> 用来用来声明<strong>程序挂起</strong>，比如异步程序执行到<strong>某一步时需要等待的时间很长，就将此挂起</strong>，去<strong>执行其他的异步程序</strong>。<code>await</code> 后面只能跟 <strong>异步函数</strong> 或有 <code>__await__</code> 属性的对象，因为<strong>异步程序与一般程序不同</strong>。</p>
<p>假设有两个异步函数 <code>async a，async b</code>，a 中的某一步有 <code>await</code>，当程序碰到关键字 <code>await b()</code> 后，异步程序挂起后去执行另一个异步 b 程序，就是从<strong>函数内部跳出去执行其他函数</strong>，<strong>当挂起条件消失后，不管 b 是否执行完，要马上从 b 程序中跳出来</strong>，<strong>回到原程序执行原来</strong>的操作。如果 await 后面跟的<strong>b 函数不是异步函数</strong>，那么操作就<strong>只能等 b 执行完再返回</strong>，无法在<strong>b 执行的过程中返回</strong>。如果要在<strong>b 执行完</strong>才返回，也就<strong>不需要用 await 关键字了</strong>，直接<strong>调用 b 函数</strong>就行。所以这就需要 <code>await</code> 后面跟的是<strong>异步函数</strong>了。在一个异步函数中，可以<strong>不止一次挂起</strong>，也就是可以用多个 <code>await</code>。</p>
<h3 id="基本实现"><a class="header" href="#基本实现"><strong>基本实现:</strong></a></h3>
<blockquote>
<ul>
<li>
<ol>
<li>在普通的函数前面加 <strong>async</strong> 关键字；</li>
</ol>
</li>
<li>
<ol start="2">
<li><code>await</code> 表示在这个地方<strong>等待子函数执行完成</strong>，再往下执行。（在并发操作中，把程序控制权交给主程序，让他分配其他协程执行。） <code>await</code> 只能在带有 <code>async</code> 关键字的函数中运行。</li>
</ol>
</li>
</ul>
</blockquote>
<pre><code class="language-python"># 异步io简单实现
import asyncio
import time
# 获取超级事件循环
# event:事件 loop:环
loop = asyncio.get_event_loop()
urls = [
    f&quot;https://skyxinye.xyz/#{page}&quot;
    for page in range(1, 99)
]

# 定义协程函数
async def myfunc(url):
    await time.sleep(2) # 这样写不行,因为 time.sleep 不是异步函数,不能中途跳出执行另一个协程.
    await asyncio.sleep(2) # 用协程函数.
# 创建 task 列表
# create:创造
tasks = [
    # 在超级循环中创造多个任务,并设置等待任务完成.(如果协程函数中没有同步操作的话就不用设置)
    # 任务没有运行
    loop.create_task(asyncio.wait(myfunc(url)))
    for url in urls
]
# 执行异步事件列表,运行直到完成,如果是协程列表就要设置等待事件完成.
loop.run_until_complete(asyncio.wait(tasks))
</code></pre>
<h4 id="利用-aiohttp-模块发送网络请求"><a class="header" href="#利用-aiohttp-模块发送网络请求">利用 <code>aiohttp</code> 模块发送网络请求</a></h4>
<pre><code class="language-python"># 异步模块 aiohttp 使用
import asyncio
import aiohttp


# Http请求 协程函数
# GET
async def async_get(url):
    &quot;&quot;&quot;
    aiohttp:发送http请求
    1.创建一个ClientSession对象
    2.通过ClientSession对象去发送请求（get, post, delete等）
    3.await 异步等待返回结果
    &quot;&quot;&quot;
    print(&quot;Get Url:&quot;, url)
    async with aiohttp.ClientSession() as se:
        async with se.get(url) as resp:
            result = await resp.text()
            print(len(result))

urls = [
    f&quot;https://skyxinye.xyz/#{page}&quot;
    for page in range(1, 99999)
]

# 超级循环
loop = asyncio.get_event_loop()
# 事件列表
tasks=[
    loop.create_task(async_get(url))
    for url in urls 
]
# 用 wait 方法遍历事件列表.协程列表需要设置等待运行完成
loop.run_until_complete(asyncio.wait(tasks))

&quot;&quot;&quot;
    异步协程不用事件列表的另一种实现方法
    aiohttp:发送POST请求
&quot;&quot;&quot;
# POST
async def main():
    data = {'key1': 'value1', 'key2': 'value2'}
    url = 'http://httpbin.org/post'
    async with aiohttp.ClientSession() as session:
        async with session.post(url, data=data) as res:
            print(res.status)
            print(await res.text())
loop = asyncio.get_event_loop()
# 如果是单个协程就不需要设置 asyncio.wait()
task = loop.create_task(main())
loop.run_until_complete(task)
</code></pre>
<h4 id="利用-aiofile-异步操作文件"><a class="header" href="#利用-aiofile-异步操作文件">利用 <code>aiofile</code> 异步操作文件</a></h4>
<pre><code class="language-python">import aiofiles
import asyncio

async def write():
    async with aiofiles.open(&quot;test.txt&quot;,&quot;w&quot;,encoding=&quot;utf8&quot;) as fp:
        await fp.write(&quot;异步写入文件&quot;)
        print(&quot;文件写入成功&quot;)

async def read():
    async with aiofiles.open(&quot;test.txt&quot;,&quot;r&quot;,encoding=&quot;utf8&quot;) as fp:
        content = await fp.read()
        print(content)

async def read2_demo():
    async with aiofiles.open(&quot;text.txt&quot;,&quot;r&quot;,encoding=&quot;utf-8&quot;) as fp:
        # 读取每行
        async for line in fp:
            print(line)

if __name__==&quot;__main__&quot;:
    asyncio.run(write())
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Python 迭代器生成器修饰器
date: 2021-08-18 19:37:48
updated: 2021-08-18 19:37:48
categories: Python
tags: [Python, Coding]
description: Python 迭代器生成器修饰器,Python 中三大名器的完全总结！个人总结，算是比较详细的了。
thumbnail: http://oss.whaleluo.top/blog/old/20210630201524.png
banner_img: http://oss.whaleluo.top/blog/old/20210630201524.png</p>
<hr />
<h1 id="python-generator-iterator-decorater"><a class="header" href="#python-generator-iterator-decorater">Python-Generator-Iterator-decorater</a></h1>
<h2 id="迭代器"><a class="header" href="#迭代器">迭代器</a></h2>
<blockquote>
<p><strong>迭代器</strong>指的是迭代取值的工具，迭代是一个重复的过程，并且每次重复都是基于上一次的结果而继续的，</p>
<p>单纯的重复并不是迭代!</p>
</blockquote>
<ol>
<li>
<p>可迭代对象</p>
<p>元组; 列表; 字典; 集合; 字符串等</p>
<p>生成器.</p>
</li>
<li>
<p>用 for 循环迭代</p>
</li>
<li>
<p>验证一个东西是否可迭代</p>
<blockquote>
<p><strong>可迭代不一定是迭代对象</strong></p>
<p>(列表不是可迭代对象,但是可迭代.)</p>
</blockquote>
<pre><code class="language-python">from collections import Iterable
# 判断是否是可迭代对象(迭代器)
isinstance(&quot;adb&quot;,Iterable) # instance:实例
</code></pre>
</li>
<li>
<p>生成器可迭代,但可以迭代的不一定是生成器</p>
</li>
<li>
<p><code>iter()</code> 可以将列表变成可迭代对象</p>
</li>
</ol>
<h3 id="迭代器的作用"><a class="header" href="#迭代器的作用">迭代器的作用</a></h3>
<p>迭代器是用来<strong>迭代取值</strong>的工具，而涉及到把多个值循环取出来的类型</p>
<blockquote>
<p>有：列表、字符串、元组、字典、集合、打开文件</p>
</blockquote>
<pre><code class="language-python">l = ['egon', 'liu', 'alex']
i = 0
while i &lt; len(l):
    print(l[i])
    i += 1
</code></pre>
<p>上述<strong>迭代取值的方式</strong>只适用于<strong>有索引</strong>的数据类型：<strong>列表、字符串、元组.</strong><br />
为了解决基于索引迭代器取值的局限性<br />
python 必须提供一种能够不<strong>依赖于索引的取值方式</strong>，这就是<strong>迭代器</strong>.</p>
<h3 id="迭代器详解"><a class="header" href="#迭代器详解">迭代器详解</a></h3>
<p>但凡内置有 <code>__iter__()</code> 方法的对象都称之为<strong>可迭代的对象</strong>:</p>
<pre><code class="language-python">s1=''
s1.__iter__()

l=[]
l.__iter__()

t=(1,)
t.__iter__()

d={'a':1}
d.__iter__()

set1={1,2,3}
set1.__iter__()

with open('a.txt',mode='w') as f:
    f.__iter__()
    pass
</code></pre>
<p><strong>迭代器对象</strong>:</p>
<p>内置有 <code>__next__</code> 方法并且内置有 <code>__iter__</code> 方法的对象<br />
迭代器对象 <code>__next()__</code>：得到迭代器的下一个值.<br />
迭代器对象 <code>__iter__()</code>：得到迭代器的本身，调用和没调用相同.</p>
<pre><code class="language-python">d={'a':1,'b':2,'c':3}
d_iterator=d.__iter__()
print(d_iterator)    # &lt;dict_keyiterator object at 0x0000022FF0E13A90&gt;

print(d_iterator.__next__()) # a
print(d_iterator.__next__()) # b
print(d_iterator.__next__()) # c
print(d_iterator.__next__()) # 抛出异常StopIteration,值取完了
d={'a':1,'b':2,'c':3}
d_iterator=d.__iter__()

while True:
    try:
        print(d_iterator.__next__())
    except StopIteration:
        break
# 得到&quot;a&quot;,&quot;b&quot;,&quot;c&quot;
print('====&gt;&gt;&gt;&gt;&gt;&gt;') # 在一个迭代器取值取完后，再对其取值就会报错
d_iterator=d.__iter__()
while True:
    try:
        print(d_iterator.__next__())
    except StopIteration:
        break
# 什么都得不到,因为迭代器值已取完


l=[1,2,3,4,5]
l_iterator=l.__iter__()

while True:
    try:
        print(l_iterator.__next__())
    except StopIteration:
        break
# 得到1,2,3,4,5
</code></pre>
<p>常见<strong>数据类型</strong>的分类:</p>
<blockquote>
<p>可迭代对象：<strong>字符串、列表、元组、字典、集合、文件对象</strong><br />
迭代器对象：<strong>文件对象</strong></p>
</blockquote>
<pre><code class="language-python">s1=''
s1.__iter__()

l=[]
l.__iter__()

t=(1,)
t.__iter__()


d={'a':1}
d.__iter__()

set1={1,2,3}
set1.__iter__()


with open('a.txt',mode='w') as f:
    f.__iter__()
    f.__next__()
</code></pre>
<h3 id="创建一个迭代器"><a class="header" href="#创建一个迭代器">创建一个迭代器</a></h3>
<p>把一个类作为一个迭代器使用需要在类中实现两个方法 <code>iter()</code> 与 <code>next()</code> 。</p>
<ol>
<li>
<p><code>iter()</code> 方法返回一个特殊的迭代器对象,这个迭代器对象实现了 <code>next()</code> 方法并通过 <code>StopIteration</code> 异常标识迭代的完成。</p>
</li>
<li>
<p><code>next()</code> 方法会返回<strong>下一个迭代器对象</strong>。</p>
</li>
<li>
<p><strong>StopIteration</strong></p>
<p><code>StopIteration</code> 异常用于标识<strong>迭代的完成</strong>，防止出现无限循环的情况，在 <strong>next</strong>() 方法中我们可以设置在完成指定循环次数后触发 <code>StopIteration</code> 异常来结束迭代。</p>
</li>
</ol>
<blockquote>
<p>创建一个返回数字的迭代器，初始值为 1，逐步递增 1</p>
</blockquote>
<pre><code class="language-python">class MyNumbers:
  def __iter__(self):
    # 初始化迭代器
    self.a = 1
    return self
 
  def __next__(self):
    # 迭代器返回值
    if self.a &lt;= 20:
      x = self.a
      self.a += 1
      return x
    else:
      raise StopIteration
 
myclass = MyNumbers()
myiter = iter(myclass)
 
for x in myiter:
  print(x)

# fun2:
myiter = iter(myclass)
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
</code></pre>
<h3 id="for-循环的工作原理"><a class="header" href="#for-循环的工作原理">For 循环的工作原理</a></h3>
<p>for 循环可以称之为叫<strong>迭代器循环</strong></p>
<pre><code class="language-json">d = {'a':1,'b':2,'c':3}
</code></pre>
<ol>
<li><code>d.iter()</code> 得到一个迭代器对象</li>
<li><code>迭代器对象.next()</code> 拿到一个返回值，然后将该返回值赋值给 k</li>
<li>循环往复,直到抛出 <code>StopIteration</code> 异常<strong>for 循环会捕捉异常然后结束循环.</strong></li>
</ol>
<pre><code class="language-python">d = {'a':1,'b':2,'c':3}
for k in d:   # d_it = d.__iter__()
    print(k)  # 循环k = d_it.__next__()直到抛出异常结束循环

with open('a.txt',mode='rt',encoding='utf-8') as f:
    for line in f: # f.__iter__()
        print(line)

list('hello') # 原理同for循环
</code></pre>
<h2 id="生成器"><a class="header" href="#生成器">生成器</a></h2>
<p>在 Python 中，使用了 <code>yield</code> 的函数被称为<strong>生成器</strong>（generator）。</p>
<p>跟普通函数不同的是，生成器是<strong>一个返回迭代器的函数</strong>，只能用于<strong>迭代操作</strong>，更简单点理解<strong>生成器就是一个迭代器</strong>。</p>
<p>在<strong>调用生成器</strong>运行的过程中，每次遇到 <code>yield</code> 时函数会<strong>暂停并保存当前所有的运行信息</strong>，<strong>返回 ​</strong>​**<code>yield</code><strong>​</strong>​ 的值**, 并在下一次执行 <code>next()</code> 方法时<strong>从当前位置继续运行</strong>。</p>
<p><strong>调用一个生成器函数，返回的是一个迭代器对象。</strong></p>
<h3 id="生成器的使用"><a class="header" href="#生成器的使用">生成器的使用</a></h3>
<pre><code class="language-python">def func():
    print('第一次')
    yield 1
    print('第二次')
    yield 2
    print('第三次')
    yield 3
    print('第四次')

g = func()
print(g)
# 生成器就是迭代器
# 生成器函数返回的是可迭代对象.
g.__iter__()

# g.__next__()会触发函数体代码的运行，然后遇到yield停下来，将yield后的值
# 当做本次调用的结果返回
g = func()
# 可以用iter将可迭代对象转化为迭代器.用next()方法
print(g)

g.__iter__()

res1 = g.__next__()
# 第一次
print(res1)
# 1

res2 = g.__next__()
# 第二次
print(res2)
# 2

res3 = g.__next__()
# 第三次
print(res3)
# 3

res4 = g.__next__()
# 第四次
# StopIteration
</code></pre>
<p>实例: 使用 <code>yield</code> 实现斐波那契数列：</p>
<pre><code class="language-python">def fibonacci(n):  # 生成器函数 - 斐波那契
    a, b, counter = 0, 1, 0
    while True:
        if (counter &gt; n):
            return
        yield a
        a, b = b, a + b
        counter += 1


f = fibonacci(10)  # f 是一个迭代器，由生成器返回生成

while True:
    try:
        print(next(f), end=&quot; &quot;)
    except StopIteration:
        break
</code></pre>
<h3 id="yield-关键字"><a class="header" href="#yield-关键字"><code>yield</code> 关键字</a></h3>
<p>yield 关键字的作用是<strong>函数与调用者</strong>的通信，它不光能够将<strong>值返回给调用者</strong>，它还可以<strong>接收调用者传过来的值</strong>，那么怎么实现呢？ 调用者通过 <code>send()</code> 函数将值传递给<strong>generator</strong>，<strong>generator</strong>通过 <code>yield</code> 前面的变量 (形如:<code>n = yield)</code> 来接收</p>
<pre><code class="language-python">&gt;&gt;&gt; def test():
 number = 0
 while True:
  n = yield number
  print('我是yield关键字下面一行代码')
  print('调用者传递过来的值为:', n)
 
  
&gt;&gt;&gt; t = test()
&gt;&gt;&gt; t.send(None)  
# 当第一次执行生成器的时候，需要传入None

&gt;&gt;&gt; t.send(1)
我是yield关键字下面一行代码
调用者传递过来的值为: 1

&gt;&gt;&gt; t.send(2)
我是yield关键字下面一行代码
调用者传递过来的值为: 2
t.close() 关闭generator后再调用，会出现StopIteration异常
&gt;&gt;&gt; next(t)
我是yield关键字下面一行代码
调用者传递过来的值为: None
</code></pre>
<blockquote>
<p>可以发现，<code>send</code> 函数和 <code>next</code> 函数的区别就是 <code>send</code> 函数可以在执行 generator 的<strong>过程中</strong>，给<strong>generator</strong>发送消息。<strong>而 next 仅仅是接收 yield 右边的变量值</strong>。</p>
</blockquote>
<h3 id="send方法用法"><a class="header" href="#send方法用法"><code>send()</code>​<strong>方法用法</strong></a></h3>
<ol>
<li>
<p><strong>send 过来的数值 = yield next 出来的数值</strong></p>
</li>
<li>
<p>它的主要作用是，当我需要<strong>手动更改生成器里面的某一个值并且使用它</strong>，则<strong>send 发送进去一个数据</strong>，然后<strong>保存到 yield 语句的返回值</strong>，以提供使用.</p>
</li>
<li>
<p><code>send()</code> 的返回值就是那个<strong>本来应该被迭代出来的那个值</strong>。这样既可以<strong>保证我能够传入新的值，原来的值也不会弄丢.</strong></p>
</li>
<li>
<p>实例:</p>
<pre><code class="language-python">def my_generator(n):
    '''定义一个生成器'''
    for i in range(n):
        # send来的数值 = yield 数值
        num = yield i
        print(f'传入的{num}')

g = my_generator(5)
print(next(g))
print(next(g))
a = g.send(100)
print('我是{0}'.format(a))
print(next(g))
print(next(g))
''' 结果
0
传入的None
1
传入的100 
我是2     
传入的None
3
传入的None
4
'''
</code></pre>
</li>
</ol>
<h3 id="throw-方法用法"><a class="header" href="#throw-方法用法"><code>throw()</code> 方法用法</a></h3>
<blockquote>
<p>简单来说就是:<strong>向生成器扔去一个异常,使生成器停止.</strong></p>
</blockquote>
<p><code>raise exception in generator，return next yielded value or StopIteration</code>，即在<strong>生成器中抛出异常</strong>，并且这个 throw 函数会<strong>返回下一个要迭代的值</strong>或者是<strong>StopIteration</strong>。还是通过几个例子来看吧！</p>
<pre><code class="language-python">def my_generator():
    yield 'a'
    yield 'b'
    yield 'c'
g = my_generator()
print(next(g))
print(next(g))
print('-------------------------')
print(g.throw(StopIteration))
print(next(g))
'''运行结果为：
a
b
-------------------------
StopIteration
'''
</code></pre>
<h3 id="生成器的启动与关闭-close"><a class="header" href="#生成器的启动与关闭-close"><strong>生成器的启动与关闭 close</strong></a></h3>
<ol>
<li>
<p><strong>生成器的启动</strong></p>
<p><strong>方法 1：<strong>​<strong><strong>直接使用</strong></strong>​</strong></strong><code>next(g)</code><strong><strong>​</strong></strong>，这会****​<strong>直接开始迭代第一个元素</strong>（<strong>推荐使用这个启动</strong>）</p>
<p><strong>方法 2：<strong>​<strong><strong>使用</strong></strong>​</strong></strong><code>g.send(None)</code>**<strong>​<strong><strong>进行启动，注意</strong></strong>​<strong>第一次启动的时候只能传入</strong>​</strong><code>None</code><strong>，如果传入其他具体的指则会</strong>报错**哦！</p>
<pre><code class="language-python">def my_generator():
    yield 1
    yield 2
    yield 3
    yield 4

g = my_generator()
g.send(None)   #第一次启动，本来第一次应该迭代的1，这里被取代了，但是send(None)会返回1
print(next(g))
print(next(g))
print(next(g))

'''运行结果为：
2
3
4
'''
</code></pre>
</li>
<li>
<p><strong>生成器的关闭</strong></p>
<p>如果一个生成器被<strong>中途关闭</strong>之后，在此调用 <code>next()</code> 方法，则会显示错误，如下：</p>
<pre><code class="language-python">def my_generator():
    yield 1
    yield 2
    yield 3
    yield 4

g = my_generator()
print(next(g))
print(next(g))
g.close()
print(next(g))   #在此处会显示错误
print(next(g))
'''运行结果为：
1
2
显示StopIteration
'''
</code></pre>
</li>
</ol>
<h3 id="生成器的终止迭代stopiteration"><a class="header" href="#生成器的终止迭代stopiteration"><strong>生成器的终止迭代——<strong>​</strong><code>StopIteration</code></strong></a></h3>
<blockquote>
<p>前面讲的手动关闭生成器，使用 <code>close()</code> 方法，后面的迭代会抛出 <code>StopIteration</code> 异常。</p>
</blockquote>
<p>在一个生成器中，如果没有 <code>return</code>，则默认执行到函数完毕时返回 <code>StopIteration</code>:</p>
<pre><code class="language-python">def g1():
    yield 1
g = g1()
next(g)    #第一次调用next(g)时，会在执行完yield语句后挂起，所以此时程序并没有执行结束。
next(g)    #程序试图从yield语句的下一条语句开始执行，发现已经到了结尾，所以抛出StopIteration异常。
'''运行结果为：
1
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
StopIteration
'''
</code></pre>
<p>如果遇到 <code>return</code>,如果在执行过程中 return，则直接抛出 <code>StopIteration</code> 终止迭代:</p>
<pre><code class="language-python">def g2():
    yield 'a'
    return
    yield 'b'
g=g2()
next(g)    #程序停留在执行完yield 'a'语句后的位置。
next(g)    #程序发现下一条语句是return，所以抛出StopIteration异常，这样yield 'b'语句永远也不会执行。
'''运行结果为：
a
b
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
StopIteration
'''
</code></pre>
<p>如果在 <code>return</code> 后返回一个值，那么这个值为 <code>StopIteration</code> 异常的说明，不是程序的返回值。</p>
<pre><code class="language-python">def g3():
 yield 'a'
 return '这是错误说明'
 yield 'b'   #有一些编辑器会提示错误，此处为unreachable code，即不可到达的代码
g=g3()
next(g)
next(g)
'''运行结果为：
a
Traceback (most recent call last):
 File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
StopIteration: 这是错误说明
'''
</code></pre>
<blockquote>
<p><strong>注意：<strong>​<strong><strong>生成器没有办法使用</strong></strong>​</strong></strong><code>return</code><strong><strong>​<strong><strong>来返回值。因为</strong></strong>​</strong></strong><code>return</code>****​<strong><strong>返回的那个值是通过</strong></strong>​<strong>StopIteration 的异常信息</strong>返回的，所以没办法<strong>直接获取这个 return 返回的值</strong>。</p>
</blockquote>
<p>当然上面所说的无法获取<strong>return 返回值</strong>，我们指的是没有办法通过 <code>result=g3()</code> 这种形式获取<strong>return 的返回值</strong>。实际上还是有手段获取这个<strong>return 的值的</strong>，有两种方法：</p>
<ol>
<li>
<p>使用 <code>yield from</code> 语句</p>
</li>
<li>
<p>因为 <code>return</code> 返回的值是作为<strong>StopIteration 的一个 value 属性存在的</strong>，StopIteration 本质上是<strong>一个类</strong>，所以可以通过访问它的<strong>value 属性获取这个 return 返回的值</strong>。使用下面的代码：</p>
<pre><code class="language-python">def g3():
    yield 'a'
    return '这是错误说明'
    yield 'b'
g=g3()

try:   
    print(next(g))  #a
    print(next(g))  #触发异常
except StopIteration as exc:
    result=exc.value
    print(result)
'''运行结果为：
a
这是错误说明
'''
</code></pre>
</li>
</ol>
<h3 id="yield实现协程"><a class="header" href="#yield实现协程"><strong><code>yield</code><strong>​</strong>实现协程</strong></a></h3>
<p>在 Python 中，协程通过 <code>yield</code> 实现。因为当<strong>一个函数中有 yield 存在</strong>的时候，这个函数是<strong>生成器</strong>，那么当你调用这个函数的时候，你在函数体中写的代码<strong>并没有被执行</strong>，而是<strong>只返回了一个生成器对象</strong>，这个需要特别注意。然后，你的代码将会在每次使用这个生成器的时候被执行。</p>
<p>前面讲过<strong>yield 表达式</strong>的两个关键作用：<strong>①返回一个值、②接收调用者的参数</strong></p>
<p>**“调用者”与“被调用者”**之间的通信是通过 <code>send()</code> 进行联系的</p>
<p>正是因为 <code>yield</code> 实现的生成器具备**“中断等待的功能”<strong>，才使得 yield 可以实现</strong>协程**。</p>
<ol>
<li>
<p>例子 1:<strong>生产者 - 消费者模型</strong></p>
<pre><code class="language-python">def consumer():
    r = ''
    while True:
        n = yield r  #执行的中断点
        if not n:
            return
        print('[消费者] 正在消费:{0}'.format(n))
        r = '200 人民币'

def produce(c):
    c.send(None)  #启动消费者（生成器）——实际上是函数调用，只不过生成器不是直接象函数那般调用的
    n = 0
    while n &lt; 5:
        n = n + 1
        print('[生产者] 正在生产:{0}'.format(n))
        r = c.send(n) #给消费者传入值——实际上也是函数调用
        print('[生产者] 消费者返回:{0}'.format(r))
        print('-------------------------------------------------')
    c.close()

c = consumer()#构造一个生成器
produce(c)

'''运行结果为：
[生产者] 正在生产:1
[消费者] 正在消费:1
[生产者] 消费者返回:200 人民币
-------------------------------------------------
[生产者] 正在生产:2
[消费者] 正在消费:2
[生产者] 消费者返回:200 人民币
-------------------------------------------------
[生产者] 正在生产:3
[消费者] 正在消费:3
[生产者] 消费者返回:200 人民币
-------------------------------------------------
[生产者] 正在生产:4
[消费者] 正在消费:4
[生产者] 消费者返回:200 人民币
-------------------------------------------------
[生产者] 正在生产:5
[消费者] 正在消费:5
[生产者] 消费者返回:200 人民币
-------------------------------------------------
'''
</code></pre>
</li>
</ol>
<p>协程其实就是一个<strong>可以暂停执行</strong>的函数，并且<strong>可以恢复继续执行</strong>。那么 <code>yield</code> 已经可以<strong>暂停执行</strong>了，如果在暂停后有办法把一些 <code>value</code> 发回到<strong>暂停执行的函数</strong>中，那么 Python 就有了**『协程』**。于是有了, <strong>“把东西发送到已经暂停的生成器中”</strong> 的方法，这个方法就是 <code>send()</code>。</p>
<h3 id="yield-from-的简单实现"><a class="header" href="#yield-from-的简单实现"><code>yield from</code> 的简单实现</a></h3>
<p>yield 是每次**“惰性返回”一个值**，其实从名字中就能看出，<code>yield from</code> 是 <code>yield</code> 的升级改进版本，如果将<strong>yield 理解成“返回”</strong>，那么 yield from 就是**“从什么（生成器）里面返回”**，这就构成了 <code>yield from</code> 的一般语法，即:</p>
<pre><code class="language-python">yield from 生成器()
</code></pre>
<p><strong>其实她等同于:</strong></p>
<pre><code class="language-python">for item in 生成器():
    yield item
</code></pre>
<p>这样的形式。我们通过一个简单例子来看：</p>
<pre><code class="language-python">def generator2():
    yield 'a'
    yield 'b'
    yield 'c'
    yield from generator1() #yield from iterable本质上等于 for item in iterable: yield item的缩写版
    yield from [11,22,33,44]
    yield from (12,23,34)
    yield from range(3)
    
for i in generator2():
    print(i,end=' , ')
'''运行的结果为：
a , b , c , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 11 , 22 , 33 , 44 , 12 , 23 , 34 , 0 , 1 , 2 ,
'''
</code></pre>
<p><code>yield from</code> 后面可以跟的可以是 <strong>“ 生成器 、元组、 列表、range() 函数产生的序列等可迭代对象”</strong></p>
<p>简单地说,<code>yield from  generator</code> 。实际上就是返回<strong>另外一个生成器</strong>。而 <code>yield</code> 只是返回<strong>一个元素</strong>。从这个层面来说，有下面的等价关系：<strong>yield from iterable 本质上等于 for item in iterable: yield item 。</strong></p>
<h3 id="yield-from-的高级应用"><a class="header" href="#yield-from-的高级应用"><code>yield from</code> 的高级应用</a></h3>
<h4 id="1-针对-yield-无法获取生成器-return-的返回值"><a class="header" href="#1-针对-yield-无法获取生成器-return-的返回值"><strong>1. 针对 Yield 无法获取生成器 return 的返回值</strong></a></h4>
<blockquote>
<p>在使用<strong>yield 生成器</strong>的时候，如果使用<strong>for 语句去迭代生成器</strong>，则不会显式的发出<strong>StopIteration 异常</strong>，而是<strong>自动捕获 StopIteration 异常</strong>，所以如果<strong>遇到 return，只是会终止迭代，而不会触发异常</strong>，故而也就<strong>没办法获取 return 的值</strong>。如下：</p>
</blockquote>
<pre><code class="language-python">def my_generator():
    for i in range(5):
        if i==2:
            return '我被迫中断了'
        else:
            yield i
 
def main(generator):
    try:
        for i in generator:  #不会显式触发异常，故而无法获取到return的值
            print(i)
    except StopIteration as exc:
        print(exc.value)
 
g = my_generator()  #调用
main(g)
'''运行结果为：
0
1
'''
</code></pre>
<p><strong>for 迭代语句不会显式触发异常</strong>，故而无法获取到<strong>return 的值</strong>，迭代到 2 的时候<strong>遇到 return 语句</strong>，<strong>隐式的触发了 StopIteration 异常</strong>，就<strong>终止迭代</strong>了，但是在程序中<strong>不会显示出来</strong>。</p>
<p>如果是使用 <code>next()</code>​<strong>一次一次迭代</strong>，则会<strong>显式触发异常</strong>，但要获取 return 的返回值，我需要如下操作：</p>
<pre><code class="language-python">def my_generator():
    for i in range(5):
        if i==2:
            return '我被迫中断了'
        else:
            yield i
 
def main(generator):
    try:
        print(next(generator))   #每次迭代一个值，则会显式出发StopIteration
        print(next(generator))
        print(next(generator))
        print(next(generator))
        print(next(generator))
    except StopIteration as exc:
        print(exc.value)     #获取返回的值

g=my_generator()
main(g)
'''运行结果为：
0
1
我被迫中断了
'''
</code></pre>
<p>现在我们使用 <code>yield from</code> 来完成上面的同样的功能：</p>
<pre><code class="language-python">生成器中return的值 = yield from 生成器对象
</code></pre>
<pre><code class="language-python">def my_generator():
    for i in range(5):
        if i == 2:
            # 遇到return自动触发StopIteration异常
            return '我被迫中断了'
        else:
            yield i
 
def wrap_my_generator(generator):  # 定义一个包装“生成器”的生成器，它的本质还是生成器
    result = yield from generator    # 自动触发StopIteration异常，并且将return的返回值赋值给yield from表达式的结果，即result
    print(result)
 
def main(generator):
    for j in generator:
        print(j)
 
g = my_generator()
wrap_g = wrap_my_generator(g)
main(wrap_g)  #调用
'''运行结果为：
0
1
我被迫中断了
'''
</code></pre>
<p>从上面的比较可以看出，<code>yield from</code> 具有以下几个<strong>特点</strong>：</p>
<ol>
<li><strong>单独</strong>​**<code>yield</code><strong>​</strong>时**：的 my_generator 是原始的生成器，main 是调用方，使用 yield 的时候，只涉及到这两个函数，即“调用方”与“生成器（协程函数）”是<strong>直接进行交互的，不涉及其他方法</strong>，即**“调用方——&gt;生成器函数 (协程函数)”；**</li>
<li><strong>在使用</strong>​**<code>yield from</code><strong>​</strong>的时**：多了一个对原始 my_generator 的<strong>包装函数</strong>，然后<strong>调用方是通过这个包装函数</strong>（后面会讲到它专有的名词）来与<strong>生成器进行交互</strong>的，即**“调用方——&gt;生成器包装函数——&gt;生成器函数 (协程函数)”**；</li>
<li><code>yield from iteration</code> 结构会在内部<strong>自动捕获 iteration 生成器的 StopIteration 异常</strong>。这种处理方式与 for 循环处理 StopIteration 异常的方式一样。而且对 <code>yield from</code> 结构来说，<strong>解释器不仅会捕获 StopIteration 异常，还会把 return 返回的值或者是 StopIteration 的 value 属性的值变成 yield from 表达式的值，即上面的 result。</strong></li>
</ol>
<blockquote>
<p>委派生成器：包含 <code>yield from</code> <iterable> <strong>表达式的生成器函数</strong>；即上面的 wrap_my_generator<strong>生成器包装函数</strong></p>
</blockquote>
<blockquote>
<p>子生成器：从 <code>yield from</code> 表达式中 <iterable> 部分获取的生成器；即上面的 my_generator<strong>生成器函数</strong></p>
</blockquote>
<blockquote>
<p>调用方：<strong>调用委派生成器的客户端代码</strong>；即上面的<strong>main 调用方函数</strong></p>
</blockquote>
<p><img src="http://oss.whaleluo.top/blog/old/20210814184753.png-picsmall" alt="" /></p>
<h4 id="2-yield-from-的管道传输用法示例"><a class="header" href="#2-yield-from-的管道传输用法示例">2. Yield from 的管道传输用法示例</a></h4>
<p>其实 <code>yield from</code> 最重要的作用就是提供了一个**“数据传输的管道”**，下面通过一个简单的例子加以说明为什么是管道：</p>
<pre><code class="language-python">def average():
    total = 0.0  #数字的总和
    count = 0    #数字的个数
    avg = None   #平均值
    while True:
        num = yield avg
        total += num
        count += 1
        avg = total/count
 
def wrap_average(generator):
    yield from generator
 
#定义一个函数，通过这个函数向average函数发送数值
def main(wrap):
    print(next(wrap))  #启动生成器
    print(wrap.send(10))  # 10
    print(wrap.send(20))  # 15
    print(wrap.send(30))  # 20
    print(wrap.send(40))  # 25
  
g = average()
wrap = wrap_average(g)
main(wrap)
 
'''运行结果为：
None
10.0
15.0
20.0
25.0
'''
</code></pre>
<p>从上面我们可以发现，调用方发送的数据是发给 <code>wrap_average</code> 的，怎么依然到了生成器函数 <code>average</code> 里面呢？这就是**“数据传输管道的作用”<strong>。即</strong>主函数调用方 main 把各个 value 传给 grouper** ，而这个传入的值<strong>最终到达 averager 函数中</strong>； <strong>grouper 并不知道传入的是什么值</strong>，因为从上面的代码看出，<strong><code>wrap_average</code><strong>​</strong>里面完全没有处理这个值的任何代码！</strong></p>
<h2 id="装饰器"><a class="header" href="#装饰器">装饰器</a></h2>
<h3 id="函数引用"><a class="header" href="#函数引用">函数引用</a></h3>
<pre><code class="language-python">def test():
    print(&quot;1&quot;)
print(test)
# &lt;function __main__.test&gt;
a = test # 变量A指向函数对象
a() # 变量A可调用函数
</code></pre>
<h3 id="什么是闭包"><a class="header" href="#什么是闭包">什么是闭包</a></h3>
<blockquote>
<p><strong>在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这些函数以及用到的一些变量称之为闭包。</strong></p>
</blockquote>
<h3 id="闭包的应用"><a class="header" href="#闭包的应用">闭包的应用</a></h3>
<pre><code class="language-python">def parse(number: int):
    print(&quot;第一层函数&quot;, number)

    def sum(number2):
        print(&quot;第二层函数加和后&quot;, number+number2)
    return sum
# 接受函数对象的引用
func = parse(100)
func(100)
</code></pre>
<p><img src="http://oss.whaleluo.top/blog/old/20210719211704.png-picsmall" alt="" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210719215011.png-picsmall" alt="" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210719215459.png-picsmall" alt="" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210719215842.png-picsmall" alt="" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210719220126.png-picsmall" alt="" /></p>
<pre><code class="language-python"># 编写闭包函数
def checkLogin(func):
    print(&quot;准备检查权限&quot;)

    def inner():
        print(&quot;权限正确!&quot;)
        func()  # 执行函数的变量

    return inner  # 返回一个函数对象

# main变量指向的是mian函数
def main():
    print(&quot;执行业务1&quot;)

# 不用修改主函数的内容,就可以扩展主函数.
main = checkLogin(main)  # 此时main变量指向的是inner函数
main()
# 等效于
# 到这里python会运行 checkLogin函数,并把下面的函数名变量指向 checkLogin 函数的返回值,即 inner 函数
@checkLogin
def mian():
    print(&quot;执行业务2&quot;)

# 在调用main之前已经被装饰了
mian()
</code></pre>
<h3 id="多个修饰器从下到上修饰"><a class="header" href="#多个修饰器从下到上修饰">多个修饰器，从下到上修饰</a></h3>
<p><img src="http://oss.whaleluo.top/blog/old/20210720161511.png-picsmall" alt="" /></p>
<blockquote>
<p><strong>装饰是倒着装的，执行是顺着执行的。</strong></p>
</blockquote>
<h3 id="装饰有参数的函数"><a class="header" href="#装饰有参数的函数">装饰有参数的函数</a></h3>
<p><img src="http://oss.whaleluo.top/blog/old/20210720162540.png-picsmall" alt="" /></p>
<blockquote>
<p>对不定长参数的传递</p>
</blockquote>
<p><img src="http://oss.whaleluo.top/blog/old/20210720162754.png-picsmall" alt="" /></p>
<h3 id="装饰有返回值的参数"><a class="header" href="#装饰有返回值的参数">装饰有返回值的参数</a></h3>
<p><img src="http://oss.whaleluo.top/blog/old/20210720163328.png-picsmall" alt="image-20210720163327239" /></p>
<h3 id="通用修饰器"><a class="header" href="#通用修饰器">通用修饰器</a></h3>
<p><img src="http://oss.whaleluo.top/blog/old/20210720164146.png-picsmall" alt="" /></p>
<h3 id="带参数的修饰器"><a class="header" href="#带参数的修饰器">带参数的修饰器</a></h3>
<p><img src="http://oss.whaleluo.top/blog/old/20210818144548.png-picsmall" alt="" /></p>
<blockquote>
<p>在函数中嵌套闭包函数</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Python database 数据库 ORM 框架
date: 2023-09-09 08:12:64
updated: 2023-09-09 08:12:64
categories: Python
tags:</p>
<ul>
<li>databases</li>
<li>python</li>
<li>ORM</li>
<li>mysql
description: 
thumbnail: 
banner_img:</li>
</ul>
<hr />
<hr />
<h1 id="python-database-数据库-orm-框架"><a class="header" href="#python-database-数据库-orm-框架">Python database 数据库 ORM 框架</a></h1>
<p><strong>ORM</strong> (<strong>O</strong>object <strong>R</strong>elational <strong>M</strong>apper) 对象关系映射，用于在 Code 中通过 Object 来操作<strong>关系型数据库</strong>，将用户定义的 Python 类映射到数据库表和其他构造 ，而不用直接手撕 SQL 语句。增加安全性和可维护性。</p>
<p>SQLAlchemy （SQL 炼金术 <code>/ˈæl.kə.mi/</code> ）是 Python 中用于操作各种 <strong>关系型数据库</strong> 的 <strong>ORM</strong></p>
<p><a href="https://docs.sqlalchemy.org/en/20/intro.html">SQLAlchemy Offical Tutorial</a></p>
<p><img src="http://oss.whaleluo.top/blog/img/Python-database-ORM-tutorial-components.png-picsmall" alt="" /></p>
<p>SQLAlchemy 包含 对象关系映射器 <strong>ORM</strong> 和 核心 <strong>Core</strong> 两部分 API，ORM 构建于 Core 之上，如上图。<strong>DBAPI</strong> 代表底层数据库的驱动，例如：<code>pymysql</code> <code>sqlite3</code> 与特定数据库交互的第三方驱动程序。</p>
<h2 id="install-1"><a class="header" href="#install-1">Install</a></h2>
<pre><code class="language-shell">pip install SQLAlchemy
</code></pre>
<h2 id="establish-connectivity-建立链接"><a class="header" href="#establish-connectivity-建立链接">Establish Connectivity 建立链接</a></h2>
<p><code>Engine</code> 对象通过 <code>create_engine()</code> 方法来构造，是只用创建一次的全局对象。<br />
<code>create_engine()</code> 首次返回不会链接到数据库，仅在调用 Engine 对象执行数据库操作时才链接到数据库 （被称为 <strong>Lazy loading</strong> 的设计模式），<a href="https://docs.sqlalchemy.org/en/20/glossary.html#term-lazy-initialization">lazy initialization</a></p>
<pre><code class="language-python">from sqlalchemy import create_engine
engine = create_engine(&quot;sqlite+pysqlite:///:memory:&quot;, echo=True)
</code></pre>
<h2 id="transactions-事务操作"><a class="header" href="#transactions-事务操作">Transactions 事务操作</a></h2>
<h3 id="core-engine-connect"><a class="header" href="#core-engine-connect">Core Engine Connect</a></h3>
<pre><code class="language-python">from sqlalchemy import text

# 获取数据库游标
with engine.connect() as conn:
	
	# 返回 Result 对象	
    result = conn.execute(text(&quot;select 'hello world'&quot;))
    print(result.all())
    
    # 提交变更
    conn.commit()
	result = conn.execute(text(&quot;SELECT x, y FROM some_table&quot;))
	for row in result:
		print(f&quot;x: {row.x}  y: {row.y}&quot;)
	
	# 带参数的 sql 语句拼接
    result = conn.execute(text(&quot;SELECT x, y FROM some_table WHERE y &gt; :y&quot;), {&quot;y&quot;: 2})
    for row in result:
        print(f&quot;x: {row.x}  y: {row.y}&quot;)

	# 多参数 executemany
	conn.execute(
         text(&quot;INSERT INTO some_table (x, y) VALUES (:x, :y)&quot;),
         [{&quot;x&quot;: 11, &quot;y&quot;: 12}, {&quot;x&quot;: 13, &quot;y&quot;: 14}],
     )

</code></pre>
<h3 id="orm-engine-session"><a class="header" href="#orm-engine-session">ORM Engine Session</a></h3>
<p>使用 ORM 时的基本事务/数据库交互对象称为 <code>Session</code>。<br />
<code>Session</code> 在结束事务后实际上并不保留 <code>Connection</code> 对象。下次需要对数据库执行 SQL 时，它会从 <code>Engine</code> 获取新的 <code>Connection</code> 。</p>
<pre><code class="language-python">from sqlalchemy.orm import Session

stmt = text(&quot;SELECT x, y FROM some_table WHERE y &gt; :y ORDER BY x, y&quot;)
with Session(engine) as session:
    result = session.execute(stmt, {&quot;y&quot;: 6})
    for row in result:
        print(f&quot;x: {row.x}  y: {row.y}&quot;)
    
    result = session.execute(
         text(&quot;UPDATE some_table SET y=:y WHERE x=:x&quot;),
        [{&quot;x&quot;: 9, &quot;y&quot;: 11}, {&quot;x&quot;: 13, &quot;y&quot;: 15}],
   )
    session.commit()
</code></pre>
<p>通过 with 语句构建 begin 开始、rollback 回滚、commit 提交 语句。</p>
<pre><code class="language-python"># verbose version of what a context manager will do
with Session(engine) as session:
    # session.begin() auto commit database
    # create session and add objects
	with session.begin():
		session.add(some_object)
        session.add(some_other_object)
	    # inner context calls session.commit(), if there were no exceptions
		# outer context calls session.close()
    try:
        session.add(some_object)
        session.add(some_other_object)
    except:
        session.rollback()
        raise
    else:
        session.commit()
</code></pre>
<p>更简洁的实现：</p>
<pre><code class="language-python"># create session and add objects
with Session(engine) as session, session.begin():
    session.add(some_object)
    session.add(some_other_object)
	# inner context calls session.commit(), if there were no exceptions
	# outer context calls session.close()
</code></pre>
<p>或者使用 session macker(会话生成器)：</p>
<pre><code class="language-python">from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

# an Engine, which the Session will use for connection
# resources
engine = create_engine(&quot;postgresql+psycopg2://scott:tiger@localhost/&quot;)

# a sessionmaker(), also in the same scope as the engine
Session = sessionmaker(engine)

# we can now construct a Session() and include begin()/commit()/rollback()
# at once
with Session.begin() as session:
    session.add(some_object)
    session.add(some_other_object)
	# commits the transaction, closes the session
</code></pre>
<h2 id="database-metadata-数据库元数据-orm"><a class="header" href="#database-metadata-数据库元数据-orm">Database Metadata 数据库元数据 ORM</a></h2>
<p>SQLAlchemy 中数据库元数据最常见的基础对象称为 <code>MetaData</code> 、 <code>Table</code> 和 <code>Column</code>。<br />
一种创建表的方式是 <strong>显性使用 MetaData</strong> 表集合来创建：</p>
<pre><code class="language-python">from sqlalchemy import Table, Column, Integer, String
# `MetaData` 对象是表的集合
from sqlalchemy import MetaData
metadata_obj = MetaData()

# 用户表
user_table = Table(
    &quot;user_account&quot;,
    metadata_obj,
    Column(&quot;id&quot;, Integer, primary_key=True),
    Column(&quot;name&quot;, String(30)),
    Column(&quot;fullname&quot;, String),
)

# 新建表
metadata_obj.create_all(engine)
</code></pre>
<h3 id="declarative-base-声明式基础"><a class="header" href="#declarative-base-声明式基础">Declarative base 声明式基础</a></h3>
<p>一种是使用 <strong>对象</strong> 的方式来创建表。</p>
<pre><code class="language-python">from sqlalchemy.orm import DeclarativeBase
# 创建一个 DeclarativeBase 的子类 Base
# 可以基于这个子类 Base 来映射 mapper 数据
# 构造声明性类定义的基类 相当于已经弃用的 Base = declarative_base()
class Base(DeclarativeBase):
    pass

# 建立 `Base` 类后，可以基于 Base 类 定义 ORM 映射类
from typing import List
from typing import Optional
from sqlalchemy.orm import Mapped
from sqlalchemy.orm import mapped_column
from sqlalchemy.orm import relationship

# ORM 映射类
class User(Base):
    __tablename__ = &quot;user_account&quot;
    # 为了指示 `Table` 中的列，使用 `mapped_column()` 构造，并结合基于 `Mapped` 类型的键入注释。该对象将生成应用于 `Table` 构造的 `Column` 对象。
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(30))
    
	# 对于具有简单数据类型且没有其他选项的列，我们可以单独指示 `Mapped` 类型注释，使用简单的 Python 类型
    fullname: Mapped[Optional[str]]
    addresses: Mapped[List[&quot;Address&quot;]] = relationship(back_populates=&quot;user&quot;)
	
	# 获得可读的字符串输出
    def __repr__(self) -&gt; str:
        return f&quot;User(id={self.id!r}, name={self.name!r}, fullname={self.fullname!r})&quot;

class Address(Base):
    __tablename__ = &quot;address&quot;
    id: Mapped[int] = mapped_column(primary_key=True)
    email_address: Mapped[str]
    user_id = mapped_column(ForeignKey(&quot;user_account.id&quot;))
    user: Mapped[User] = relationship(back_populates=&quot;addresses&quot;)
    def __repr__(self) -&gt; str:
        return f&quot;Address(id={self.id!r}, email_address={self.email_address!r})&quot;

# 向数据库构建表
# 运行 PRAGMA 语句，但不会生成新表，因为发现它们已经存在
Base.metadata.create_all(engine)

</code></pre>
<h3 id="table-reflection-表反射"><a class="header" href="#table-reflection-表反射">Table Reflection 表反射</a></h3>
<p>用于识别已有数据库的映射。</p>
<pre><code class="language-python"># 将创建一个新的 `Table` 对象 自动识别
some_table = Table(&quot;some_table&quot;, metadata_obj, autoload_with=engine)
</code></pre>
<h2 id="working-with-data-处理数据"><a class="header" href="#working-with-data-处理数据">Working with Data 处理数据</a></h2>
<h3 id="working-with-sql-core-拼接构造-sql-语句"><a class="header" href="#working-with-sql-core-拼接构造-sql-语句">Working with sql core 拼接构造 sql 语句</a></h3>
<p>reference: <a href="https://docs.sqlalchemy.org/en/20/tutorial/data_select.html">Using SELECT Statements — SQLAlchemy 2.0 Documentation</a></p>
<h4 id="insert-插入"><a class="header" href="#insert-插入">Insert 插入</a></h4>
<pre><code class="language-python">with engine.connect() as conn:
	# insert(user_table).values(name=&quot;spongebob&quot;, fullname=&quot;Spongebob Squarepants&quot;)
    result = conn.execute(
        insert(user_table),
        [
            {&quot;name&quot;: &quot;sandy&quot;, &quot;fullname&quot;: &quot;Sandy Cheeks&quot;},
            {&quot;name&quot;: &quot;patrick&quot;, &quot;fullname&quot;: &quot;Patrick Star&quot;},
        ],
    )
    conn.commit()
</code></pre>
<h4 id="select-选择查询"><a class="header" href="#select-选择查询">Select 选择查询</a></h4>
<pre><code class="language-python">from sqlalchemy import select
stmt = select(user_table).where(user_table.c.name == &quot;spongebob&quot;)
print(stmt) # 生成一段 mysql 语句
# SELECT user_account.id, user_account.name, user_account.fullname FROM user_account WHERE user_account.name = :name_1

# first() 第一个数据
row = session.execute(select(User)).first()

# all() 全部数据
session.execute(
				select(User.name, Address).where(User.id == Address.user_id).order_by(Address.id)
			).all()

# where 语句 c: column
user_table.c.name == &quot;squidward&quot;
select(user_table).where(user_table.c.name == &quot;squidward&quot;)

# 多查
print(
    select(address_table.c.email_address)
    .where(user_table.c.name == &quot;squidward&quot;)
    .where(address_table.c.user_id == user_table.c.id)
)
print(
    select(address_table.c.email_address).where(
        user_table.c.name == &quot;squidward&quot;,
        address_table.c.user_id == user_table.c.id,
    )
)

# AND OR 语句
from sqlalchemy import and_, or_
print(
    select(Address.email_address).where(
        and_(
            or_(User.name == &quot;squidward&quot;, User.name == &quot;sandy&quot;),
            Address.user_id == User.id,
        )
    )
)

# ORDER BY 排序依据
print(select(user_table).order_by(user_table.c.name))


</code></pre>
<h4 id="update-更新"><a class="header" href="#update-更新">Update 更新</a></h4>
<pre><code class="language-python">from sqlalchemy import update
stmt = (
    update(user_table)
    .where(user_table.c.name == &quot;patrick&quot;)
    .values(fullname=&quot;Patrick the Star&quot;)
)
print(stmt)


with engine.begin() as conn:
    result = conn.execute(
        update(user_table)
        .values(fullname=&quot;Patrick McStar&quot;)
        .where(user_table.c.name == &quot;patrick&quot;)
    )
    print(result.rowcount)

update_stmt = (
    update(user_table)
    .where(user_table.c.name == &quot;patrick&quot;)
    .values(fullname=&quot;Patrick the Star&quot;)
    .returning(user_table.c.id, user_table.c.name) # 定义返回的数据
)


print(update_stmt)
delete_stmt = (
    delete(user_table)
    .where(user_table.c.name == &quot;patrick&quot;)
    .returning(user_table.c.id, user_table.c.name)
)
print(delete_stmt)
</code></pre>
<h3 id="woking-with-orm"><a class="header" href="#woking-with-orm">Woking with ORM</a></h3>
<p>Instances of Classes represent Rows 表类的实例代表行。</p>
<pre><code class="language-python">squidward = User(name=&quot;squidward&quot;, fullname=&quot;Squidward Tentacles&quot;)
krabs = User(name=&quot;ehkrabs&quot;, fullname=&quot;Eugene H. Krabs&quot;)
session = Session(engine)
session.add(squidward)
session.commit()
</code></pre>
<p>从主键获取对象：</p>
<pre><code class="language-python">some_squidward = session.get(User, 4) # 直接返回数据库对象类型
some_squidward = User(id=4, name='squidward', fullname='Squidward Tentacles')
</code></pre>
<p>从 execute 获取对象：<code>scalar()</code> scalar /ˈskeɪ.lər/</p>
<pre><code class="language-python">sandy = session.execute(select(User).filter_by(name=&quot;sandy&quot;)).scalar_one()

session.execute(
  select(User)
).scalars().all()

# or

session.scalars(
  select(User)
).all()
</code></pre>
<h2 id="asyncio-support"><a class="header" href="#asyncio-support">AsyncIO Support</a></h2>
<p>对异步 IO 的支持：<a href="https://docs.sqlalchemy.org/en/20/intro.html#asyncio-support">Overview — SQLAlchemy 2.0 Documentation</a></p>
<p>reference: <a href="https://docs.sqlalchemy.org/en/20/orm/extensions/asyncio.html">Asynchronous I/O (asyncio) — SQLAlchemy 2.0 Documentation</a></p>
<p>install:</p>
<pre><code class="language-shell">pip install sqlalchemy[asyncio]
</code></pre>
<p>uses:</p>
<pre><code class="language-python">import asyncio

from sqlalchemy import Column
from sqlalchemy import MetaData
from sqlalchemy import select
from sqlalchemy import String
from sqlalchemy import Table
from sqlalchemy.ext.asyncio import create_async_engine

meta = MetaData()
t1 = Table(&quot;t1&quot;, meta, Column(&quot;name&quot;, String(50), primary_key=True))

class Base(AsyncAttrs, DeclarativeBase):
    pass

async def async_main() -&gt; None:
	# 创建异步数据库 engine
    engine = create_async_engine(
        &quot;postgresql+asyncpg://scott:tiger@localhost/test&quot;,
        echo=True,
    )

    async with engine.begin() as conn:
	    # `run_sync()` 方法可用于调用特殊的 DDL 函数，例如不包含可等待挂钩的 `MetaData.create_all()`
        await conn.run_sync(meta.create_all)

        await conn.execute(
            t1.insert(), [{&quot;name&quot;: &quot;some name 1&quot;}, {&quot;name&quot;: &quot;some name 2&quot;}]
        )

    async with engine.connect() as conn:
        # select a Result, which will be delivered with buffered
        # results
        result = await conn.execute(select(t1).where(t1.c.name == &quot;some name 1&quot;))

        print(result.fetchall())

    # for AsyncEngine created in function scope, close and
    # clean-up pooled connections
    # 当在超出上下文并被垃圾回收的作用域中使用 `AsyncEngine` 对象时，建议使用 `await` 调用 `AsyncEngine.dispose()` 方法，如上例中的 `async_main` 函数。这确保了连接池保持打开的任何连接都将在可等待上下文中得到正确处理。
    await engine.dispose()


asyncio.run(async_main())
</code></pre>
<h3 id="complete-example-完整示例"><a class="header" href="#complete-example-完整示例">Complete example 完整示例：</a></h3>
<pre><code class="language-python">from __future__ import annotations

import asyncio
import datetime
from typing import List

from sqlalchemy import ForeignKey
from sqlalchemy import func
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncAttrs
from sqlalchemy.ext.asyncio import async_sessionmaker
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.ext.asyncio import create_async_engine
from sqlalchemy.orm import DeclarativeBase
from sqlalchemy.orm import Mapped
from sqlalchemy.orm import mapped_column
from sqlalchemy.orm import relationship
from sqlalchemy.orm import selectinload


class Base(AsyncAttrs, DeclarativeBase):
    pass


class A(Base):
    __tablename__ = &quot;a&quot;

    id: Mapped[int] = mapped_column(primary_key=True)
    data: Mapped[str]
    create_date: Mapped[datetime.datetime] = mapped_column(server_default=func.now())
    bs: Mapped[List[B]] = relationship()


class B(Base):
    __tablename__ = &quot;b&quot;
    id: Mapped[int] = mapped_column(primary_key=True)
    a_id: Mapped[int] = mapped_column(ForeignKey(&quot;a.id&quot;))
    data: Mapped[str]

# 类型注释一个函数
async def insert_objects(async_session: async_sessionmaker[AsyncSession]) -&gt; None:
	# 使用 async session maker 构造 session
    async with async_session() as session:
        async with session.begin():
            session.add_all(
                [
                    A(bs=[B(), B()], data=&quot;a1&quot;),
                    A(bs=[], data=&quot;a2&quot;),
                    A(bs=[B(), B()], data=&quot;a3&quot;),
                ]
            )


async def select_and_update_objects(
    async_session: async_sessionmaker[AsyncSession],
) -&gt; None:
    async with async_session() as session:
        stmt = select(A).options(selectinload(A.bs))

        result = await session.execute(stmt)

        for a1 in result.scalars():
            print(a1)
            print(f&quot;created at: {a1.create_date}&quot;)
            for b1 in a1.bs:
                print(b1)

        result = await session.execute(select(A).order_by(A.id).limit(1))

        a1 = result.scalars().one()

        a1.data = &quot;new data&quot;

        await session.commit()

        # access attribute subsequent to commit; this is what
        # expire_on_commit=False allows
        print(a1.data)

        # alternatively, AsyncAttrs may be used to access any attribute
        # as an awaitable (new in 2.0.13)
        for b1 in await a1.awaitable_attrs.bs:
            print(b1)


async def async_main() -&gt; None:
    engine = create_async_engine(
        &quot;postgresql+asyncpg://scott:tiger@localhost/test&quot;,
        echo=True,
    )

    # async_sessionmaker: a factory for new AsyncSession objects.
    # expire_on_commit - don't expire objects after transaction commit
    async_session = async_sessionmaker(engine, expire_on_commit=False)

    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    await insert_objects(async_session)
    await select_and_update_objects(async_session)

    # for AsyncEngine created in function scope, close and
    # clean-up pooled connections
    await engine.dispose()


asyncio.run(async_main())
</code></pre>
<h2 id="legacy-query-api-旧版查询-api"><a class="header" href="#legacy-query-api-旧版查询-api">Legacy query API 旧版查询 API</a></h2>
<p><a href="https://docs.sqlalchemy.org/en/20/orm/queryguide/query.html#legacy-query-api">Legacy Query API — SQLAlchemy 2.0 Documentation</a></p>
<p>多年来，它是使用 SQLAlchemy ORM 时唯一的 SQL 接口。从版本 2.0 开始，一种全新的工作方式现已成为标准方法，其中适用于 Core 的相同 <code>select()</code> 构造也适用于 ORM，为构建查询提供一致的接口。</p>
<p>从旧版本迁移到 2.0 <a href="https://docs.sqlalchemy.org/en/20/changelog/migration_20.html#migration-20-query-usage">SQLAlchemy 2.0 - Major Migration Guide — SQLAlchemy 2.0 Documentation</a></p>
<p>SQLAlchemy 2.0 中最大的明显变化是使用 <code>Session.execute()</code> 与 <code>select()</code> 结合使用来运行 ORM 查询，而不是使用 <code>Session.query()</code> 。正如其他地方提到的，没有计划实际删除 <code>Session.query()</code> API 本身，因为它现在是通过在内部使用新 API 来实现的，它将保留为旧版 API，并且这两个 API 都可以自由使用。</p>
<h2 id="qa"><a class="header" href="#qa">Q&amp;A</a></h2>
<h3 id="is-the-session-thread-safe-线程安全-is-asyncsession-safe异步并发安全-to-share-in-concurrent-tasks"><a class="header" href="#is-the-session-thread-safe-线程安全-is-asyncsession-safe异步并发安全-to-share-in-concurrent-tasks">Is the Session thread-safe (线程安全)? Is AsyncSession safe(异步并发安全) to share in concurrent tasks?<a href="https://docs.sqlalchemy.org/en/20/orm/session_basics.html#is-the-session-thread-safe-is-asyncsession-safe-to-share-in-concurrent-tasks" title="Permalink to this heading">¶</a></a></h3>
<p><code>Session</code> 是一个可变的、有状态的对象，<code>session</code> 的实例就无法在并发线程或异步任务之间共享。 <code>Session</code> 旨在以非并发方式使用。</p>
<p>在设计并发数据库应用程序时，适当的模型是 <strong>每个并发任务/线程都处理自己的数据库事务 <code>Session</code></strong>。</p>
<p>确保这种使用的最佳方法是在线程或任务内部的顶级 Python 函数中本地使用 <strong>标准上下文管理器</strong> 模式。</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Python Tkinter 框架学习
date: 2021-08-18 19:37:48
updated: 2021-08-18 19:37:48
categories:</p>
<ul>
<li>Python
tags: [Python, Coding, GUI]
description: Python Tkinter 是一个 Python 自带GUI包，十分轻量。
thumbnail: http://oss.whaleluo.top/blog/old/20210630201524.png
banner_img: http://oss.whaleluo.top/blog/old/20210630201524.png</li>
</ul>
<hr />
<h1 id="tkinter-框架学习"><a class="header" href="#tkinter-框架学习">Tkinter 框架学习</a></h1>
<h2 id="gui-tkinter-框架结构"><a class="header" href="#gui-tkinter-框架结构">GUI Tkinter 框架结构</a></h2>
<p><img src="http://oss.whaleluo.top/blog/old/20210704162742.png-picsmall" alt="image-20210704162740134" /></p>
<h2 id="常用组件汇总列表"><a class="header" href="#常用组件汇总列表">常用组件汇总列表</a></h2>
<p><img src="http://oss.whaleluo.top/blog/old/20210704162352.png-picsmall" alt="" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210704162631.png-picsmall" alt="" /></p>
<h2 id="面向对象的方式写-gui-框架的经典实例"><a class="header" href="#面向对象的方式写-gui-框架的经典实例">面向对象的方式写 GUI 框架的经典实例</a></h2>
<p><img src="http://oss.whaleluo.top/blog/old/20210704170311.png-picsmall" alt="image-20210704170309065" /></p>
<h3 id="具体实现代码"><a class="header" href="#具体实现代码">具体实现代码</a></h3>
<pre><code class="language-python">#!/usr/bin/python python3
# coding=utf-8
'''
Author: whalefall
Date: 2021-07-04 16:50:10
LastEditTime: 2021-07-04 17:25:55
Description: 利用面向对象的方式写一个经典的 GUI 程序
'''
from tkinter import *
# Frame: 一个布局容器,里面可以放置组件.
from tkinter import Frame
# messagebox: 一个消息框组件
from tkinter import messagebox


class Application(Frame):
    '''
    通过 Application 类组织整个 GUI 程序,继承自 Frame.
    '''

    def __init__(self, master=None):
        '''
        初始化类,要传入根窗口对象.
        '''
        # 调用父类 Frame 的初始化方法
        super().__init__(master)
        # 将 master(传入的根窗口对象) 添加到 APP 类的属性
        # 使 self 拥有 root 根窗口对象的所有方法.
        self.master = master

        self.pack()  # 布局管理器,用于添加组件到布局
        # 创建各组件
        self.createWidget()

    def createWidget(self):
        '''
        创建一个组件,在初始化类中调用
        '''
        # 用父类的 Master 即 self 对象创建一个按钮组件
        self.btn1 = Button(self)
        self.btn1[&quot;text&quot;] = &quot;点击提交&quot;  # 设置按钮文字属性
        self.btn1[&quot;command&quot;] = self.lover  # 点击按钮所执行的函数
        self.btn1.pack()  # 添加到布局管理器

        # 创建一个退出按钮
        # command: 命令 (点击按钮要执行的函数)
        # root: 全局变量(根窗口)
        # destroy 方法: 消灭所有窗体(退出程序)
        self.btnQuit = Button(self, text=&quot;退出&quot;, command=root.destroy)
        self.btnQuit.pack()  # 添加到布局管理器

    def lover(self):
        '''
        点击 btn1 所执行的函数
        '''
        messagebox.showinfo(&quot;表白信息&quot;, &quot;颖怡我喜欢你.&quot;)


if __name__ == &quot;__main__&quot;:
    root = Tk()  # 创建主窗体
    root.geometry(&quot;400x100+200+300&quot;)  # 设置程序长宽位置
    root.title(&quot;面向对象经典 GUI 程序&quot;)

    app = Application(master=root)

    root.mainloop()  # 调用组件的方法,进入事件循环.
</code></pre>
<h2 id="label--标签--用法"><a class="header" href="#label--标签--用法">Label ( 标签 ) 用法</a></h2>
<p><img src="http://oss.whaleluo.top/blog/old/20210704193103.png-picsmall" alt="" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210704193502.png-picsmall" alt="" /></p>
<h2 id="组件-option-选项设置"><a class="header" href="#组件-option-选项设置">组件 Option 选项设置</a></h2>
<p><img src="http://oss.whaleluo.top/blog/old/20210704203439.png-picsmall" alt="" /></p>
<h3 id="选项大全"><a class="header" href="#选项大全">选项大全</a></h3>
<p><img src="http://oss.whaleluo.top/blog/old/20210705220646.png-picsmall" alt="" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210705220636.png-picsmall" alt="" /></p>
<h2 id="button-anchor-位置控制"><a class="header" href="#button-anchor-位置控制">Button Anchor 位置控制</a></h2>
<p><img src="http://oss.whaleluo.top/blog/old/20210705221052.png-picsmall" alt="" /></p>
<h2 id="entry-strinngvar-输入框"><a class="header" href="#entry-strinngvar-输入框">Entry StrinngVar 输入框</a></h2>
<blockquote>
<p>输入框接收变量的类型</p>
</blockquote>
<p><img src="http://oss.whaleluo.top/blog/old/20210705223051.png-picsmall" alt="" /></p>
<p>属性的双向关联</p>
<p><img src="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Python/C:/Users/WhaleFall/AppData/Roaming/Typora/typora-user-images/image-20210705223506326.png-picsmall" alt="image-20210705223506326" /></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>title: Python 黑魔法
date: 2023-08-11 10:51:51
updated: 2023-08-11 10:51:51
categories: Python
tags: [coding, Python, 高级编程]
description: 
thumbnail: 
banner_img:</h2>
<h1 id="python-黑魔法"><a class="header" href="#python-黑魔法">Python 黑魔法</a></h1>
<p>记录一些 Python 语言独有的，不太常见的写法，方便进行库的开发。一般我在读源码的时候可以碰见很多没有见过的魔术方法和神奇实现，所以把它记录下来。</p>
<h2 id="getattr-get-attribute-获取属性"><a class="header" href="#getattr-get-attribute-获取属性">Getattr (get attribute 获取属性)</a></h2>
<p>source code: <a href="https://github.com/Ripeey/Conversation-Pyrogram/blob/main/src/convopyro/__init__.py">Pyrogram Conversation-Pyrogram</a></p>
<h3 id="getattr"><a class="header" href="#getattr">Getattr</a></h3>
<p><code>getattr()</code> 是 Python 的一个内置函数，用于获取对象的属性值。它接受两个参数：对象和属性名，并返回属性值。</p>
<p>语法：</p>
<pre><code class="language-python">getattr(object, name[, default])
</code></pre>
<ul>
<li>object: 要获取属性值的对象。</li>
<li>name: 属性名。</li>
<li>default (可选): 如果属性不存在，则返回 default 值（默认为 None）。</li>
</ul>
<p>示例：</p>
<pre><code class="language-python">class MyClass:
    def __init__(self):
        self.foo = 42

obj = MyClass()
print(getattr(obj, 'foo'))  # 输出: 42
print(getattr(obj, 'bar', 'default value'))  # 输出: default value
</code></pre>
<p>在上述示例中，通过 <code>getattr(obj, 'foo')</code> 获取了对象 <code>obj</code> 的属性 <code>foo</code> 的值，返回结果为 42。而通过 <code>getattr(obj, 'bar', 'default value')</code> 获取了对象 <code>obj</code> 的属性 <code>bar</code> 的值，由于该属性不存在，所以返回了指定的默认值 'default value'。</p>
<p><code>getattr()</code> 的特点是可以在 <strong>运行时动态地获取属性值</strong>，而不需要提前知道属性的名称。这在处理需要根据不同条件获取不同属性值的情况下非常有用。</p>
<h3 id="__getattr__-魔术方法"><a class="header" href="#__getattr__-魔术方法"><code>__getattr__</code> 魔术方法</a></h3>
<p>在类中定义 <code>__getattr__</code>  方法可以实现自定义的属性访问逻辑。当访问一个不存在的属性时，Python 解释器会自动调用  <code>__getattr__</code> 方法，传入属性名作为参数，并期望返回一个值。</p>
<p>以下是一个示例：</p>
<pre><code class="language-python">class MyClass:
    def __getattr__(self, name):
        print(f'Accessing attribute {name}')
        return 42

obj = MyClass()
print(obj.foo)  # 输出: Accessing attribute foo
                #      42
</code></pre>
<p>在上述示例中，当访问 obj.foo 属性时，由于该属性不存在，Python 解释器会调用  <code>__getattr__</code> 方法，并将属性名 &quot;foo&quot; 作为参数传入。 <code>__getattr__</code> 方法打印了一条消息并返回了 42。</p>
<p>需要注意的是，如果一个类定义了 <code>__getattr__</code> 方法，那么该方法只会在访问不存在的属性时被调用。对于已经存在的属性，仍然会直接访问。如果需要在访问任何属性时都进行一些处理，可以使用 <code>__getattribute__</code> 方法。</p>
<h2 id="asynciorun-vs-asynciorun"><a class="header" href="#asynciorun-vs-asynciorun">asyncio.run Vs asyncio.run</a></h2>
<p><a href="https://stackoverflow.com/questions/55590343/asyncio-run-or-run-until-complete">python - asyncio run or run_until_complete - Stack Overflow</a></p>
<p><code>loop.run_until_complete()</code> 是用于在一个已存在的事件循环中运行一个协程，它会一直运行直到协程完成或抛出异常。这个函数在 Python 3.7 之前是主要的运行协程的方法。</p>
<p>而 <code>asyncio.run()</code> 是在 Python 3.7 中引入的一个方便的函数，它会创建一个新的事件循环并在其中运行一个协程。它会一直运行直到协程完成或抛出异常，并且在协程完成后会自动关闭事件循环。</p>
<p>使用 <code>loop.run_until_complete()</code> 时，你需要先创建一个事件循环对象，并在使用完后手动关闭它。而使用 <code>asyncio.run()</code> 时，你不需要手动创建和关闭事件循环，它会自动处理这些细节。</p>
<p>以下是使用 <code>loop.run_until_complete()</code> 和 <code>asyncio.run()</code> 的示例：</p>
<p>Copy</p>
<pre><code class="language-python">import asyncio

async def my_coroutine():
    await asyncio.sleep(1)
    print(&quot;Coroutine completed&quot;)

# 使用 loop.run_until_complete()
loop = asyncio.get_event_loop()
loop.run_until_complete(my_coroutine())
loop.close()

# 使用 asyncio.run()
asyncio.run(my_coroutine())
</code></pre>
<p>在上面的示例中，<code>my_coroutine</code> 是一个简单的协程，它会等待 1 秒钟然后打印一条消息。</p>
<p>在第一个示例中，我们使用 <code>loop.run_until_complete()</code> 来运行协程。我们首先通过 <code>asyncio.get_event_loop()</code> 获取一个事件循环对象，然后通过 <code>run_until_complete()</code> 运行协程。最后，我们手动关闭事件循环。</p>
<p>在第二个示例中，我们使用 <code>asyncio.run()</code> 来运行协程。我们只需要调用 <code>asyncio.run()</code> 并传入协程，它会自动创建和关闭事件循环。</p>
<p>总结来说，<code>loop.run_until_complete()</code> 适用于在已存在的事件循环中运行协程，而 <code>asyncio.run()</code> 适用于创建一个新的事件循环并运行协程，并且它能够自动处理事件循环的创建和关闭。在 Python 3.7 及更高版本中，推荐使用 <code>asyncio.run()</code> 来运行协程。</p>
<h2 id="contentmanager"><a class="header" href="#contentmanager">@contentmanager</a></h2>
<p>在 Python 中，<code>@contextmanager</code> 是一个装饰器，用于创建上下文管理器。上下文管理器是一个对象，它定义了在进入和退出上下文时要执行的代码块。通常，上下文管理器用于管理资源的分配和释放，例如打开和关闭文件，获取和释放锁等。</p>
<p><code>@contextmanager</code> 装饰器可以应用于一个生成器函数，该函数使用 <code>yield</code> 语句来定义进入和退出上下文时的操作。被装饰的生成器函数必须返回一个上下文管理器对象。</p>
<p>当使用装饰器 <code>@contextmanager</code> 装饰一个生成器函数时，该函数将被转换为一个上下文管理器对象。装饰器会自动处理进入和退出上下文的逻辑，并在进入上下文时返回生成器的迭代器，以便在进入和退出上下文时执行相应的代码。</p>
<p>下面是一个使用 <code>@contextmanager</code> 装饰器的示例：</p>
<pre><code class="language-python">from contextlib import contextmanager

@contextmanager
def file_manager(filename):
    file = open(filename, 'w')
    try:
        yield file
    finally:
        file.close()

with file_manager('example.txt') as f:
    f.write('Hello, World!')
</code></pre>
<p>在上面的示例中，<code>file_manager</code> 函数被装饰为上下文管理器。在 <code>with</code> 语句块中，文件 <code>example.txt</code> 被打开，并在退出上下文时自动关闭。在 <code>yield</code> 语句之前的代码块表示进入上下文时要执行的操作，<code>yield</code> 语句之后的代码块表示退出上下文时要执行的操作。在 <code>with</code> 语句块中，可以使用 <code>f</code> 变量来访问文件对象，并在其中执行相应的操作。</p>
<p>使用 <code>@contextmanager</code> 装饰器可以简化上下文管理器的创建过程，使代码更加简洁和可读。</p>
<h2 id="异步-sqlite3"><a class="header" href="#异步-sqlite3">异步 sqlite3</a></h2>
<pre><code class="language-shell">pip install aiosqlite
</code></pre>
<p><a href="https://github.com/omnilib/aiosqlite">GitHub - omnilib/aiosqlite: asyncio bridge to the standard sqlite3 module</a></p>
<h2 id="python-enum-枚举类型"><a class="header" href="#python-enum-枚举类型">Python enum 枚举类型</a></h2>
<p><a href="https://docs.python.org/zh-cn/3.7/library/enum.html">enum --- 枚举类型支持 — Python 3.7.13 文档</a></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Flask Web 框架学习笔记
date: 2021-08-18 19:37:48
updated: 2021-08-18 19:37:48
categories: Python
tags: [Python, Flask, Coding]
description:
thumbnail: http://oss.whaleluo.top/blog/old/20210818152255.png
banner_img: http://oss.whaleluo.top/blog/old/20210818152255.png</p>
<hr />
<h1 id="flask-web-框架学习笔记"><a class="header" href="#flask-web-框架学习笔记">Flask Web 框架学习笔记</a></h1>
<p><img src="http://oss.whaleluo.top/blog/old/20210818152255.png-picsmall" alt="" /></p>
<h2 id="1-flask-初始化参数"><a class="header" href="#1-flask-初始化参数">1. Flask 初始化参数</a></h2>
<blockquote>
<p><strong>Flask 程序实例</strong>在创建的时候，需要<strong>默认传入当前 Flask 程序所指定的包</strong>(模块).</p>
</blockquote>
<ul>
<li>import name
<ul>
<li>Flask 程序所在的包 (模块),传 <code>__name__</code> 就可以</li>
<li>其可以决定 Flask 在访问静态文件时查找的路径</li>
</ul>
</li>
<li>static__url__path
<ul>
<li>静态文件访问路径，可以不传，默认为: /+ 静态文件目录名</li>
</ul>
</li>
<li>static_ folder
<ul>
<li>静态文件存储的文件夹，可以不传，默认为 static</li>
</ul>
</li>
<li>template_ folder
<ul>
<li>模板文件存储的文件夹，可以不传，默认为 templates</li>
</ul>
</li>
</ul>
<h3 id="flask-基本编写"><a class="header" href="#flask-基本编写">Flask 基本编写</a></h3>
<pre><code class="language-python"># 导入Flask类
from flask import Flask
#Flask类接收一个参数 __name__
app = Flask(__name__)

# 装饰器的作用是将路由映射到视图函数index
@app.route('/')
def index() :
 return 'Hello World'

# Flask应用程序实例的run方法启动WEB服务器
if __name__ == '__main__':
 app.run()
</code></pre>
<h2 id="2-flask-工程配置加载的方式"><a class="header" href="#2-flask-工程配置加载的方式">2. Flask 工程配置加载的方式</a></h2>
<h3 id="使用方式"><a class="header" href="#使用方式">使用方式</a></h3>
<p>Flask 将配置信息保存到了 <code>app.config</code> 属性中，该属性可以按照<strong>字典类型</strong>进行操作。</p>
<pre><code class="language-python3">app.config.get(name) # 读取
app.config[name] # 修改
</code></pre>
<h3 id="设置"><a class="header" href="#设置">设置</a></h3>
<ul>
<li>
<p><strong>从配置对象中加载</strong></p>
<pre><code class="language-python">from flask import Flask
class DefaultConfig(oject):
    # 密钥
    SECRET_KET = 'lovehyy2021209classpzezprem'
app = Flask(__name__)
app.config.from_object(DefaultConfig) # 从配置对象中加载

@app.route('/') # 装饰器-&gt;路由
def index(): # 视图函数
    print(app.config['SECRET_KEY'])
    return 'hello world'
</code></pre>
</li>
<li>
<p><strong>从配置文件中加载</strong></p>
<p>在项目目录下新建 <code>setting.py</code> 文件，存放大写常量</p>
<pre><code class="language-python">SECRET_KET = 'lovehyy2021209classpzezprem'
</code></pre>
<p>在 Flask 程序文件中</p>
<pre><code class="language-python">app = Flask(__name__)
app.config.from_pyfile('setting.py') # 从配置文件加载
</code></pre>
</li>
<li>
<p><strong>从环境变量中加载</strong></p>
<blockquote>
<p><strong>环境变量 (environment variables)</strong> 一般是指在操作系统中用来指定操作系统运行环境的一些参数，如: 临时文件夹位置和系统文件夹位置等。环境变量是在操作系统中一个具有特定名字的对象，它包含了一个或者多个应用程序所将使用到的信息。</p>
</blockquote>
<p><strong>通俗的理解，环境变量就是我们设置在操作系统中，由操作系统代为保存的变量值</strong>:</p>
<p>在 Linux 系统中设置和读取环境变量的方式如下:</p>
<pre><code class="language-shell">export 变量名=变量值 # 设置
echo $变量名 # 读取
</code></pre>
<p><strong>Flask 使用环境变量加载配置的本质是通过环境变量值找到配置文件</strong>，再读取配置文件的信息，其使用方式为：<br />
<code>app.config.from_ envvar('环境变量名')</code></p>
<p><strong>环境变量的值为配置文件的绝对路径</strong>先在终端中执行如下命令：</p>
<p><code>export PROJECT_ _SETTING= '~/ setting. py'</code></p>
<p>再运行如下代码</p>
<pre><code class="language-python">app = Flask(__ name__)
app.config.from_envvar('PROJECT_ SETTING', silent=True)
</code></pre>
</li>
<li>
<p><strong>各配置方式优缺点</strong></p>
<ul>
<li><strong>app.config.from _object(配置对象)</strong>
<ul>
<li>继承 - -&gt;优点复用</li>
<li>敏感数据暴露缺点</li>
</ul>
</li>
<li><strong>app.config.from_pyfile(配置文件)</strong>
<ul>
<li>优点 --&gt; 独立文件保护敏感数据</li>
<li>缺点 --&gt; 不能继承文件路径固定不灵活</li>
</ul>
</li>
<li><strong>app.config.from_envvar(&quot; 环境变量名&quot;)</strong>
<ul>
<li>优点 --&gt; 独立文件保护敏感数据文件路径不固定灵活</li>
<li>缺点 --&gt; 不方便要记得设置环境量</li>
</ul>
</li>
<li><strong>设置环境变量</strong>
<ul>
<li>终端 export</li>
<li>pycharm 设置</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="利用工厂函数设置"><a class="header" href="#利用工厂函数设置">利用工厂函数设置</a></h3>
<pre><code class="language-python">from flask import Flask

class DefaultConfig(object):
    DEBUG = True
    SECRET_KEY = 'lovehyy2021pzez209class'

def create_flask_app(config):
    '''构建flask对象的工厂函数,传入配置对象,返回配置后的app对象'''
    app = Flask(__name__, static_url_path='/static', static_folder='static')
    app.config.from_object(config)
    return app

app = create_flask_app(DefaultConfig)

@app.route('/', methods=[&quot;GET&quot;])
def index():
    return &quot;Hello Flask&quot;

if __name__ == '__mian__':
    app.run()
</code></pre>
<h2 id="3-flask-运行方式"><a class="header" href="#3-flask-运行方式">3. Flask 运行方式</a></h2>
<h3 id="直接运行-py-文件启动"><a class="header" href="#直接运行-py-文件启动">直接运行 Py 文件启动</a></h3>
<p>可以指定运行的主机 IP 地址，端口，是否开启调试模式</p>
<pre><code class="language-python">app.run(host=&quot;0.0.0.0&quot;, port=5000, debug=True)
</code></pre>
<p>关于<strong>DEBUG 调试模式</strong>：</p>
<ol>
<li>程序代码修改后可以自动重启服务器</li>
<li>在服务器出现相关错误的时候可以直接将错误信息返回到前端进行展示</li>
</ol>
<h3 id="新版启动方式"><a class="header" href="#新版启动方式">新版启动方式</a></h3>
<p><strong>开发服务器</strong>启动方式：<br />
在 1.0 版本之后，Flask 调整了开发服务器的启动方式，由代码编写 app. run() 语句调整为<strong>命令启动 flask</strong></p>
<p>终端启动：</p>
<pre><code class="language-shell">export FLASK_APP=main # 设置启动的python文件
flask run # 在项目文件下执行
</code></pre>
<h3 id="说明"><a class="header" href="#说明">说明</a></h3>
<p>环境变量 <strong>FLASK_APP</strong> 指明 flask 的启动实例：</p>
<ul>
<li><code>flask run -h 0.0.0.0 -p 8000</code> 绑定地址端口</li>
<li><code>flask run --help</code> 获取帮助</li>
<li>生产模式与开发模式的控制<br />
通过 <code>FLASK_ENV</code> 环境变量指明
<ul>
<li><code>export FLASK_ ENV=production</code> 运行在生产模式，未指明则默认为此方式</li>
<li><code>export FLASK_ ENV=development</code> 运行在开发模式</li>
</ul>
</li>
</ul>
<h2 id="4-flask-路由"><a class="header" href="#4-flask-路由">4. Flask 路由</a></h2>
<h3 id="查询路由信息"><a class="header" href="#查询路由信息">查询路由信息</a></h3>
<ul>
<li>
<p>命令行方式</p>
<pre><code class="language-shell">flask routes
</code></pre>
</li>
<li>
<p>在应用中的 <code>url_ map</code> 属性中保存着整个 Flask 应用的<strong>路由映射信息</strong>，可以通过读取这个属性获取<strong>路由信息</strong>。</p>
<p><code>print(app.url_map)</code><br />
如果想在程序中遍历路由信息，可以采用如下方式：</p>
<pre><code class="language-python">for rule in app.url_map.iter_rules():
    # endpoint 视图函数的名字
    # rule 路由的路径
 print( 'name={} path={}'. format(rule.endpoint, rule.rule))

</code></pre>
</li>
<li>
<p>搭建一个<strong>返回所有路由信息</strong>的 json 接口</p>
<pre><code class="language-python">@app.route('/', methods=[&quot;GET&quot;])
def index():
    # for rule in app.url_map.iter_rules():
    #     print(f&quot;name={rule.endpoint};path={rule.rule}&quot;)
    rules_iterator = app.url_map.iter_rules()
    # 字典推导式
    dic = {
        rule.endpoint: rule.rule
        for rule in rules_iterator
    }
    # 利用jsonify返回json数据
    return jsonify(dic)
</code></pre>
</li>
</ul>
<h2 id="5-路由-options-限定请求方式-methods"><a class="header" href="#5-路由-options-限定请求方式-methods">5. 路由 Options 限定请求方式 Methods</a></h2>
<h3 id="请求方式"><a class="header" href="#请求方式">请求方式</a></h3>
<ul>
<li>
<p><strong>GET</strong>(自带)</p>
</li>
<li>
<p><strong>OPTIONS</strong>(自带) -&gt; 简化版的 GET 请求用于询问服务器接口信息的<br />
比如接口允许的请求方式允许的</p>
<blockquote>
<p>CORS 跨域:<br />
&lt;www.meiduo.site&gt; -&gt; api.meiduo.site/users/1<br />
options api.meiduo.site/uses/1</p>
</blockquote>
</li>
<li>
<p><strong>HEAD</strong>(自带) -&gt; 简化版的 GET 请求</p>
<blockquote>
<p>只返回 GET 请求处理时的响应头，不返回响应体。</p>
</blockquote>
</li>
</ul>
<h3 id="指定接口请求方式"><a class="header" href="#指定接口请求方式">指定接口请求方式</a></h3>
<pre><code class="language-python"># 利用修饰器中的methods返回设定请求接口方式
# 定义视图
@app.route('/', methods=[&quot;POST&quot;])
def index():
    return 'POST API'
</code></pre>
<h2 id="6-蓝图"><a class="header" href="#6-蓝图">6. 蓝图</a></h2>
<h3 id="引入"><a class="header" href="#引入">引入</a></h3>
<p>在一个<strong>Flask 应用项目</strong>中，如果<strong>业务视图</strong>过多，可以用某种方式划分出的<strong>业务单元单独维护</strong>，将每个单元用到的<strong>视图、静态文件、模板文件</strong>等独立分开。</p>
<p>例如从<strong>业务角度</strong>上，可将整个应用划分为<strong>用户模块单元、商品模块单元、订单模块单元</strong>，分别开发这些不同单元，并最终整合到一个项目应用中。</p>
<h3 id="蓝图"><a class="header" href="#蓝图">蓝图</a></h3>
<p>在 Flask 中，使用<strong>蓝图 Blueprint</strong>来分模块组织管理。</p>
<p>蓝图实际可以理解为是<strong>一个存储一组视图方法的容器对象</strong>，其具有如下特点:</p>
<ul>
<li>一个应用可以具有<strong>多个 Blueprint</strong></li>
<li>可以将一个<strong>Blueprint 注册到</strong>任何一个未使用的<strong>URL</strong>下，比如“/user”、 “/godds&quot;。</li>
<li><strong>Blueprint</strong>可以单独具有<strong>自己的模板、静态文件</strong>或者其它的通用操作方法，它并不是必须要实现应用的视图和函数的</li>
<li>在一个<strong>应用初始化</strong>时，就应该要<strong>注册需要使用的 Blueprint</strong>。★</li>
<li>但是一个<strong>Blueprint</strong>并不是一个完整的应用，它<strong>不能独立于应用运行</strong>，而必须要<strong>注册到某一个应用中</strong>。★</li>
</ul>
<h3 id="定义蓝图"><a class="header" href="#定义蓝图">定义蓝图</a></h3>
<ol>
<li>
<p>定义</p>
<pre><code class="language-python">user_bp = Blueprint('user', __name__)
</code></pre>
</li>
<li>
<p>在这个<strong>蓝图对象上进行操作</strong>,<strong>注册路由</strong>,<strong>指定静态文件夹</strong>,<strong>注册模版过滤器</strong></p>
<pre><code class="language-python">@user_bp.route('/')
def user_profile():
    return 'user_profile'
</code></pre>
</li>
<li>
<p>在应用对象中注册这个蓝图对象</p>
<pre><code class="language-python">app.register_blueprint(user_bp)
</code></pre>
</li>
</ol>
<h3 id="单文件蓝图"><a class="header" href="#单文件蓝图">单文件蓝图</a></h3>
<p>可以将创建蓝图对象与定义视图函数放在一个文件中。</p>
<h3 id="目录包蓝图"><a class="header" href="#目录包蓝图">目录（包）蓝图</a></h3>
<p>对于一个打算包含<strong>多个文件的蓝图</strong>，通常将<strong>创建蓝图对象</strong>放到 Python 包的 <code>__init__.py</code> 文件中</p>
<pre><code>--------- project # 工程目录
 |---- main.py # 启动文件
 |---- user # 用户蓝图
 | |---- __init__.py # 此处创建蓝图对象
 | |---- views.py
</code></pre>
<p><img src="http://oss.whaleluo.top/blog/old/20210725224412.png-picsmall" alt="蓝图包目录实例" /></p>
<h4 id="循环引用问题"><a class="header" href="#循环引用问题">循环引用问题</a></h4>
<p><img src="http://oss.whaleluo.top/blog/old/20210725224744.png-picsmall" alt="循环引用问题" /></p>
<blockquote>
<p>所以导入视图函数要放在 <code>__init__.py</code> 文件的最后</p>
</blockquote>
<h3 id="蓝图内部静态文件"><a class="header" href="#蓝图内部静态文件">蓝图内部静态文件</a></h3>
<p>和<strong>应用对象</strong>不同，蓝图对象创建时<strong>不会默认注册静态目录的路由</strong>。需要我们在创建时指定 <code>static_folder</code> 参数。</p>
<p>下面的示例将蓝图所在目录下的 <code>static_admin</code> 目录设置为静态目录</p>
<pre><code class="language-python">admin = Blueprint (&quot;admin&quot;,__ name__ , static_folder='static_admin')
app.register_blueprint (admin, url_prefix='/admin' )
</code></pre>
<p>现在就可以使用 <code>/admin/static_admin/&lt;filename&gt;</code> 访问 <code>static_ admin</code> 目录下的静态文件了。<br />
也可通过 <code>static_url_path</code> 改变访问路径</p>
<pre><code class="language-python">admin = Blueprint(&quot;admin&quot;,__name__, static_folder='static_admin' ,static_url_path='/lib')
app.register_blueprint(admin, url_prefix='/admin')
</code></pre>
<h2 id="7-处理请求"><a class="header" href="#7-处理请求">7. 处理请求</a></h2>
<blockquote>
<p>在视图编写中需要读取客户端请求携带的数据时，如何才能正确的<strong>取出数据</strong>呢?<br />
<strong>请求携带的数据</strong>可能出现在 HTTP 报文中的不同位置，需要<strong>使用不同的方法来获取参数</strong>。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="golang"><a class="header" href="#golang">Golang</a></h1>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Golang 学习笔记——go 包的使用
date: 2022-05-28 21:54:48
updated: 2022-05-28 21:54:48
categories: Golang
tags: [Golang, Coding]
description:
thumbnail: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall
banner_img: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall</p>
<hr />
<h1 id="go-包的使用"><a class="header" href="#go-包的使用">Go 包的使用</a></h1>
<p>关于包的使用:</p>
<ol>
<li>一个目录下的文件归属一个包。<code>package</code> 的声明要一致</li>
<li>package 声明的包和对应的目录名可以不一致。但习惯上还是写成一致的</li>
<li>包可以嵌套</li>
<li>同包下的函数不需要导入包，可以直接使用</li>
<li>main 包，<code>main()</code> 函数所在的包，其他的包不能使用</li>
<li>导入包的时候，路径要从 <code>src</code> 下开始写</li>
<li><strong>变量名大写</strong> 表示该变量可以外部访问.</li>
</ol>
<h2 id="init-函数"><a class="header" href="#init-函数"><code>init()</code> 函数</a></h2>
<p><code>init()</code>、<code>main()</code> 是 Go 语言中的保留函数。我们可以在源码中，定义 <code>init()</code> 函数。此函数会在<strong>包被导入时执行</strong>，例如如果是在 <code>main()</code> 中导入包，包中存在 <code>init()</code>,那么 <code>init()</code> 中的代码会在 <code>main()</code> 函数执行前执行，用于初始化包所需要的特定资料.</p>
<h2 id="相同点"><a class="header" href="#相同点">相同点</a></h2>
<ol>
<li><code>init()</code> <code>main()</code> 函数不能有返回值也不能有参数.</li>
<li>两个函数在定义时不能有任何的参数和返回值,该函数只能由 Go 程序自动调用,不可以被引用.</li>
</ol>
<h2 id="不同点"><a class="header" href="#不同点">不同点</a></h2>
<ol>
<li><code>init()</code> 可以应用于任意包中，且可以重复定义多个。</li>
<li><code>main()</code> 函数只能用于 <code>main</code> 包中，且只能定义一个。</li>
</ol>
<h2 id="两个函数的执行顺序"><a class="header" href="#两个函数的执行顺序">两个函数的执行顺序</a></h2>
<ol>
<li>对于同一个 Go 文件,从上到下执行<br />
<img src="http://oss.whaleluo.top/blog/Golang/package-1.png-picsmall" alt="" /></li>
<li>对于同一个 package 中的不同文件,将文件名按字符串进行从小到大排序,之后顺序调用各文件中的 <code>init()</code> 函数.<br />
<img src="http://oss.whaleluo.top/blog/Golang/package-2.png-picsmall" alt="" /></li>
<li>对于不同的 package,如果不相互依赖的话，按照 main 包中 import 的顺序调用其他包中的 <code>init()</code> 函数。</li>
<li>如果 package 存在依赖,调用顺序为最后被依赖的最先被初始化.<br />
例如：导入顺序 main-&gt;A-&gt;B-&gt;C ,则初始化顺序为 C-&gt;B-&gt;A-&gt;main ,一次执行对应的 init 方法。main 包总是被最后一个初始化，因为它总是依赖别的包.<br />
<img src="http://oss.whaleluo.top/blog/Golang/package-3.png-picsmall" alt="" /></li>
<li>避免出现 <strong>循环 import</strong> ,例如：<code>A-&gt;B-&gt;C-&gt;A</code>.<br />
一个包被其它多个包 import ,.但只能被初始化一次</li>
</ol>
<h2 id="总结-1"><a class="header" href="#总结-1">总结</a></h2>
<p><code>init()</code> 函数和 <code>main()</code> 函数</p>
<ol>
<li>这两个函数都是 go 语言中的<strong>保留函数</strong>。<code>init()</code> 用于初始化信息，<code>main()</code> 用于作为<strong>程序的入口</strong></li>
<li>这两个函数定义的时候：<strong>不能有参数，返回值</strong>。只能由 Go 程序自动调用，<strong>不能被引用</strong></li>
<li><code>init()</code> 函数可以定义在任意的包中，可以有多个。<code>main()</code> 函数只能在 main 包下，并且<strong>只能有一个</strong>。</li>
<li>执行顺序
<ol>
<li>先执行 <code>init()</code> 函数，后执行 <code>main()</code> 函数</li>
<li>对于同一个 Go 文件中，调用顺序是<strong>从上到下</strong>的，也就是说，先写的先被执行，后写的后被执行</li>
<li>对于同一个包下，将文件名按照字符串进行排序，之后顺序调用各个文件中 <code>init()</code> 函数</li>
<li>对于不同包下.<br />
如果不存在依赖，按照 main 包中 import 的顺序来调用对应包中 <code>init()</code> 函数如果存在依赖，<strong>最后被依赖的最先被初始化</strong><br />
导入顺序：main 一&gt;A 一&gt;B-&gt;C<br />
执行顺序：C 一&gt;B-&gt;A 一&gt;main</li>
</ol>
</li>
<li>存在依赖的包之间，不能循环导入</li>
<li>一个包可以被其他多个包 import ,但是 <strong>只能被初始化一次</strong>。</li>
<li><code>_</code> 操作，其实是<strong>引入该包</strong>，而不直接使用包里面的函数，仅仅是调用了该包里的 <code>init()</code></li>
</ol>
<h2 id="注意-1"><a class="header" href="#注意-1">注意</a></h2>
<ol>
<li>如果仅仅需要导入包时执行<strong>初始化操作</strong>，并不需要使用包内的<strong>其他函数</strong>，常量等资源。则可以在导入包时，<strong>匿名导入</strong>。<br />
这个操作经常是让<strong>很多人费解</strong>的一个操作符</li>
</ol>
<pre><code class="language-go">// 使用 `_`(空白标识符) 匿名导入.
import (
    &quot;database/sql&quot;
    _ &quot;github.com/ziutek/mymysql/godrv&quot;
)
</code></pre>
<ol>
<li>管理外部包<br />
Go 允许 import 不同代码库的代码。对于 import 要导入的外部的包，可以使用 <code>Go get</code> 命令取下来放到 <code>GOPATHS</code> 对应的目录中去。<br />
举个例子，比如说我们想通过 Go 语言连接 mysql 数据库，那么需要先下载 mysql 的数据包，打开终端并输入以下命令：</li>
</ol>
<pre><code class="language-shell">go get github.com/go-sql-driver/mysql
</code></pre>
<p>安装之后，就可以在 <code>GOPATHS</code> 目录的 <code>src</code> 下，看到对应的文件包目录.</p>
<blockquote>
<p>如果有多个 <code>GOPATHS</code> 目录,默认下载到第一个目录下.</p>
</blockquote>
<ol>
<li>我们可以通过 <code>go install</code> 来编译包文件。<br />
我们知道一个非 main 包在编译后会生成一个。a 文件 (在临时目录下生成)。除非使用 go install 安装到 <code>$GOROOT</code> 或 <code>$GOPATH</code> 下，否则你看不到 a,用于后续可执行程序链接使用。<br />
比如 Go 标准库中的包对应的源码部分路径在：<code>$GROOT/src</code>,而标准库中包编译后的 a 文件路径在 <code>$GROOT/pkg/darwin_amd64</code> 下。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Golang 学习笔记——method方法
date: 2022-05-6 21:54:48
categories: Golang
updated: 2022-05-6 21:54:48
tags: [Golang, Coding]
description:
thumbnail: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall
banner_img: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall</p>
<hr />
<h1 id="go-方法"><a class="header" href="#go-方法">Go 方法</a></h1>
<h2 id="面向对象编程-oop"><a class="header" href="#面向对象编程-oop">面向对象编程 (OOP)</a></h2>
<p>一个对象其实也就是一个简单的值或者一个变量，在这个对象中会包含一些方法，而一个方法则是一个一个和特殊类型关联的函数。</p>
<p>G0 语言中同时有函数和方法。一个方法就是一个<strong>包含了接受者的函数</strong>，接受者可以是<strong>命名类型或者结构体类型</strong>的一个<strong>值</strong>或者是一个<strong>指针</strong>。所有给定类型的方法属于<strong>该类型的方法集</strong>.</p>
<p>方法只是一个<strong>函数</strong>，它带有一个<strong>特殊的接收器类型</strong>，它是在 <code>func</code> 关键字和方法名之间编写的。接收器可以是 <code>struct</code> 类型或非 <code>struct</code> 类型。<strong>接收方可以在方法内部访问</strong>。</p>
<h2 id="对比函数"><a class="header" href="#对比函数">对比函数</a></h2>
<ul>
<li>意义<br />
方法：某个类别的行为功能，需要<strong>指定的接受者调用</strong>.<br />
函数：一段<strong>独立功能</strong>的代码，可以直接调用.</li>
<li>语法<br />
方法：方法名可以相同，只要接受者不同.<br />
函数：命名不能冲突.</li>
</ul>
<blockquote>
<p>方法可以模拟 <code>class</code> 继承结构.</p>
</blockquote>
<h2 id="定义一个方法"><a class="header" href="#定义一个方法">定义一个方法</a></h2>
<p>Go 能够给任意类型定义方法，Go 和很多其它的面向对象的语言不太一样。因此在 Go 语言里，我们为一些简单的数值、字符串、slice、map 来定义一些附加行为。<strong>方法可以被声明到任意类型</strong>，<strong>只要不是一个指针或者一个 interface。</strong></p>
<p>语法:</p>
<pre><code class="language-go">func (接收者) 方法名(参数列表)(返回值列表){
    // do..something..
}
</code></pre>
<h3 id="接收者为一个值"><a class="header" href="#接收者为一个值">接收者为一个值</a></h3>
<p><img src="http://oss.whaleluo.top/blog/Golang/method-1.png-picsmall" alt="" /></p>
<h3 id="接收者为一个指针"><a class="header" href="#接收者为一个指针">接收者为一个指针</a></h3>
<p>当调用一个方法时，会对其 <strong>每一个参数值进行拷贝</strong>，如果一个方法需要更新一个变量，或者方法的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下就需要用到指针了。</p>
<pre><code class="language-go">func (p *Point) ScaleBy(factor float64) {
    p.X *= factor
    p.Y *= factor
}
</code></pre>
<p>在现实的程序里，一般会约定如果 Point 这个类有一个指针作为接收器的方法，那么所有 Point 的方法都必须有一个指针接收器.</p>
<p>只有类型 <code>(Point)</code> 和指向他们的指针 <code>(*Point)</code>，才是可能会出现在接收器声明里的两种接收器。此外，为了避免歧义，在声明方法时，<strong>如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的</strong>，</p>
<pre><code class="language-go">type P *int
func (P) f() { /* ... */ } // compile error: invalid receiver type
</code></pre>
<p><img src="http://oss.whaleluo.top/blog/Golang/method-2.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/method-3.png-picsmall" alt="" /></p>
<h3 id="注意点"><a class="header" href="#注意点">注意点</a></h3>
<ol>
<li>不管你的 method 的 receiver 是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换。</li>
<li>在声明一个 method 的 receiver 该是指针还是非指针类型时，你需要考虑两方面的内部，第一方面是这个 <strong>对象本身是不是特别大</strong>，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为 receiver，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝,修改数据时总是会映射到原来的内存地址.</li>
</ol>
<h2 id="方法的继承性"><a class="header" href="#方法的继承性">方法的继承性</a></h2>
<h3 id="oop-继承"><a class="header" href="#oop-继承">OOP 继承</a></h3>
<p>如果两个类 (struct) 存在<strong>继承关系</strong>，其中一个是子类，另一个作为父类，那么：</p>
<ol>
<li>子类可以<strong>直接访问</strong>父类的属性和方法</li>
<li>子类可以<strong>新增</strong>自己的属性和方法</li>
<li>子类可以<strong>重写</strong>父类的方法 (就是将父类已有的方法，<strong>重新实现</strong>)</li>
</ol>
<p>封装的最重要的优点，是阻止了外部调用方对 <strong>对象内部的值任意地进行修改</strong>。因为<strong>对象内部变量只可以被同一个包内的函数修改</strong>，所以包的作者可以让这些函数确保对象内部的一些值的不变性。比如下面的 Counter 类型允许调用方来增加 counter 变量的值，并且允许将这个值 reset 为 0，但是不允许随便设置这个值。外部包根本访问不了 <code>Counter.n</code> 变量。</p>
<p>只用来访问或修改内部变量的函数被称为 <code>setter</code> 或者 <code>getter</code> 。</p>
<pre><code class="language-go">type Counter struct { n int }
func (c *Counter) N() int { return c.n }
func (c *Counter) Increment() { c.n++ }
func (c *Counter) Reset() { c.n = 0 }
</code></pre>
<h3 id="示例"><a class="header" href="#示例">示例</a></h3>
<p><code>method</code> 是可以继承的，如果匿名字段实现了一个 <code>method</code>,那么包含这个匿名字段的 <code>struct</code> 也能调用该 <code>method</code><br />
<img src="http://oss.whaleluo.top/blog/Golang/method-4.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/method-5.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/method-6.png-picsmall" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Golang 学习笔记——Go 接口
date: 2022-05-16 18:30:48
updated: 2022-05-16 18:30:48
categories: Golang
tags: [Golang, Coding]
description:
thumbnail: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall
banner_img: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall</p>
<hr />
<h1 id="go-接口"><a class="header" href="#go-接口">Go 接口</a></h1>
<p><strong>面向对象</strong> 世界中的接口的一般定义是 &quot;<strong>接口定义对象的行为</strong>&quot;。它表示让指定对象应该做什么。实现这种行为的方法（实现细节）是<strong>针对对象</strong>的。</p>
<p>在 <code>Go</code> 中，接口是 <strong>一组方法签名</strong>。当类型为接口中的所有方法提供定义时，它被称为 <strong>实现接口</strong>。它与 OOP 非常相似。接口指定了类型 <strong>应该具有</strong> 的方法，类型决定了 <strong>如何实现</strong> 这些方法。</p>
<blockquote>
<p>它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口</p>
<p>接口定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了该接口。</p>
</blockquote>
<h2 id="图示"><a class="header" href="#图示">图示</a></h2>
<p><img src="http://oss.whaleluo.top/blog/Golang/interface-1.png-picsmall" alt="" /></p>
<h2 id="示例-1"><a class="header" href="#示例-1">示例</a></h2>
<p><strong>表达一个类型属于某个接口只要这个类型实现这个接口。</strong></p>
<pre><code class="language-go">var w io.Writer
w = os.Stdout // OK: *os.File has Write method
w = new(bytes.Buffer) // OK: *bytes.Buffer has Write method
w = time.Second // compile error: time.Duration lacks Write method

var rwc io.ReadWriteCloser
rwc = os.Stdout // OK: *os.File has Read, Write, Close methods
rwc = new(bytes.Buffer) // compile error: *bytes.Buffer lacks Close method
</code></pre>
<p><img src="http://oss.whaleluo.top/blog/Golang/interface-2.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/interface-4.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/interface-3.png-picsmall" alt="" /></p>
<blockquote>
<p>Go 语言中接口和类型的实现方式是 <strong>非侵入式</strong> 的,接口定义的方法没有具体代码.</p>
</blockquote>
<h2 id="通过接口模拟多态"><a class="header" href="#通过接口模拟多态">通过接口模拟多态</a></h2>
<h3 id="多态的定义"><a class="header" href="#多态的定义">多态的定义</a></h3>
<p>&quot; 一个事物的多种形态 &quot;</p>
<p><img src="http://oss.whaleluo.top/blog/Golang/interface-5.png-picsmall" alt="" /></p>
<p>就一个接口的实现:</p>
<ol>
<li>看成 <strong>实现本身的类型</strong>，能够访问 <strong>实现类中的属性和方法</strong>.</li>
<li>看成 <strong>对应的接口类型</strong>，那就 <strong>只能够访问接口中的方法</strong>.</li>
</ol>
<p>接口的用法：</p>
<ol>
<li>一个函数如果接受 <strong>接口类型作为参数</strong>，那么实际上 <strong>可以传入该接口的任意实现类</strong> 对象作为参数。</li>
<li>定义一个类型为 <strong>接口类型</strong>，实际上可以 <strong>赋值为任意实现类的对象</strong>.</li>
</ol>
<p>鸭子类型:</p>
<blockquote>
<p>待补充…</p>
</blockquote>
<h2 id="空接口"><a class="header" href="#空接口">空接口</a></h2>
<p><code>interface{}</code> 不包含任何的方法,所以<strong>任何类型都是空接口的实现类</strong>,因此空接口可以储存任何类型的数值.<br />
<img src="http://oss.whaleluo.top/blog/Golang/interface-7.png-picsmall" alt="" /></p>
<h3 id="空接口定义任意类型的数据"><a class="header" href="#空接口定义任意类型的数据">空接口定义任意类型的数据</a></h3>
<p><img src="http://oss.whaleluo.top/blog/Golang/interface-6.png-picsmall" alt="" /></p>
<h3 id="空接口作为函数的参数"><a class="header" href="#空接口作为函数的参数">空接口作为函数的参数</a></h3>
<p>表示函数的参数可以是任意类型,相当于 Python 的 <code>typing.Any</code></p>
<p><img src="http://oss.whaleluo.top/blog/Golang/interface-8.png-picsmall" alt="" /><br />
<code>fmt</code> 包就是应用了空接口,可以传入任何参数.<br />
<code>fmt</code> 包下的 <code>Print</code> 系列函数:</p>
<pre><code class="language-go">func Print(a ...interface{}) (n int,err error)
func Printf(format string,a ...interface{}) (n int,err error)
func Println(a ...interface{}) (n int,err error)
</code></pre>
<h3 id="复合数据结构使用空接口"><a class="header" href="#复合数据结构使用空接口">复合数据结构使用空接口</a></h3>
<p><img src="http://oss.whaleluo.top/blog/Golang/interface-9.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/interface-10.png-picsmall" alt="" /></p>
<h2 id="接口嵌套"><a class="header" href="#接口嵌套">接口嵌套</a></h2>
<p>接口允许多继承.</p>
<p><img src="http://oss.whaleluo.top/blog/Golang/interface-11.png-picsmall" alt="" /></p>
<p>如果 Cat 想实现接口 C,不仅要实现接口 C 自己的方法,还要实现接口 C 继承的接口 A B 中的方法.</p>
<p><img src="http://oss.whaleluo.top/blog/Golang/interface-12.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/interface-13.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/insterface-14.png-picsmall" alt="" /></p>
<h2 id="接口断言"><a class="header" href="#接口断言">接口断言</a></h2>
<p>前面说过，因为空接口 <code>interface</code> 没有定义任何函数，因此 <code>Go</code> 中 <strong>所有类型都实现了空接口</strong>。当一个函数的形参是 <code>interface{}</code> ，那么在函数中，需要对形参 <strong>进行断言</strong>，从而 <strong>得到它的真实类型</strong>。</p>
<p><img src="http://oss.whaleluo.top/blog/Golang/interface-15.png-picsmall" alt="" /></p>
<p>方法一: 通过 <code>x.(T)</code> 的方式断言</p>
<pre><code class="language-go">var w io.Writer
w = os.Stdout
f := w.(*os.File)      // success: f == os.Stdout
c := w.(*bytes.Buffer) // panic: interface holds *os.File, not *bytes.Buffer
</code></pre>
<p><strong>如果断言的类型 T 是一个接口类型</strong>，然后类型断言检查是否 x 的动态类型满足 T。如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同动态类型（type）和值部分（value）的接口值，但是结果为类型 T。</p>
<p>用于判断 <code>x.(T)</code> x 是否满足 T 接口。</p>
<pre><code class="language-go">var w io.Writer // io.Writer 接口
w = os.Stdout // os.Stdout接口 实现了 io.Writer 接口
rw := w.(io.ReadWriter) // success: *os.File has both Read and Write
w = new(ByteCounter)
rw = w.(io.ReadWriter) // panic: *ByteCounter has no Read method
</code></pre>
<p>如果一个类型满足下面的这个接口，然后 <code>WriteString(s)</code> 方法就必须和 <code>Write([]byte(s))</code> 有相同的效果。</p>
<p>Write 方法需要传入一个 byte 切片而我们希望写入的值是一个字符串，所以我们需要使用 <code>[]byte(…)</code> 进行转换。<strong>这个转换分配内存并且做一个拷贝</strong>，但是这个拷贝在转换后几乎立马就被丢弃掉，会影响一丢丢性能。</p>
<p>我们知道在这个程序中的 w 变量持有的动态类型也有一个<strong>允许字符串高效写入</strong>的 <code>WriteString</code> 方法；这个方法会避免去分配一个临时的拷贝。</p>
<p>许多满足 io.Writer 接口的重要类型同时也有 WriteString 方法，包括 <code>*bytes.Buffer</code>，<code>*os.File</code> 和 <code>*bufio.Writer</code>。</p>
<p>我们不能对任意实现 <code>io.Writer</code> 接口类型的变量 w，假设它也拥有 <code>WriteString</code> 方法。但是我们可以定义一个只有这个方法的新接口并且使用类型断言来检测是否 w 的动态类型满足这个新接口。</p>
<pre><code class="language-go">func writeString(w io.Writer, s string) (n int, err error) {
    // 定义一个实现了 WriteString 方法的接口
    type stringWriter interface {
        WriteString(string) (n int, err error)
    }
    // 检查 w 是否实现了 WriteString 方法
    if sw, ok := w.(stringWriter); ok {
        // 实现了就调用这个方法
        return sw.WriteString(s) // avoid a copy
    }
    // 没有实现 WriteString 方法就回退到使用 w.Write 方法
    return w.Write([]byte(s)) // allocate temporary copy
}
</code></pre>
<p>它太有用了以致于标准库将它作为 <code>io.WriteString</code> 函数提供。<strong>这是向一个 io.Writer 接口写入字符串的推荐方法。</strong></p>
<p>上面的 writeString 函数使用一个<strong>类型断言来获知一个普遍接口类型的值是否满足一个更加具体的接口类型</strong>；并且如果满足，它会使用这个更具体接口的行为。</p>
<p><strong>如果断言操作的对象是一个 nil 接口值</strong>，那么不论被断言的类型是什么这个类型断言都会失败。</p>
<p><img src="http://oss.whaleluo.top/blog/Golang/interface-16.png-picsmall" alt="通过x.(T)方式断言" /></p>
<pre><code class="language-go">var w io.Writer = os.Stdout
f, ok := w.(*os.File)      // success:  ok, f == os.Stdout
b, ok := w.(*bytes.Buffer) // failure: !ok, b == nil

// 更简洁的结构
if f, ok := w.(*os.File); ok {
    // ...use f...
}
</code></pre>
<p>当类型断言的操作对象是一个变量时，if 内层其实是声明了一个同名的新的本地变量，外层原来的 w 不会被改变。</p>
<pre><code class="language-go">if w, ok := w.(*os.File); ok {
    // ...use w...
}
</code></pre>
<p>方法二：使用 <code>switch…case…</code> 语句，断言类型分支。</p>
<p>一个类型分支隐式的创建了一个词法块，因此新变量 x 的定义不会和外面块中的 x 变量冲突。每一个 case 也会隐式的创建一个单独的词法块。</p>
<pre><code class="language-go">switch x := x.(type) {
    case nil:       // ...
    case int, uint: // ...
    case bool:      // ...
    case string:    // ...
    default:        // ...
}
</code></pre>
<p><img src="http://oss.whaleluo.top/blog/Golang/interface-17.png-picsmall" alt="" /></p>
<h2 id="接口值"><a class="header" href="#接口值">接口值</a></h2>
<p>接口值由两部分组成：一个具体的类型（type）和这个类型的值（value）。**接口是动态类型。**一个接口值可以持有任意大的动态值。实现了这个接口的类型都可以赋值这个接口。</p>
<p><img src="http://oss.whaleluo.top/blog/img/20221229121130.png-picsmall" alt="" /></p>
<p>定义一个 nil 接口：</p>
<pre><code class="language-go">var w io.Writer // 空接口
w.Writer([]byte(&quot;hello&quot;)) // panic: nil pointer
// 可以通过 w == nil 判断接口值是否为空
</code></pre>
<p>将 <code>*os.File</code> 类型赋值给变量 w，因为 <code>*os.File</code> 实现了 <code>io.Writer</code> 接口，所以赋值合法。赋值过程调用了一个 <strong>具体类型到接口类型</strong> 的隐式转换（变成 T 类型 <code>T(type)</code> ） <code>io.Writer(os.Stdout)</code></p>
<pre><code class="language-go">w = os.Stdout
// 隐式转换 
io.Writer(os.Stdout)
</code></pre>
<p>接口的 value 持有 <code>os.Stdout</code> 的拷贝，这是一个代表处理标准输出的 <code>os.File</code> 类型的指针。</p>
<p><img src="http://oss.whaleluo.top/blog/img/20221229122508.png-picsmall" alt="接口的赋值" /></p>
<p>调用一个包含 <code>*os.File</code> 类型指针的接口值的 <code>Write</code> 方法，得 <code>(*os.File).Write</code> 方法被调用。这个调用输出 “hello”。</p>
<pre><code class="language-go">w.Write([]byte(&quot;hello&quot;)) // &quot;hello&quot;
(*os.File).Write // 等效
</code></pre>
<p>当我们处理错误或者调试的过程中，得知接口值的动态类型是非常有帮助的。所以我们使用 <code>fmt</code> 包的 <code>%T</code> 动作，在 fmt 包内部，使用反射来获取接口动态类型的名称。</p>
<pre><code class="language-go">var w io.Writer
fmt.Printf(&quot;%T\n&quot;, w) // &quot;&lt;nil&gt;&quot;
w = os.Stdout
fmt.Printf(&quot;%T\n&quot;, w) // &quot;*os.File&quot;
w = new(bytes.Buffer)
fmt.Printf(&quot;%T\n&quot;, w) // &quot;*bytes.Buffer&quot;
</code></pre>
<h3 id="一个包含-nil-指针的接口不是-nil-接口"><a class="header" href="#一个包含-nil-指针的接口不是-nil-接口">⚠️一个包含 Nil 指针的接口不是 Nil 接口</a></h3>
<p>一个不包含任何值的 nil 接口值：</p>
<p><img src="http://oss.whaleluo.top/blog/img/20221229121130.png-picsmall" alt="一个不包含任何值的 nil 接口值" /></p>
<p>一个刚好包含 nil 指针的接口值：</p>
<p><img src="http://oss.whaleluo.top/blog/img/20221229123705.png-picsmall" alt="" /></p>
<pre><code class="language-go">var w io.Writer
w = new(bytes.Buffer)  // new函数返回类型的初始化值的指针 nil w: *bytes.Buffer
// w not nil
</code></pre>
<pre><code class="language-go">func main() {
    var w io.Writer
    w = new(bytes.Buffer)
    fmt.Printf(&quot;w: %T\n&quot;, w)
    if w == nil{
        fmt.Println(&quot;w is nil&quot;)
    } else {
        fmt.Println(&quot;w not nil&quot;)
    }
}

// output:
// w: *bytes.Buffer
// w not nil
</code></pre>
<h2 id="应用-2"><a class="header" href="#应用-2">应用</a></h2>
<h3 id="sortinterface-接口"><a class="header" href="#sortinterface-接口"><code>sort.Interface</code> 接口</a></h3>
<p>在很多语言中，排序算法都是和序列数据类型关联，但 Go 语言的 <code>sort.Sort</code> 函数不会对具体的序列和它的元素做限定。它使用一个接口类型 <code>sort.Interface</code> 来指定通用的序列算法。</p>
<p>一个内置的排序算法需要知道三个东西：序列的长度，表示两个元素比较的结果，一种交换两个元素的方式；这就是 <code>sort.Interface</code> 接口的三个方法：</p>
<pre><code class="language-go">package sort
type Interface interface {
    Len() int // 序列长度
    Less(i, j int) bool // 两个元素比较的结果
    Swap(i, j int) // 交换两个元素
}
</code></pre>
<p>排列字符串切片：</p>
<pre><code class="language-go">sort.Sort(StringSlice(names)) // 将切片转换为实现 `sort.Interface` 接口的类型
sort.Strings(names) // 简化
</code></pre>
<h3 id="httphandler-接口"><a class="header" href="#httphandler-接口"><code>http.Handler</code> 接口</a></h3>
<p><u><em>net/http</em></u></p>
<pre><code class="language-go">package http
type Handler interface { 
    ServeHTTP(w ResponseWriter, r*Request)
} 
func ListenAndServe(address string, h Handler) error
</code></pre>
<p><code>ListenAndServe</code> 函数需要一个例如“localhost:8000”的服务器地址，和一个所有请求都可以分派的 Handler 接口实例。它会一直运行，直到这个服务因为一个错误而失败（或者启动失败），它的返回值一定是一个非空的错误。</p>
<p>使用不同的 URL 触发不同的行为</p>
<pre><code class="language-go">func (db database) ServeHTTP(w http.ResponseWriter, req *http.Request) {
switch req.URL.Path {
case &quot;/list&quot;:
    for item, price := range db {
    fmt.Fprintf(w, &quot;%s: %s\n&quot;, item, price)
    }
case &quot;/price&quot;:
    // Quary 方法可以将 http 请求参数解析为一个 map
    item := req.URL.Query().Get(&quot;item&quot;)
    price, ok := db[item]
    if !ok {
    w.WriteHeader(http.StatusNotFound) // 404
    fmt.Fprintf(w, &quot;no such item: %q\n&quot;, item)
    return
    }
    fmt.Fprintf(w, &quot;%s\n&quot;, price)
default:
    w.WriteHeader(http.StatusNotFound) // 404
    fmt.Fprintf(w, &quot;no such page: %s\n&quot;, req.URL)
}
}
</code></pre>
<p>现在 handler 基于 URL 的路径部分（<code>req.URL.Path</code>）来决定执行什么逻辑。如果不能识别，调用 <code>w.WriteHeader(http.StatusNotFound)</code> 返回客户端一个 HTTP 404 错误。</p>
<p><code>http.ResponseWriter</code> 是另一个接口。它在 <code>io.Writer</code> 上增加了发送 HTTP 相应头的方法。另外，还可以使用 <code>http.Error</code> 函数。</p>
<pre><code class="language-go">http.Error(w, msg, http.StatusNotFound)
</code></pre>
<p>net/http 包提供了一个请求多路器 <code>ServeMux</code> 来简化 URL 和 handlers 的联系（路由映射）。一个 ServeMux 将一批 <code>http.Handler</code> 聚集到一个单一 <code>http.Handler</code> 中。</p>
<pre><code class="language-go">func main() {
    mux := http.NewServeMux()
    mux.Handle(&quot;/list&quot;, http.HandlerFunc(db.list))
    mux.Handle(&quot;/price&quot;, http.HandlerFunc(db.price))
    log.Fatal(http.ListenAndServe(&quot;localhost:8000&quot;, mux))
}
</code></pre>
<p>所以 <code>db.list</code> 是一个实现了 handler 类似行为的函数，但是因为它没有方法，所以它不满足 <code>http.Handler</code> 接口并且不能直接传给 <code>mux.Handle</code>。</p>
<p>语句 <code>http.HandlerFunc(db.list)</code> 是一个转换而非一个函数调用，因为 <code>http.HandlerFunc</code> 是一个类型。它有如下的定义：</p>
<pre><code class="language-go">package http
type HandlerFunc func(w ResponseWriter, r *Request)
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
    f(w, r)
}
</code></pre>
<p>因为 handler 通过这种方式注册非常普遍，ServeMux 有一个方便的 HandleFunc 方法，它帮我们简化 handler 注册代码成这样：</p>
<pre><code class="language-go">mux.HandleFunc(&quot;/list&quot;, db.list)
mux.HandleFunc(&quot;/price&quot;, db.price)
</code></pre>
<p>为了方便，net/http 包提供了一个全局的 ServeMux 实 DefaultServerMux 和包级别的 <code>http.Handle</code> 和 <code>http.HandleFunc</code> 函数。现在，为了使用 DefaultServeMux 作为服务器的主 handler，我们不需要将它传给 ListenAndServe 函数；nil 值就可以工作。</p>
<p>使用包级别的 <code>http.HandleFunc</code> 注册路由：</p>
<pre><code class="language-go">func main() {
    db := database{&quot;shoes&quot;: 50, &quot;socks&quot;: 5}
    http.HandleFunc(&quot;/list&quot;, db.list)
    http.HandleFunc(&quot;/price&quot;, db.price)
    log.Fatal(http.ListenAndServe(&quot;localhost:8000&quot;, nil))
}
</code></pre>
<p>最后，web 服务器在一个新的协程 Goruntine 中调用每一个 handler，所以当 handler 获取其它协程的共享变量时一定要使用预防措施比如 <strong>锁机制</strong>。</p>
<h3 id="error-接口"><a class="header" href="#error-接口">Error 接口</a></h3>
<pre><code class="language-go">type error interface {
    Error() string
}
</code></pre>
<p>创建一个 error 最简单的方法就是 <code>error.New</code> 函数，其实整个 error 包只有 4 行：</p>
<pre><code class="language-go">package errors
func New(text string) error { return &amp;errorString{text} }
type errorString struct { text string }
func (e *errorString) Error() string { return e.text }
</code></pre>
<p>指针类型 <code>*errorString</code> 满足 error 接口而非 <code>errorString</code> 类型，承载 <code>errorString</code> 的类型是一个结构体而非一个字符串，所以每个 New 函数的调用都分配了一个独一无二的错误示例。</p>
<pre><code class="language-go">fmt.Println(errors.New(&quot;EOF&quot;) == errors.New(&quot;EOF&quot;)) // &quot;false&quot;
</code></pre>
<p>有一个方便的封装函数 <code>fmt.Errorf</code>，允许对错误信息进行字符串格式化 ：</p>
<pre><code class="language-go">package fmt
import &quot;errors&quot;
func Errorf(format string, args ...interface{}) error {
    return errors.New(Sprintf(format, args...))
}
</code></pre>
<p><a href="https://www.cnblogs.com/cheyunhua/p/16007219.html">详解 Go 语言的 rune 类型</a></p>
<h2 id="建议"><a class="header" href="#建议">建议</a></h2>
<p>当设计一个新的包时，小白 Gopher 总是先创建一套接口，然后再定义一些满足它们的具体类型。这种方式的结果就是有很多的接口，它们中的每一个仅只有一个实现。<strong>接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要</strong>。</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Golang 学习笔记——func函数
date: 2022-05-2 2:17:48
updated: 2022-05-2 2:17:48
categories: Golang
tags: [Golang, Coding]
description:
thumbnail: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall
banner_img: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall</p>
<hr />
<h1 id="go-函数"><a class="header" href="#go-函数">Go 函数</a></h1>
<pre><code class="language-go">// 6.5, 7.8 实际参数
// x, y 形式参数
res := hypot(6.5, 7.8)

func hypot(x, y float64) float64 {
   return math.Sqrt(x*x + y*y)
}
fmt.Println(hypot(3,4)) // &quot;5&quot;
</code></pre>
<p>函数调用时，Go 语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义。</p>
<p>实参通过值的方式传递，因此函数的 <strong>形参是实参的拷贝</strong> 。对形参进行修改不会影响实参。但是，如果实参包括 <strong>引用类型</strong>，如指针，slice(切片)、map、function、channel 等类型，实参可能会由于函数的简介引用被修改。</p>
<p>偶尔遇到没有函数体的函数声明，这表示该函数不是以 Go 实现的。这样的声明定义了函数标识符。</p>
<p>Go 使用控制流机制（如 if 和 return）处理异常，这使得编码人员能更多的关注错误处理。</p>
<p><img src="http://oss.whaleluo.top/blog/Golang/func-2.png-picsmall" alt="" /></p>
<h2 id="函数调用过程"><a class="header" href="#函数调用过程">函数调用过程</a></h2>
<p><img src="http://oss.whaleluo.top/blog/Golang/func-1.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/func-3.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/func-4.png-picsmall" alt="" /></p>
<h2 id="函数的参数使用"><a class="header" href="#函数的参数使用">函数的参数使用</a></h2>
<p><img src="http://oss.whaleluo.top/blog/Golang/func-5.png-picsmall" alt="" /></p>
<h2 id="实参和形参"><a class="header" href="#实参和形参">实参和形参</a></h2>
<p><img src="http://oss.whaleluo.top/blog/Golang/func-6.png-picsmall" alt="" /></p>
<h2 id="函数传参"><a class="header" href="#函数传参">函数传参</a></h2>
<p><img src="http://oss.whaleluo.top/blog/Golang/func-7.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/func-8.png-picsmall" alt="" /></p>
<h2 id="可变参数"><a class="header" href="#可变参数">可变参数</a></h2>
<p>参数数量可变的函数称为为可变参数函数。需要在参数列表的最后一个参数类型之前加上省略符号“…”，这表示该函数会接收任意数量的该类型参数。</p>
<pre><code class="language-go">func sum(vals...int) int
</code></pre>
<p>在函数体中,vals 被看作是类型为 []int 的切片。sum 可以接收任意数量的 int 型参数：</p>
<p>如果原始参数已经是切片类型,在最后一个参数后加上省略符。</p>
<pre><code class="language-go">values := []int{1, 2, 3, 4}
fmt.Println(sum(values...)) // &quot;10&quot;
</code></pre>
<p><img src="http://oss.whaleluo.top/blog/Golang/func-9.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/func-10.png-picsmall" alt="" /></p>
<h2 id="参数传递"><a class="header" href="#参数传递">参数传递</a></h2>
<p>实参通过值的方式传递，因此函数的 <strong>形参是实参的拷贝</strong> 。对形参进行修改不会影响实参。但是，如果实参包括 <strong>引用类型</strong>，如指针，slice(切片)、map、function、channel 等类型，实参可能会由于函数的间接引用被修改。</p>
<p><img src="http://oss.whaleluo.top/blog/Golang/func-13.png-picsmall" alt="" /></p>
<h3 id="参数的值传递"><a class="header" href="#参数的值传递">参数的值传递</a></h3>
<p><img src="http://oss.whaleluo.top/blog/Golang/func-11.png-picsmall" alt="" /></p>
<h3 id="参数的引用传递"><a class="header" href="#参数的引用传递">参数的引用传递</a></h3>
<p><img src="http://oss.whaleluo.top/blog/Golang/func-12.png-picsmall" alt="" /></p>
<h2 id="函数的返回值"><a class="header" href="#函数的返回值">函数的返回值</a></h2>
<p><img src="http://oss.whaleluo.top/blog/Golang/func-17.png-picsmall" alt="" /></p>
<hr />
<p><img src="http://oss.whaleluo.top/blog/Golang/func-14.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/func-15.png-picsmall" alt="" /></p>
<blockquote>
<p>在定义参数返回值的时候已经初始化了.</p>
</blockquote>
<h3 id="函数多返回值"><a class="header" href="#函数多返回值">函数多返回值</a></h3>
<p>如果一个函数将所有的返回值都显示的变量名，那么该函数的 return 语句可以省略操作数。这称之为 bare return。</p>
<p><img src="http://oss.whaleluo.top/blog/Golang/func-16.png-picsmall" alt="" /></p>
<h3 id="return-语句"><a class="header" href="#return-语句">Return 语句</a></h3>
<p><img src="http://oss.whaleluo.top/blog/Golang/func-18.png-picsmall" alt="" /><br />
<code>return</code> 语句：词义 &quot; 返回 &quot;</p>
<ol>
<li>一个函数有返回值，那么使用 return 将返回值返回给调用处</li>
<li>同时意味着结束了函数的执行</li>
</ol>
<p><strong>注意点:</strong></p>
<ol>
<li>一个函数定义了返回值，必须使用 return 语句将<strong>结果返回给调用处</strong>。return 后的数据必须和<strong>函数定义的一致</strong>：个数，类型，顺序。</li>
<li>可以使用 <code>_</code>,来舍弃多余的返回值</li>
<li>如果一个函数定义了有返回值，那么函数中有分支，循环，那么要保证，无论执行了哪个分支，都要有 <code>return</code> 语句被执行到.</li>
<li>如果一个函数没有定义返回值，那么函数中也可以使用 return,专门用于<strong>结束函数的执行</strong>。</li>
</ol>
<h2 id="函数中变量的作用域"><a class="header" href="#函数中变量的作用域">函数中变量的作用域</a></h2>
<p><img src="http://oss.whaleluo.top/blog/Golang/func-19.png-picsmall" alt="" /></p>
<blockquote>
<p>随着函数的结束,函数内的变量自己会销毁.</p>
</blockquote>
<h3 id="全局变量和局部变量"><a class="header" href="#全局变量和局部变量">全局变量和局部变量</a></h3>
<p><img src="http://oss.whaleluo.top/blog/Golang/func-20.png-picsmall" alt="" /></p>
<blockquote>
<p>全局变量 <strong>不支持简短定义的写法</strong></p>
<pre><code class="language-go">// s := 0.12 全局变量不能使用类型推断
var s float64 = 0.12  // 全局变量定义正确方式
</code></pre>
</blockquote>
<h2 id="递归函数"><a class="header" href="#递归函数">递归函数</a></h2>
<p><img src="http://oss.whaleluo.top/blog/Golang/func-21.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/func-22.png-picsmall" alt="" /></p>
<p>递归函数实现 fibonacci 数列 (斐波那契数列)</p>
<p><img src="http://oss.whaleluo.top/blog/Golang/func-23.png-picsmall" alt="斐波那契数列" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/func-24.png-picsmall" alt="" /></p>
<h2 id="defer延迟函数"><a class="header" href="#defer延迟函数">defer(延迟函数)</a></h2>
<p><strong>defer 的词义:&quot; 延迟&quot;,&quot; 推迟&quot;</strong>,在 go 语言中,使用 <code>defer</code> 关键字来延迟一个函数或者方法的执行.</p>
<p>你可以在一个函数中执行多条 defer 语句，它们的执行顺序与声明顺序相反。</p>
<p>defer 语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。释放资源的 defer 应该直接跟在请求资源的语句后。</p>
<ol>
<li>deferi 函数或方法：<strong>一个函数或方法的执行被延迟了。</strong></li>
<li>defer 的用法:<br />
对象,close(),临时文件的删除.<br />
文件.open()<br />
defer close() 关闭文件</li>
</ol>
<pre><code class="language-go">package ioutil
func ReadFile(filename string) ([]byte, error) {
   f, err := os.Open(filename)
   if err != nil {
      return nil, err
   }
   defer f.Close()
   return ReadAll(f)
}
</code></pre>
<h3 id="使用-defer-记录函数"><a class="header" href="#使用-defer-记录函数">使用 Defer 记录函数</a></h3>
<p>defer 机制也常被用于记录何时进入和退出函数。</p>
<p>不要忘记 defer 语句后的圆括号，否则本该在进入时执行的操作会在退出时执行，而本该在退出时执行的，永远不会被执行。</p>
<pre><code class="language-go">// 使用闭包跟踪函数运行时间
func trace(msg string) func() {
   start := time.Now()
   log.Printf(&quot;enter %s&quot;, msg)
   return func() {
      log.Printf(&quot;exit %s (%s)&quot;, msg,time.Since(start))
   }
}

func bigSlowOperation() {
   defer trace(&quot;bigSlowOperation&quot;)() // don't forget the
   // extra parentheses
   // ...lots of work…
   time.Sleep(10 * time.Second) // simulate slow
   // operation by sleeping
}
</code></pre>
<h3 id="语言中关于异常的处理"><a class="header" href="#语言中关于异常的处理">语言中关于异常的处理</a></h3>
<p>虽然 Go 的 panic 机制类似于其他语言的异常，但 panic 的适用场景有一些不同。由于 panic 会引起程序的崩溃，因此 panic 一般用于严重错误，如程序内部的逻辑不一致.对于大部分漏洞，我们应该使用 Go 提供的错误机制，而不是 panic ，<strong>尽量避免程序的崩溃</strong>。</p>
<p><code>regexp</code> 包提供了包装函数 <code>regexp.MustCompile</code> 检查输入的合法性。输入错误就立马 panic,函数名中的 <strong>Must 前缀是一种针对此类函数输入错误的立马 panic</strong></p>
<pre><code class="language-go">package regexp
func Compile(expr string) (*Regexp, error) { /* ... */ }
func MustCompile(expr string) *Regexp {
re, err := Compile(expr)
if err != nil {
panic(err)
}
return re
}
</code></pre>
<h4 id="runtime-输出堆栈信息"><a class="header" href="#runtime-输出堆栈信息">Runtime 输出堆栈信息</a></h4>
<pre><code class="language-go">func main() {
defer printStack()
f(3)
}
func printStack() {
var buf [4096]byte  // 字节切片储存信息
n := runtime.Stack(buf[:], false) // 写入
os.Stdout.Write(buf[:n]) // 写入到输出流
}
</code></pre>
<h4 id="使用-panic-和-recover"><a class="header" href="#使用-panic-和-recover">使用 <code>panic()</code> 和 <code>recover()</code></a></h4>
<p>panic 函数用于引发恐慌，导致程序中断执行</p>
<p>recover 函数用于恢复程序的执行，<code>recover()</code> 语法上要求必须在 <code>defer</code> 中执行。</p>
<ol>
<li>如果多个 defer 函数：</li>
<li>defer 函数传递参数的时候：</li>
</ol>
<p>如果在 deferred 函数中调用了内置函数 recover，并且定义该 defer 语句的函数发生了 panic 异常，recover 会使程序从 panic 中恢复，并返回 panic value。导致 panic 异常的函数<strong>不会继续运行，但能正常返回</strong>。在未发生 panic 时调用 recover，recover 会返回 nil。</p>
<pre><code class="language-go">func Parse(input string) (s *Syntax, err error) {
defer func() {
if p := recover(); p != nil {
err = fmt.Errorf(&quot;internal error: %v&quot;, p)
}
}()
// ...parser...
    panic(&quot;错误&quot;) // 程序不会停止,会转到 defer recover 处理
}
</code></pre>
<p>安全的做法是有选择性的 recover 。换句话说，只恢复应该被恢复的 panic 异常.</p>
<p>可以将 panic value 设置成特殊类型。在 recover 时对 panic value 进行检查，如果发现 panic value 是特殊类型，就将这个 panic 作为 error 处理，如果不是，则按照正常的 panic 进行处理.</p>
<pre><code class="language-go">func soleTitle(doc *html.Node) (title string, err error) {
type bailout struct{}
defer func() {
    // 通过 switch 语句 判断 panic 的类型
    // 进行有选择的 recover
switch p := recover(); p {
case nil: // no panic
case bailout{}: // &quot;expected&quot; panic
err = fmt.Errorf(&quot;multiple title elements&quot;)
default:
panic(p) // unexpected panic; carry on panicking
}
}()

panic(bailout{})
}

</code></pre>
<h3 id="栈的结构-先进后出后进先出"><a class="header" href="#栈的结构-先进后出后进先出">栈的结构 (先进后出!后进先出!)</a></h3>
<p><img src="http://oss.whaleluo.top/blog/Golang/func-25.png-picsmall" alt="" /><br />
当一个函数有多个延迟调用时，它们被添加到一<br />
个堆栈中，并 Last In First Out(LIFO) <strong>先进后出!后进先出!</strong> 的顺序中执行。</p>
<p><img src="http://oss.whaleluo.top/blog/Golang/func-26.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/func-27.png-picsmall" alt="" /></p>
<h3 id="defer-注意点"><a class="header" href="#defer-注意点">Defer 注意点</a></h3>
<ol>
<li>当外围函数中的语句正常执行完毕时，只有其中所有的延迟函数都执行完毕，外围函数才会真正的结束执行。</li>
<li>当执行外围函数中的 return 语句时，只有其中所有的延迟函数都执行完毕后，外围函数才会真正返回。</li>
<li>当外围函数中的代码引发运行恐慌时，只有其中所有的延迟函数都执行完毕后，该运行时恐慌才会真正被扩展至调用函数。</li>
</ol>
<h2 id="函数的数据类型"><a class="header" href="#函数的数据类型">函数的数据类型</a></h2>
<p>在 Go 中，函数被看作第一类值 (一等公民)（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。</p>
<p><code>strings.Map</code> <strong>对字符串中的每个字符</strong> 调用 add1 函数，并将每个 add1 函数的返回值组成一个新的字符串返回给调用者。</p>
<pre><code class="language-go">type rune = int32
func Map(mapping func(rune) rune, s string) string
</code></pre>
<pre><code class="language-go">func add1(r rune) rune { return r + 1 }

fmt.Println(strings.Map(add1, &quot;HAL-9000&quot;)) // &quot;IBM.:111&quot;
fmt.Println(strings.Map(add1, &quot;VMS&quot;)) // &quot;WNT&quot;
fmt.Println(strings.Map(add1, &quot;Admix&quot;)) // &quot;Benjy&quot;
</code></pre>
<p>函数的类型：<br />
<code>func(参数列表的数据类型)(返回值列表的数据类型)</code></p>
<p><img src="http://oss.whaleluo.top/blog/Golang/func-31.png-picsmall" alt="" /></p>
<h3 id="基本类型回顾"><a class="header" href="#基本类型回顾">基本类型回顾</a></h3>
<p><img src="http://oss.whaleluo.top/blog/Golang/func-28.png-picsmall" alt="" /></p>
<h2 id="函数的本质"><a class="header" href="#函数的本质">函数的本质</a></h2>
<p><img src="http://oss.whaleluo.top/blog/Golang/func-30.png-picsmall" alt="" /></p>
<hr />
<p><img src="http://oss.whaleluo.top/blog/Golang/func-29.png-picsmall" alt="" /></p>
<blockquote>
<p>&quot; 说到底,函数也是一种特殊类型的变量.&quot;</p>
</blockquote>
<p><img src="http://oss.whaleluo.top/blog/Golang/func-32.png-picsmall" alt="" /></p>
<h2 id="匿名函数"><a class="header" href="#匿名函数">匿名函数</a></h2>
<p>拥有函数名的函数只能在包级语法块中被声明，通过函数字面量（function literal），，在任何表达式中表示一个函数值。函数值字面量是一种表达式，它的值被称为匿名函数<br />
（anonymous function）。</p>
<pre><code class="language-go">strings.Map(func(r rune) rune { return r + 1 }, &quot;HAL-9000&quot;)
</code></pre>
<p>通过这种方式定义的函数可以访问 <strong>完整的词法环境</strong>（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量，如下例所示：</p>
<p>在 squares 中定义的匿名内部函数可以访问和更新 squares 中的局部变量，匿名函数和 squares 中，存在变量引用。</p>
<p>变量的生命周期不由它的作用域决定：squares 返回后，变量 x 仍然隐式的存在于 f 中。</p>
<p>Go 使用闭包（closures）技术实现函数值，Go 程序员也把函数值叫做闭包。</p>
<pre><code class="language-go">// squares返回一个匿名函数。（闭包）
// 该匿名函数每次被调用时都会返回下一个数的平方。
func squares() func() int {
   var x int
   return func() int {
      x++
      return x * x
   }
}
func main() {
   // f是匿名函数，可以访问到 squares 保持的 x 局部变量
   f := squares() 
   fmt.Println(f()) // &quot;1&quot;
   fmt.Println(f()) // &quot;4&quot;
   fmt.Println(f()) // &quot;9&quot;
   fmt.Println(f()) // &quot;16&quot;
}
</code></pre>
<p><img src="http://oss.whaleluo.top/blog/Golang/func-36.png-picsmall" alt="" /></p>
<hr />
<p><img src="http://oss.whaleluo.top/blog/Golang/func-34.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/func-35.png-picsmall" alt="" /></p>
<h2 id="回调函数"><a class="header" href="#回调函数">回调函数</a></h2>
<p><img src="http://oss.whaleluo.top/blog/Golang/func-41.png-picsmall" alt="" /></p>
<hr />
<p><img src="http://oss.whaleluo.top/blog/Golang/func-37.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/func-38.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/func-39.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/func-40.png-picsmall" alt="" /></p>
<h2 id="闭包"><a class="header" href="#闭包">闭包</a></h2>
<h3 id="go-语言支持函数式编程"><a class="header" href="#go-语言支持函数式编程">Go 语言支持函数式编程</a></h3>
<p>函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用。</p>
<p>函数类型的零值是 nil。调用值为 nil 的函数值会引起 panic 错误.</p>
<p>函数值之间是不可比较的，也不能用函数值作为 map 的 key。</p>
<p>支持将一个函数作为另一个函数的参数,也支持将一个函数作为另一个函数的返回值.</p>
<p>strings.Map <strong>对字符串中的每个字符调用</strong> add1 函数，并将每个 add1 函数的返回值组成一个新的字符串返回给调用者。</p>
<pre><code class="language-go">func add1(r rune) rune { return r + 1 }
fmt.Println(strings.Map(add1, &quot;HAL-9000&quot;)) // &quot;IBM.:111&quot;

fmt.Println(strings.Map(func(r rune) rune { return r + 1 }, &quot;HAL-9000&quot;)) // 使用匿名函数的方式
</code></pre>
<h3 id="闭包-closure"><a class="header" href="#闭包-closure">闭包 (closure)</a></h3>
<p>一个外层函数中,有内层函数,该内层函数中,会操作外层函数的 <strong>局部变量</strong> (外层函数中的参数，或者外层函数中直接定义的变量),并且该外层函数的返回值就是这个内层函数.</p>
<p>这个<strong>内层函数和外层函数的局部变量</strong>，统称为<strong>闭包结构</strong>。</p>
<p>局部变量的 <strong>生命周期</strong> 会发生改变，正常的局部变量随着函数调用而创建，随着函数的结束而销毁</p>
<p>但是闭包结构中的外层函数的局部变量并不会随着外层函数的结束销毁，因为内层函数还要<strong>继续使用</strong>。</p>
<hr />
<p><img src="http://oss.whaleluo.top/blog/Golang/func-43.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/func-42.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/func-44.png-picsmall" alt="" /></p>
<h2 id="捕获迭代变量"><a class="header" href="#捕获迭代变量">捕获迭代变量</a></h2>
<blockquote>
<p><strong>将介绍 Go 词法作用域的一个陷阱。请务必仔细的阅读，弄清楚发生问题的原因。即使是经验丰富的程序员也会在这个问题上犯错误。</strong></p>
</blockquote>
<p>循环中的 d 函数值记录的是 <strong>循环变量的内存地址</strong> ，不是循环变量某一时刻的值。for 循环结束时，d 指向循环最后一次迭代的值。而需要一个局部变量 dir 将 d <strong>进行深拷贝保存作为循环变量的副本</strong>。</p>
<pre><code class="language-go">var rmdirs []func()
for _, d := range tempDirs() {
   dir := d // NOTE: necessary!
   os.MkdirAll(dir, 0755) // creates parent directories too
   rmdirs = append(rmdirs, func() {
      os.RemoveAll(dir)
   })
}
// ...do some work…
for _, rmdir := range rmdirs {
 rmdir() // clean up
}
</code></pre>
<p>这个问题不仅存在基于 range 的循环，go 语句或者 defer 语句会经常遇到此类问题。这不是 go 或 defer 本身导致的，而是因为它们都会 <strong>等待循环结束后</strong> ，再执行函数值。</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Golang 学习笔记——JSON的解析
date: 2022-12-17 12:17:48
categories: Golang
updated: 2022-12-17 12:17:48
tags: [Golang, Coding]
description:
thumbnail: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall
banner_img: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall</p>
<hr />
<h1 id="golang-解析-json-数据"><a class="header" href="#golang-解析-json-数据">Golang 解析 JSON 数据</a></h1>
<p><code>JSON</code> 是对 <code>JavaScript</code> 中各种类型的值——字符串、数字、布尔值和对象—— Unicode 本文编码。它可以用有效可读的方式表示基础数据类型和数组、slice、结构体和 map 等聚合数据类型。</p>
<h2 id="json-序列化编码"><a class="header" href="#json-序列化编码">JSON 序列化（编码）</a></h2>
<p>将结构体 slice 转为 JSON 的过程叫编组（marshaling）。编组通过调用 <code>json.Marshal</code> 函数完成：</p>
<pre><code class="language-go">type Movie struct {
    Title string
    Year int `json:&quot;released&quot;`
    Color bool `json:&quot;color,omitempty&quot;`
    Actors []string
}
data, err := json.Marshal(movies)
if err != nil {
    log.Fatalf(&quot;JSON marshaling failed: %s&quot;, err)
}
fmt.Printf(&quot;%s\n&quot;, data)
// [{&quot;Title&quot;:&quot;Casablanca&quot;,&quot;released&quot;:1942,&quot;Actors&quot;:[&quot;Humphrey Bogart&quot;,&quot;Ingrid Bergman&quot;]}]
</code></pre>
<blockquote>
<p>在结构体声明中，Year 和 Color 成员后面的字符串面值是结构体成员 Tag</p>
</blockquote>
<p><code>json.MarshalIndent</code> 函数将产生整齐缩进的输出。该函数有两个额外的字符串参数用于表示每一行输出的前缀和每一个层级的缩进：</p>
<pre><code class="language-go">data, err := json.MarshalIndent(movies, &quot;&quot;, &quot; &quot;)
if err != nil {
    log.Fatalf(&quot;JSON marshaling failed: %s&quot;, err)
}
fmt.Printf(&quot;%s\n&quot;, data)
</code></pre>
<h2 id="json-反序列化解码"><a class="header" href="#json-反序列化解码">JSON 反序列化（解码）</a></h2>
<p>编码的逆操作是解码，对应将 JSON 数据解码为 Go 语言的数据结构，Go 语言中一般叫 unmarshaling，通过 <code>json.Unmarshal</code> 函数完成。</p>
<pre><code class="language-go">func Unmarshal(data []byte, v interface{}) error{...}
</code></pre>
<p>结构体中只有 Title 成员。通过定义合适的 Go 语言数据结构，我们可以 <strong>选择性</strong> 地解码 JSON 中感兴趣的成员。</p>
<pre><code class="language-go">var titles []struct{ Title string }  // 匿名结构体
if err := json.Unmarshal(data, &amp;titles); err != nil {
    log.Fatalf(&quot;JSON unmarshaling failed: %s&quot;, err)
}
fmt.Println(titles) // &quot;[{Casablanca} {Cool Hand Luke} {Bullitt}]&quot;
</code></pre>
<p>将定义的结构体传入函数时，需要 <strong>传入结构体的地址（指针）</strong> 。因为在函数内部默认是深拷贝数据，写入结构体时需要映射原有的结构体。</p>
<h2 id="struct-结构体成员-tag"><a class="header" href="#struct-结构体成员-tag">Struct 结构体成员 Tag</a></h2>
<p>Go 语言默认将结构体的成员名字作为 JSON 的对象（通过 reflect 反射技术）。<strong>只有导出的结构体成员才会被编码，要用大写字母开头的成员名称。</strong></p>
<p>有些 JSON 成员名字和 Go 结构体成员名字并不相同，因此需要 Go 语言结构体成员 Tag 来指定对应的 JSON 名字。</p>
<pre><code class="language-go">Year int `json:&quot;released&quot;`
Color bool `json:&quot;color,omitempty&quot;`
// 定义的 tag 解析到（序列化） JSON
// {released:&quot;Year_value&quot;,color:&quot;Color_value&quot;}
</code></pre>
<p>Color 成员的 Tag 还带了一个额外的 omitempty 选项，表示当 Go 语言结构体成员为空或零值时不生成 JSON 对象。</p>
<h2 id="流式-json-解码器"><a class="header" href="#流式-json-解码器">流式 JSON 解码器</a></h2>
<p>基于流式的解码器 <code>json.Decoder</code>，它可以从一个输入流解码 JSON 数据，尽管这不是必须的。如您所料，还有一个针对输出流的 <code>json.Encoder</code> 编码对象。</p>
<p><img src="http://oss.whaleluo.top//blog/Golang/json-1.png-picsmall" alt="流式 JSON 解码器" /></p>
<pre><code class="language-go">if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil {
    resp.Body.Close()
    return nil, err
}
</code></pre>
<p>调用 Decode 方法传入结构体指针来填充变量。</p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Golang 学习笔记——Go环境搭建
date: 2022-04-19 18:30:48
updated: 2022-04-19 18:30:48
categories: Golang
tags: [Golang, Coding]
description:
thumbnail: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall
banner_img: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall</p>
<hr />
<h1 id="go-环境搭建"><a class="header" href="#go-环境搭建">Go 环境搭建</a></h1>
<ol>
<li>安装完 Go,添加 <code>bin</code> 目录到环境变量.</li>
<li>CMD 配置 go 环境</li>
</ol>
<pre><code class="language-shell">go version # 输出版本
go env # 显示 go 环境变量
set GO111MODULE=on  # 包管理
set GOPROXY=http://goproxy.cn  # 设置镜像源
</code></pre>
<ol>
<li>Vscode 安装 <code>Go</code> <code>Run code</code> 插件</li>
</ol>
<h2 id="hello-go"><a class="header" href="#hello-go">Hello Go</a></h2>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
 fmt.Println(&quot;hello go&quot;)
}

# 运行
go run helloworld.go
# 编译为可执行文件
go build hellworld.go
# 下载包
go mod init go_pro  # 新建依赖
go get XXX 或 go get install 源码包
go list # 列出包
go tool # 输出go工具
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Golang 学习笔记——struct结构体
date: 2022-12-30 18:30:48
categories: Golang
updated: 2022-12-30 18:30:48
tags: [Golang, Coding]
description:
thumbnail: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall
banner_img: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall</p>
<hr />
<h1 id="go-结构体"><a class="header" href="#go-结构体">Go 结构体</a></h1>
<p><strong>结构体:</strong> 是由一系列具有 <strong>相同类型</strong> 或 <strong>不同类型</strong> 的数据构成的数据 <strong>集合</strong>。</p>
<p>结构体成员是由 <strong>一系列的成员变量</strong> 构成，这些 <strong>成员变量</strong> 也被称为 <strong>字段</strong>。</p>
<p><strong>字段</strong> 大写就表明该字段是可导出字段，可以被外部包导入。</p>
<p>如果考虑效率的话，较大的结构体通常会用 <strong>指针的方式</strong> 传入和返回。如果要在函数内部修改结构体成员的话，用 <strong>指针传入</strong> 是必须的；因为在 Go 语言中，所有的函数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量。</p>
<h2 id="结构体定义"><a class="header" href="#结构体定义">结构体定义</a></h2>
<p>定义结构体</p>
<p><img src="http://oss.whaleluo.top/blog/Golang/struct-1.png-picsmall" alt="定义结构体" /></p>
<p>初始化结构体:</p>
<p><img src="http://oss.whaleluo.top/blog/Golang/struct-2.png-picsmall" alt="初始化结构体1" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/struct-3.png-picsmall" alt="初始化结构体2" /></p>
<p>如果不赋值,默认存储的是类型的零值.</p>
<h2 id="结构体指针"><a class="header" href="#结构体指针">结构体指针</a></h2>
<p><img src="http://oss.whaleluo.top/blog/Golang/struct-4.png-picsmall" alt="结构体指针" /></p>
<h3 id="定义结构体指针"><a class="header" href="#定义结构体指针">定义结构体指针</a></h3>
<p><img src="http://oss.whaleluo.top/blog/Golang/struct-5.png-picsmall" alt="定义结构体指针1" /></p>
<p><code>*</code> 获取指针指向的原始数据.<br />
<code>&amp;</code> 获取一个对象的地址.</p>
<p><img src="http://oss.whaleluo.top/blog/Golang/struct-6.png-picsmall" alt="定义结构体指针2" /></p>
<h3 id="通过-new-构建结构体指针"><a class="header" href="#通过-new-构建结构体指针">通过 <code>new</code> 构建结构体指针</a></h3>
<blockquote>
<p>内置函数 <code>new()</code> 专门用于创建某种类型的指针.</p>
</blockquote>
<p><img src="http://oss.whaleluo.top/blog/Golang/struct-7.png-picsmall" alt="New函数构建结构体指针1" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/struct-8.png-picsmall" alt="New函数构建结构体指针2" /></p>
<p>通过, <code>new()</code> 函数 (不为 <code>nil</code>,空指针) 指向了 <strong>新分配的类型的内存空间</strong> ,里面存该类型的零值.</p>
<p><img src="http://oss.whaleluo.top/blog/Golang/struct-10.png-picsmall" alt="New函数详解" /></p>
<h2 id="结构体的匿名"><a class="header" href="#结构体的匿名">结构体的匿名</a></h2>
<h3 id="匿名结构体"><a class="header" href="#匿名结构体">匿名结构体</a></h3>
<p><img src="http://oss.whaleluo.top/blog/Golang/struct-11.png-picsmall" alt="" /></p>
<h3 id="结构体的匿名字段"><a class="header" href="#结构体的匿名字段">结构体的匿名字段</a></h3>
<p><img src="http://oss.whaleluo.top/blog/Golang/struct-12.png-picsmall" alt="" /></p>
<h2 id="结构体嵌套"><a class="header" href="#结构体嵌套">结构体嵌套</a></h2>
<p>一个结构体可能包含一个字段，而这个字段是一个结构体。这个结构体被称为嵌套结构。</p>
<p><img src="http://oss.whaleluo.top/blog/Golang/struct-13.png-picsmall" alt="结构体嵌套1" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/struct-14.png-picsmall" alt="结构体嵌套2" /></p>
<h3 id="将结构体的地址作为字段数值-引用传递-建议使用"><a class="header" href="#将结构体的地址作为字段数值-引用传递-建议使用">将结构体的地址作为字段数值 (引用传递) [建议使用]</a></h3>
<p>在嵌套结构体中,结构体字段是结构体指针.使用了引用传递.</p>
<p><img src="http://oss.whaleluo.top/blog/Golang/struct-16.png-picsmall" alt="嵌套结构体指针1" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/struct-15.png-picsmall" alt="嵌套结构体指针2" /></p>
<h2 id="golang-中的-opp面向对象"><a class="header" href="#golang-中的-opp面向对象">Golang 中的 OPP(面向对象)</a></h2>
<p><code>Golang</code> 并不是面向对象的语言….但可以模拟继承性.</p>
<p>通过结构体嵌套模拟面向对象的继承性.</p>
<p><img src="http://oss.whaleluo.top/blog/Golang/struct-17.png-picsmall" alt="OPP原理分析" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/struct-18.png-picsmall" alt="Go结构体嵌套" /></p>
<h3 id="通过结构体的嵌套模拟继承性"><a class="header" href="#通过结构体的嵌套模拟继承性">通过结构体的嵌套模拟继承性</a></h3>
<p><img src="http://oss.whaleluo.top/blog/Golang/struct-19.png-picsmall" alt="模拟继承性" /></p>
<p><code>s3.Person.name-&gt;s3.name</code></p>
<p>Student 结构体将 Person 结构体作为一个匿名字段了.</p>
<p>那么 Person 中的字段，对于 Student 来讲，就是提升字段.</p>
<p>Student 对象直接访问 Person 中的字段</p>
<p><img src="http://oss.whaleluo.top/blog/Golang/struct-20.png-picsmall" alt="子结构体直接访问父结构体属性" /></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Golang 学习笔记——Pointer指针
date: 2022-05-2 18:17:48
updated: 2022-05-2 18:17:48
categories: Golang
tags: [Golang, Coding]
description:
thumbnail: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall
banner_img: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall</p>
<hr />
<h1 id="go-指针"><a class="header" href="#go-指针">Go 指针</a></h1>
<p><code>*指针类型</code>: 取指针地址对应的真实值. | 定义一个指针 <code>*p1</code><br />
<code>&amp;值</code>: 取值的内存地址.<br />
<code>var p *int</code>: 定义一个指向 int 类型的指针</p>
<h2 id="指针初步"><a class="header" href="#指针初步">指针初步</a></h2>
<p><img src="http://oss.whaleluo.top/blog/Golang/pointer-1.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/pointer-2.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/pointer-3.png-picsmall" alt="" /></p>
<hr />
<p><img src="http://oss.whaleluo.top/blog/Golang/pointer-7.png-picsmall" alt="" /></p>
<h2 id="数组指针"><a class="header" href="#数组指针">数组指针</a></h2>
<p>&quot; 首先是一个指针,一个数组的地址.&quot;<br />
<img src="http://oss.whaleluo.top/blog/Golang/pointer-4.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/pointer-5.png-picsmall" alt="" /></p>
<h2 id="指针数组"><a class="header" href="#指针数组">指针数组</a></h2>
<p>&quot; 首先是一个数组,存储的数据类型是指针.&quot;<br />
<img src="http://oss.whaleluo.top/blog/Golang/pointer-6.png-picsmall" alt="" /></p>
<h2 id="函数指针"><a class="header" href="#函数指针">函数指针</a></h2>
<p>&quot; 一个指针,指向一个函数的指针.&quot;<br />
<img src="http://oss.whaleluo.top/blog/Golang/pointer-8.png-picsmall" alt="" /></p>
<h2 id="指针函数"><a class="header" href="#指针函数">指针函数</a></h2>
<p>&quot; 一个函数,该函数的返回值是一个指针.&quot;<br />
<img src="http://oss.whaleluo.top/blog/Golang/pointer-9.png-picsmall" alt="" /></p>
<h3 id="普通函数的执行分析"><a class="header" href="#普通函数的执行分析">普通函数的执行分析</a></h3>
<p><img src="http://oss.whaleluo.top/blog/Golang/pointer-10.png-picsmall" alt="" /></p>
<h3 id="指针函数的执行分析"><a class="header" href="#指针函数的执行分析">指针函数的执行分析</a></h3>
<p><img src="http://oss.whaleluo.top/blog/Golang/pointer-11.png-picsmall" alt="" /></p>
<h2 id="指针作为参数"><a class="header" href="#指针作为参数">指针作为参数</a></h2>
<h3 id="普通函数的值传递"><a class="header" href="#普通函数的值传递">普通函数的值传递</a></h3>
<p><img src="http://oss.whaleluo.top/blog/Golang/pointer-12.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/pointer-13.png-picsmall" alt="" /></p>
<h3 id="指针作为参数时的引用传递"><a class="header" href="#指针作为参数时的引用传递">指针作为参数时的引用传递</a></h3>
<p><img src="http://oss.whaleluo.top/blog/Golang/pointer-14.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/pointer-15.png-picsmall" alt="" /></p>
<h3 id="应用-3"><a class="header" href="#应用-3">应用</a></h3>
<p><img src="http://oss.whaleluo.top/blog/Golang/pointer-16.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/pointer-17.png-picsmall" alt="" /></p>
<blockquote>
<p>切片本来就是 <strong>引用类型</strong>,<strong>不必传递指针.</strong></p>
</blockquote>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;Hello, World!&quot;)
 s1 := []int{1,2,3,4}
 fmt.Printf(&quot;main()数值:%v 地址:%p\n&quot;, s1, s1)
 test(s1)
 fmt.Printf(&quot;执行完函数main()数值:%v 地址:%p\n&quot;, s1, s1)
}

func test(slice []int) {
 fmt.Printf(&quot;进入test()数值:%v 地址:%p\n&quot;, slice, slice)
 // 在函数内修改切片
 slice[0] = 10
 fmt.Printf(&quot;离开test()数值:%v 地址:%p\n&quot;, slice, slice)
}
</code></pre>
<p>output:<br />
切片地址都是一样的,切片发生的是引用传递</p>
<pre><code class="language-txt">Hello, World!
main()数值:[1 2 3 4] 地址:0xc000098000
进入test()数值:[1 2 3 4] 地址:0xc000098000
离开test()数值:[10 2 3 4] 地址:0xc000098000
执行完函数main()数值:[10 2 3 4] 地址:0xc000098000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Golang 学习笔记——Go error 错误
date: 2022-05-22 0:44:48
updated: 2022-05-22 0:44:48
categories: Golang
tags: [Golang, Coding]
description:
thumbnail: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall
banner_img: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall</p>
<hr />
<h1 id="go-error-错误"><a class="header" href="#go-error-错误">Go Error 错误</a></h1>
<p>Go 使用控制流机制（如 if 和 return）处理异常，这使得编码人员能更多的关注错误处理。</p>
<p>在实际工程项目中，我们希望通过程序的错误信息快速定位问题，但是又不喜欢错误处理代码写的冗余而又啰嗦。Go 语言没有提供像 <code>Java</code>、<code>c#</code> 语言中的 <code>try..catch</code> 异常处理方式，而是通过 <strong>函数返回值</strong> 逐层往上抛。这种设计，鼓励工程师在代码中 <strong>显式的检查错误</strong> ，而非忽略错误，好处就是避免漏掉本应处理的错误。但是带来一个弊端，让 <strong>代码啰嗦</strong> 。</p>
<h2 id="错误异常"><a class="header" href="#错误异常">错误&amp;异常</a></h2>
<ul>
<li><strong>错误</strong>: 指的是<strong>可能出现问题</strong>的地方出现了问题。比如打开一个文件时失败，这种情况在人们的意料之中。</li>
<li><strong>异常</strong>: 指的是不<strong>应该出现问题</strong>的地方出现了问题。比如引用了空指针，这种情况<strong>在人们的意料之外</strong>。可见，错误是业务过程的一部分，而异常不是。</li>
</ul>
<p>Go 中的错误 <strong>也是一种类型</strong> 。错误用内置的 <code>error</code> 类型表示。就像其他类型的，如 <code>int</code>,<code>floate64</code>.错误值可以<strong>存储在变量中，从函数中返回</strong>，等等。</p>
<h2 id="处理-os-模块异常"><a class="header" href="#处理-os-模块异常">处理 OS 模块异常</a></h2>
<p>如果一个函数或方法返回一个错误，那么按照惯例，它必须是 <strong>函数返回的最后一个值</strong>。因此，<code>Open</code> 函数返回的值是最后一个值。<br />
处理错误的惯用方法是将 <strong>返回的错误与 ​</strong>​**<code>nil</code><strong>​</strong>​ 进行比较** 。<code>nil</code> 值表示没有发生错误，而 <code>非nil</code> 值表示出现错误。在我们的例子中，我们检查错误是否为 <code>nil</code>。如果它不是 <code>nil</code> ,我们只需 <strong>打印错误并从主函数返回</strong>。</p>
<pre><code class="language-go">package main
import (
&quot;os&quot;
&quot;fmt&quot;
&quot;log&quot;
)

func main() {
    //打开一个文件
    f,err := os.Open(name:&quot;test.txt&quot;)
    if err != nil{
        //log.Fatal(err)  //调用日志模块捕捉异常,会自动 return
        fmt.Println(err) //异常信息:open test.txt:no such file directoryreturn
        return
    }

  fmt.Println(f.Name(),&quot;打开文件成功。。&quot;)

}
</code></pre>
<h2 id="错误类型表示"><a class="header" href="#错误类型表示">错误类型表示</a></h2>
<p>G0 语言通过 <strong>内置的错误接口</strong> 提供了非常简单的错误处理机制。<br />
<strong>定义错误类型</strong> 的构建。错误是一个带有以下定义的接口类型:</p>
<pre><code class="language-go">type error interface {
    Error() string
}
</code></pre>
<blockquote>
<p><code>fmt.Println(err)</code> 会在内部执行 Error() 方法,返回错误的字符串信息.</p>
</blockquote>
<p><img src="http://oss.whaleluo.top/blog/Golang/error-1.png-picsmall" alt="" /></p>
<h3 id="从错误中获取更多信息"><a class="header" href="#从错误中获取更多信息">从错误中获取更多信息</a></h3>
<blockquote>
<p><strong>断言判断接口底层类型</strong> ,通过 <code>struct</code> 结构体的属性和方法获取更多的信息</p>
</blockquote>
<h4 id="使用-struct-类型属性"><a class="header" href="#使用-struct-类型属性">使用 <code>struct</code> 类型属性</a></h4>
<p><img src="http://oss.whaleluo.top/blog/Golang/error-4.png-picsmall" alt="" /></p>
<h4 id="调用-struct-类型的方法"><a class="header" href="#调用-struct-类型的方法">调用 <code>struct</code> 类型的方法</a></h4>
<p><img src="http://oss.whaleluo.top/blog/Golang/error-5.png-picsmall" alt="" /></p>
<h4 id="直接比较"><a class="header" href="#直接比较">直接比较</a></h4>
<p>直接与错误类型的变量进行比较.</p>
<pre><code class="language-go">package main
import (
  &quot;path/filepath&quot;
  &quot;fmt&quot;
)
func main() {
  files,err := filepath.Glob(&quot;[&quot;)
  // 直接判断错误的类型
  if err != nil &amp; err == filepath.ErrBadPattern{
    fmt.Println(err)//syntax error in patternreturn
    return
  }
  fmt.Println(a:&quot;files:&quot;,files)
}
</code></pre>
<h2 id="自定义-error"><a class="header" href="#自定义-error">自定义 Error</a></h2>
<h3 id="1-通过-errorsnew描述"><a class="header" href="#1-通过-errorsnew描述">1. 通过 <code>errors.New(&quot;描述&quot;)</code></a></h3>
<p><img src="http://oss.whaleluo.top/blog/Golang/error-2.png-picsmall" alt="" /></p>
<h3 id="2-通过-fmterrorf"><a class="header" href="#2-通过-fmterrorf">2. 通过 <code>fmt.Errorf()</code></a></h3>
<p>也可以使用 <code>fmt.Errorf()</code> 输出的错误更详细,支持格式化输出错误.</p>
<p><img src="http://oss.whaleluo.top/blog/Golang/error-3.png-picsmall" alt="" /></p>
<h3 id="3-定义错误"><a class="header" href="#3-定义错误">3. 定义错误</a></h3>
<pre><code class="language-go">package main

import (
 &quot;fmt&quot;
 &quot;math&quot;
)

func main() {
 r := -2.0
 area, err := circleArea(r)
 if err != nil {
  // 打印 err 就是调用错误struct的Error()方法,返回字符串
        //错误值其实就是错误对象调用Error方法执行的结果
  // fmt.Println(err)
  // 通过接口断言判断错误类型,获取错误类型中的属性,运行错误类型中的方法
  if err, ok := err.(*areaError); ok {
   fmt.Println(err)
   fmt.Printf(&quot;半径是:%.2f\n&quot;, err.radius)
  } else {
   fmt.Println(err)
   fmt.Printf(&quot;其他错误类型:%s,%T\n&quot;, err, err)
  }
  return
 }
 fmt.Println(&quot;圆的的面积是:&quot;, area)
}

//1. 定义一个struct,表示错误类型
type areaError struct {
 msg    string // 错误的描述
 radius float64  //半径
}

//2. 实现error接口，就是实现Error方法，该方法返回字符串
// 需要传入结构体指针
func (e *areaError) Error() string {
 // 返回一个格式化的字符串
 return fmt.Sprintf(&quot;error: 半径,%.2f,%s&quot;, e.radius, e.msg)
}

// 3.定义一个求圆面积的函数,注意，第二个返回值是go内置的 error接口实现类型
func circleArea(r float64) (float64, error) {
 if r &lt; 0 {
  // 用 &amp; 返回error对象指针
  return 0, &amp;areaError{&quot;半径是非法的&quot;, r}
 }
 return math.Pi * r * r, nil
}
</code></pre>
<h2 id="尽量不要-_-忽略错误"><a class="header" href="#尽量不要-_-忽略错误">尽量不要 <code>_</code> 忽略错误</a></h2>
<p><strong>永远不要忽略一个错误。忽视错误会招致麻烦。</strong></p>
<pre><code class="language-go">files,_ := filepath.Glob(&quot;[&quot;)
</code></pre>
<h2 id="panic-和-recover"><a class="header" href="#panic-和-recover"><code>panic()</code> 和 <code>recover()</code></a></h2>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
 // 处理 panic 的 defer 匿名函数
 defer func() {
  // reconver() 接受 panic() 的信息
  if msg := recover(); msg != nil {
   fmt.Println(msg, &quot;程序恢复啦。。&quot;)
  }
 }()
 // funB的panic传递到此处,引起panic时需要执行完所有defer主函数才会报错
 funB()

}

func myprint(s string) {
 fmt.Println(s)
}

func funB() { //外围函数
 // 匿名函数,处理pianic的recover()也可以放在main函数中
 // defer是逆序执行的
 defer func() {
  // reconver() 接受 panic() 的信息
  if msg := recover(); msg != nil {
   fmt.Println(msg, &quot;程序恢复啦。。&quot;)
  }
 }()

 fmt.Println(&quot;我是函数funB()..&quot;)
 defer myprint(&quot;defer funB()...1.....&quot;)
 for i := 1; i &lt;= 10; i++ {
  fmt.Println(&quot;i:&quot;, i)
  if i == 5 {
   //让程序中断
   panic(&quot;funB函数,恐慌了&quot;)
  }
 }
 //当外围函数的代码中发生了运行恐慌，只有其中所有的已经`defer`的函数全部都执行完毕后，
 //该运行恐慌才会真正被扩展至调用处。
 defer myprint(&quot;defer funB():2.....&quot;)
}
</code></pre>
<h2 id="什么时候使用错误异常"><a class="header" href="#什么时候使用错误异常">什么时候使用错误/异常</a></h2>
<p>什么情况下用错误表达，什么情况下用异常表达，就得有一套规则，否则很容易出现一切皆错误或一切皆异常的情况。<br />
以下给出异常处理的作用域（场景）:</p>
<blockquote>
<ol>
<li>空指针引用</li>
<li>下标越界</li>
<li>除数为 0</li>
<li>不应该出现的分支，比如 default</li>
<li>输入不应该引起函数错误</li>
</ol>
</blockquote>
<p>其他场景我们使用错误处理，这使得我们的函数接口很精炼。对于异常，我们可以选择在一个合适的上游去 <code>recover()</code> .并打印堆栈信息，使得部署后的程序不会终止。</p>
<h2 id="偶然异常重试机制"><a class="header" href="#偶然异常重试机制">偶然异常重试机制</a></h2>
<p>如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。在重试时，我们需要限制重试的 <strong>时间间隔</strong> 或重试的 <strong>次数</strong>，防止无限制的重试。</p>
<pre><code class="language-go">func WaitForServer(url string) error {
  const timeout = 1 * time.Minute
  deadline := time.Now().Add(timeout)  //设定异常最大重试时间

  for tries := 0; time.Now().Before(deadline); tries++ {
    _, err := http.Head(url)
    if err == nil {
      return nil // success
    }
    log.Printf(&quot;server not responding (%s);retrying…&quot;, err)
    time.Sleep(time.Second &lt;&lt; uint(tries)) // exponential back-off
  }

  return fmt.Errorf(&quot;server %s failed to respond after %s&quot;, url, timeout)
}
</code></pre>
<h2 id="无法运行的重大错误"><a class="header" href="#无法运行的重大错误">无法运行的重大错误</a></h2>
<p>如果错误发生后，程序无法继续运行，我们就可以采用第三种策略：输出错误信息并结束程序。需要注意的是，这种策略只应在 main 中执行。对库函数而言，<strong>应仅向上传播错误</strong>，除非该错误意味着程序内部包含不一致性，即遇到了 bug，才能在库函数中结束程序。</p>
<p>log 包中的所有函数会为没有换行符的字符串增加换行符。</p>
<pre><code class="language-go">// (In function main.)
if err := WaitForServer(url); err != nil {
  // fmt.Fprintf(os.Stderr, &quot;Site is down: %v\n&quot;, err)
  log.Fatalf(&quot;Site is down: %v\n&quot;, err)
  os.Exit(1)
}
</code></pre>
<p>只需要输出错误信息就足够了，不需要中断程序的运行。</p>
<pre><code class="language-go">log.Printf(&quot;ping failed: %v; networking disabled&quot;,err)
</code></pre>
<p>或者向标准错误流输出错误信息。</p>
<pre><code class="language-go">fmt.Fprintf(os.Stderr, &quot;ping failed: %v; networking disabled\n&quot;, err)
</code></pre>
<h2 id="文件结尾错误eof"><a class="header" href="#文件结尾错误eof">文件结尾错误（EOF）</a></h2>
<p>读取文件时，调用者会重复的读取固定大小的数据直到文件结束，io 包保证任何由文件结束引起的读取失败都返回同一个错误—— <code>io.EOF</code>.</p>
<pre><code class="language-go">// 标准输入中读取字符，以及判断文件结束。
in := bufio.NewReader(os.Stdin)
for {
  r, _, err := in.ReadRune()
  if err == io.EOF {
    break // finished reading
  }
  if err != nil {
    return fmt.Errorf(&quot;read failed:%v&quot;, err)
  }
  // ...use r…
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Golang 学习笔记——Go 项目结构和 Go mod
date: 2022-05-28 21:54:48
updated: 2022-05-28 21:54:48
categories: Golang
tags: [Golang, Coding]
description:
thumbnail: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall
banner_img: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall</p>
<hr />
<h1 id="go-项目结构和-go-mod-最佳实践"><a class="header" href="#go-项目结构和-go-mod-最佳实践">Go 项目结构和 Go mod 最佳实践</a></h1>
<h2 id="项目目录"><a class="header" href="#项目目录">项目目录</a></h2>
<pre><code class="language-other">|-- go-test
  |--bin 存放编译后的可执行文件
  |--pkg 存放编译后的包文件
  |--src 存放项目源文件
</code></pre>
<p><strong>一般地 bin 和 pkg 目录可以不创建，go 命令会自动创建（爽否？），只需要创建 src 目录放代码即可。</strong></p>
<h2 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h2>
<ul>
<li>GOROOT：安装的 <code>go</code> 路径</li>
<li>GOPATA：项目的根目录 <code>go-test</code><br />
细心的人注意到，这里有一个 <code>Project GOPATH</code>，还有一个 <code>Global GOPATH</code>，把你的项目配置在 <code>Project GOPATH</code> 里，每个项目都不一样，创建另一个项目时这个路径要配置成新项目的。</li>
</ul>
<p><code>Global GOPATH</code> 可以弄一个公共项目，以后就把第三方的包直接装到这里，就可以<strong>自动</strong>在你的项目里引用了。</p>
<p><img src="http://oss.whaleluo.top/blog/img/Golang-project-gomod-1.png-picsmall" alt="GOPATH 设置" /></p>
<h2 id="引用包"><a class="header" href="#引用包">引用包</a></h2>
<pre><code class="language-tree">|____src
| |____main
| | |____calc
| | | |____add.go
| | |____main.go
</code></pre>
<p><img src="http://oss.whaleluo.top/blog/img/Golang-project-gomod-2.png-picsmall" alt="引用自己写的包" /></p>
<h3 id="注意点-1"><a class="header" href="#注意点-1">注意点</a></h3>
<ol>
<li><code>add.go</code> 中的 Add 函数名首字母必须大写，只有大写的才是 Public 权限，外面的包才能访问，否则只能自己文件夹下代码才能访问。</li>
<li><code>add.go</code> 的改名为 addyyy.go 也可以，查找 add 包的时候，<strong>并不会根据 add.go 这个文件名来查找</strong>。而是根据文件夹名来查找，一个文件夹下的所有文件都属于同一个包。所以函数变量自然不能重复。</li>
<li><code>main</code> 中调用 <code>add.Add(1,2)</code> 时，add 是包， 必须跟 <code>add.go</code> 中的 <code>package</code> 处的包名一致，否则报错。</li>
<li>import 后， 根据 <code>GOROOT</code> 和 <code>GOPATH</code> 查找对应的包，<strong>src 这个目录名可不是能随便取的</strong>。</li>
</ol>
<h3 id="引用第三方项目"><a class="header" href="#引用第三方项目">引用第三方项目</a></h3>
<p><img src="http://oss.whaleluo.top/blog/img/Golang-project-gomod-3.png-picsmall" alt="引入第三方项目" /></p>
<h2 id="go-mod-包管理工具"><a class="header" href="#go-mod-包管理工具">Go mod 包管理工具</a></h2>
<h3 id="why"><a class="header" href="#why">Why?</a></h3>
<ol>
<li>使用 go mod 仓库中可以不用再上传依赖代码包，防止代码仓库过大浪费以及多个项目同时用包时的浪费。</li>
<li>可以管理引用包的版本，这一点是 gopath（src 模式）和 <code>vendor</code> 做不到的</li>
<li>如果依赖 <code>GOPATH</code> 不同项目如果引用了同一个软件包的不同版本，就会造成编译麻烦</li>
</ol>
<p><strong>gopath 是 go 之前的默认策略，每个项目在运行时都要严格放在</strong>​**<code>src</code><strong>​</strong>目录下，而 go mod 不用。**</p>
<p><code>Go mod</code> 的优点：</p>
<ul>
<li>自动下载依赖包。</li>
<li>项目不必放在 <code>$GOPATH/src</code> 内了。</li>
<li>项目内会生成一个 <code>go.mod</code> 文件，列出包依赖。</li>
<li>第三方包会准确的指定版本号。</li>
<li>对于已经转移的包，可以用 <code>replace</code> 申明替换，不需要改代码。</li>
<li>在使用模块的时候，GOPATH 是无意义的，不过它还是会把下载的依赖储存在 <code>$GOPATH/pkg/mod</code> 中，也会把 go install 的结果放在 <code>$GOPATH/bin</code> 中。</li>
</ul>
<h3 id="配置-1"><a class="header" href="#配置-1">配置</a></h3>
<pre><code class="language-shell"># 设置 gopath
go env -w GOPATH=/usr/gopath
# 设置环境变量
go env -w GO111MODULE=&quot;on&quot;
# china proxy
go env -w GOPROXY=https://goproxy.io
# 初始化 mod 项目
# 自动生成了 `go.mod` 和 `go.sum` 文件。
go mod init [packetName]
# add missing and remove unused modules
# 自动增加包和删除无用包到 GOPATH 目录下
go mod tidy
</code></pre>
<p>注意：只要在本地 <strong>设置一个公用 gopath 目录</strong> 就可以了，<strong>全部的包都会下载到那里</strong>，其他本地项目用到时就可以共享了，并且会自动根据 <code>go.mod</code> 选择对应版本的第三方库。</p>
<h3 id="gomod"><a class="header" href="#gomod">go.mod</a></h3>
<pre><code class="language-go">// 模块的引用路径
module github.com/BingmingWong/module-test 

// 项目使用的 go 版本
go 1.14

// 项目所需的直接依赖包及其版本
require (
example.com/apple v0.1.2
)

// 忽略指定版本的依赖包
exclude example.com/banana v1.2.4

// 由于在国内访问golang.org/x的各个包都需要翻墙，你可以在go.mod中使用replace替换成github上对应的库。
replace（
golang.org/x/text v0.3.0 = &gt; github.com/golang/text v0.3.0
)
</code></pre>
<h3 id="gosum"><a class="header" href="#gosum">go.sum</a></h3>
<p>每一行都是由 <strong>模块路径</strong>，<strong>模块版本</strong>，<strong>哈希检验值</strong> 组成，其中哈希检验值是用来保证当前缓存的模块不会被篡改。</p>
<pre><code class="language-shell">&lt;module&gt; &lt;version&gt;/go.mod &lt;hash&gt;
</code></pre>
<h3 id="go-mod-命令使用"><a class="header" href="#go-mod-命令使用">Go mod 命令使用</a></h3>
<p><code>go mod init</code>：初始化 go mod， 生成 go.mod 文件，后可接参数指定 module 名，上面已经演示过。<br />
<code>go mod download</code>：手动触发下载依赖包到本地 cache（默认为 $GOPATH/pkg/mod 目录）<br />
<code>go mod graph</code>：打印项目的模块依赖结构<br />
<code>go mod tidy</code> ：添加缺少的包，且删除无用的包<br />
<code>go mod verify</code> ：校验模块是否被篡改过<br />
<code>go mod why</code>：查看为什么需要依赖<br />
<code>go mod vendor</code> ：导出项目所有依赖到 vendor 下</p>
<p>写入 go.mod 有两种方法：</p>
<ul>
<li>你只要在项目中有 import 并使用或者使用下划线强制占用，然后 go build 时 go module 就会自动下载并添加。</li>
<li><code>go mod tidy</code></li>
</ul>
<p>参考：<a href="https://golang-minibear2333.github.io/1.base/1-3-go-mod/#134-go-mod-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8">Go mod用法</a></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Golang 学习笔记——变量
date: 2022-04-25 18:30:48
updated: 2022-04-25 18:30:48
categories: Golang
tags: [Golang, Coding]
description:
thumbnail: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall
banner_img: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall</p>
<hr />
<h1 id="golang-变量"><a class="header" href="#golang-变量">Golang 变量</a></h1>
<p>变量是计算机语言中能储存计算结果或能表示值的抽象概念。不同的变量保存的数据类型可能会不一样。</p>
<h2 id="声明变量"><a class="header" href="#声明变量">声明变量</a></h2>
<p>G0 语言中的<strong>变量需要声明后才能使用</strong>，同一作用域内不支持重复声明。并且 G0 语言的<strong>变量声明后必须使用</strong>。</p>
<h2 id="声明变量的语法"><a class="header" href="#声明变量的语法">声明变量的语法</a></h2>
<pre><code class="language-go">var identifier type
/* 
var:声明变量关键字
1dent1fier:变量名称
type:变量类型
*/
</code></pre>
<p>e.g.</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
 var name string
 fmt.Printf(&quot;name: %v\n&quot;, name)
}
</code></pre>
<h2 id="批量声明"><a class="header" href="#批量声明">批量声明</a></h2>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
 // 批量声明
 var (
  name string
  age  int
  b    bool
 )

 name = &quot;hyy&quot;
 age = 14
 b = false

 fmt.Printf(&quot;name: %v\n&quot;, name)
 fmt.Printf(&quot;age: %v\n&quot;, age)
 fmt.Printf(&quot;b: %v\n&quot;, b)
}
</code></pre>
<h2 id="变量的初始化"><a class="header" href="#变量的初始化">变量的初始化</a></h2>
<p>G0 语言在声明变量的时候，会<strong>自动对变量对应的内存区域进行初始化操作</strong>。每个变量会被初始化成其类型的<strong>默认值</strong>，例如：整型和浮点型变量的默认值为 <code>0</code>。字符串变量的默认值为空字符串 <code>&quot;&quot;</code>。布尔型变量默认为 <code>false</code>,切片、函数、指针变量的默认为 <code>nil</code>.</p>
<h3 id="变量初始化语法"><a class="header" href="#变量初始化语法">变量初始化语法</a></h3>
<pre><code class="language-go">var 变量名 类型 = 表达式
</code></pre>
<p>e.g.</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
 //变量初始化 赋初始值
 var title string = &quot;lovehyy&quot;
 var site string = &quot;http://baidu.com&quot;
 var agge int = 30
}
</code></pre>
<h3 id="类型推断"><a class="header" href="#类型推断">类型推断</a></h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
 // 类型推断
 var name = &quot;hyy&quot;
 var age = 20
 var b = true
 fmt.Printf(&quot;name: %v\n&quot;, name)
 fmt.Printf(&quot;age: %v\n&quot;, age)
 fmt.Printf(&quot;b: %v\n&quot;, b)
}
</code></pre>
<h3 id="批量初始化"><a class="header" href="#批量初始化">批量初始化</a></h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
 //批量初始化
 var name, age, b = &quot;tom&quot;, 20, true
 fmt.Printf(&quot;name: %v\n&quot;, name)
 fmt.Printf(&quot;age: %v\n&quot;, age)
 fmt.Printf(&quot;b: %v\n&quot;, b)
}
</code></pre>
<h2 id="短变量声明"><a class="header" href="#短变量声明">短变量声明</a></h2>
<p>在函数内部，可以使用 <code>:=</code> 运算符对变量进行声明和初始化。</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

// name := &quot;hyy&quot; 不能用于函数外部

func main() {
 //短变量声明 := 不能用于函数外部
 name := &quot;hyy&quot;
 age := 51
 b := true
 fmt.Printf(&quot;name: %v\n&quot;, name)
 fmt.Printf(&quot;age: %v\n&quot;, age)
 fmt.Printf(&quot;b: %v\n&quot;, b)
}
</code></pre>
<blockquote>
<p><strong>注意：这种方法只适合在函数内部，函数外面不能使用。</strong></p>
</blockquote>
<h2 id="匿名变量"><a class="header" href="#匿名变量">匿名变量</a></h2>
<p>如果我们接收到<strong>多个变量</strong>，有一些<strong>变量使用不到</strong>，可以<strong>使用下划线 _ 表示变量名称</strong>，这种变量叫做匿名变量。e.g.</p>
<ol>
<li>函数定义</li>
</ol>
<pre><code class="language-go">func getNameAndAge() (name string, age int) {
 return &quot;hyy&quot;, 30
}
</code></pre>
<p>等价于：</p>
<pre><code class="language-go">func getNameAndAge() (string, int) {
 return &quot;hyy&quot;, 30
}
</code></pre>
<ol>
<li>接收函数返回值</li>
</ol>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func getNameAndAge() (string, int) {
 return &quot;hyy&quot;, 30
}
func main() {
 // 调用函数,匿名变量,丢弃age
 name, _ := getNameAndAge()
 fmt.Printf(&quot;name: %v\n&quot;, name)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Golang 学习笔记——map映射数据结构
date: 2022-05-1 18:30:48
categories: Golang
updated: 2022-05-1 18:30:48
tags: [Golang, Coding]
description:
thumbnail: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall
banner_img: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall</p>
<hr />
<h1 id="go-map-数据类型"><a class="header" href="#go-map-数据类型">Go Map 数据类型</a></h1>
<p>map: 映射/哈希表，是一种转码用于存储键值对的结合，属于引用类型。</p>
<h2 id="定义-map-对象"><a class="header" href="#定义-map-对象">定义 Map 对象</a></h2>
<p><img src="http://oss.whaleluo.top/blog/Golang/map-1.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/20220424210757.png-picsmall" alt="" /></p>
<h2 id="存储值获取值"><a class="header" href="#存储值获取值">存储值获取值</a></h2>
<p><img src="http://oss.whaleluo.top/blog/Golang/map-3.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/map-4.png-picsmall" alt="" /></p>
<h2 id="map-的遍历"><a class="header" href="#map-的遍历">Map 的遍历</a></h2>
<blockquote>
<p>使用 <code>sort</code> 包进行排序.</p>
</blockquote>
<p><img src="http://oss.whaleluo.top/blog/Golang/map-6.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/map-7.png-picsmall" alt="" /></p>
<h2 id="map-和-slice-结合使用"><a class="header" href="#map-和-slice-结合使用">Map 和 Slice 结合使用</a></h2>
<p><img src="http://oss.whaleluo.top/blog/Golang/map-8.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/map-9.png-picsmall" alt="" /></p>
<p>原理图:<br />
<img src="http://oss.whaleluo.top/blog/Golang/mapWithSlice.png-picsmall" alt="" /></p>
<h2 id="map-是引用类型"><a class="header" href="#map-是引用类型">Map 是引用类型</a></h2>
<p><img src="http://oss.whaleluo.top/blog/Golang/map-12.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/map-10.png-picsmall" alt="" /><br />
<img src="http://oss.whaleluo.top/blog/Golang/map-11.png-picsmall" alt="" /></p>
<h2 id="总结-2"><a class="header" href="#总结-2">总结</a></h2>
<p><img src="http://oss.whaleluo.top/blog/Golang/map-5.png-picsmall" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Golang 学习笔记——const常量
date: 2022-04-22 18:30:48
categories: Golang
updated: 2022-04-22 18:30:48
tags: [Golang, Coding]
description:</p>
<p>thumbnail: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall
banner_img: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall</p>
<hr />
<h1 id="go-语言常量"><a class="header" href="#go-语言常量">Go 语言常量</a></h1>
<p>常量，就是在程序<strong>编译阶段</strong>就确定下来的值，而程序在<strong>运行时则无法改变该值</strong>。在 G0 程序中，常量可以是数值类型 (包括整型、浮点型和复数类型)、布尔类型、字符串类型等。</p>
<h2 id="定义常量的语法"><a class="header" href="#定义常量的语法">定义常量的语法</a></h2>
<p>定义一个常量使用 const 关键字，语法格式如下：</p>
<pre><code class="language-go">const constantName [type] = value
/* 
const:定义常量关键字
constantName:常量名称
type:常量类型
value:常量的值 
*/
</code></pre>
<h3 id="示例-2"><a class="header" href="#示例-2">示例</a></h3>
<pre><code class="language-go">package main

func main() {
 const PI float64 = 3.14
 const PI2 = 3.1415 //可以省略类型
    // PI2 = 3.15 不能重新对他赋值
 // 批量声明
 const (
  width  = 100
  height = 200
 )

 //多重赋值
 const i, j = 1, 2
 const a, b, c = 1, 2, &quot;foo&quot;
}
</code></pre>
<h2 id="iota-关键字"><a class="header" href="#iota-关键字"><code>iota</code> 关键字</a></h2>
<p><code>iota</code> 比较特殊，可以被认为是一个可被编译器修改的常量，它默认开始值是 <code>0</code>，每调用一次加 <code>1</code>。遇到 <code>const</code> 关键字时被重置为 <code>0</code>。e.g.</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
 // iota 关键字
 const (
  a1 = iota //0
  a2 = iota //类似 i++
  a3 = iota
 )

 fmt.Printf(&quot;a1: %v\n&quot;, a1) //0
 fmt.Printf(&quot;a2: %v\n&quot;, a2) //1
 fmt.Printf(&quot;a3: %v\n&quot;, a3) //2
}
</code></pre>
<h3 id="使用-_-跳过某些值"><a class="header" href="#使用-_-跳过某些值">使用 <code>_</code> 跳过某些值</a></h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
 // iota 关键字
    // 使用 `_` 跳过某些值
 const (
  a1 = iota //0
  _         //1
  a3 = iota //2
 )

 fmt.Printf(&quot;a1: %v\n&quot;, a1) //0
 // fmt.Printf(&quot;a2: %v\n&quot;, a2) //1
 fmt.Printf(&quot;a3: %v\n&quot;, a3) //2
}
</code></pre>
<h3 id="iota-声明中间插队"><a class="header" href="#iota-声明中间插队"><code>iota</code> 声明中间插队</a></h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
 // iota 关键字
    // `iota` 声明中间插队
 const (
  a1 = iota //0
  a2 = 100         //100
  a3 = iota //1
 )

 fmt.Printf(&quot;a1: %v\n&quot;, a1) //0
 fmt.Printf(&quot;a2: %v\n&quot;, a2) //100
 fmt.Printf(&quot;a3: %v\n&quot;, a3) //1
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Golang 学习笔记——Type关键字
date: 2022-05-21 8:30:48
updated: 2022-05-21 8:30:48
categories: Golang
tags: [Golang, Coding]
description:
thumbnail: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall
banner_img: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall</p>
<hr />
<h1 id="go-type-关键字"><a class="header" href="#go-type-关键字">Go Type 关键字</a></h1>
<p><code>type</code> 是 Go 语法里的重要而且常用的关键字,<code>type</code> 绝不只是对应于 C/C+ 中的 <code>typedef</code>.搞清楚 <code>type</code> 的使用,就容易理解 Go 语言中的核心概念 <code>struct</code>、<code>interface</code>、<code>函数</code> 等的使用。</p>
<h2 id="通过-type-定义新类型"><a class="header" href="#通过-type-定义新类型">通过 Type 定义新类型</a></h2>
<pre><code class="language-go">type 类型名 Typde
type myint int  //定义了一共 `myint` 类型它是 `int` 类型
</code></pre>
<p><img src="http://oss.whaleluo.top/blog/Golang/type-2.png-picsmall" alt="" /></p>
<h2 id="通过-type-定义函数类型"><a class="header" href="#通过-type-定义函数类型">通过 Type 定义函数类型</a></h2>
<p>Go 语言支持 <strong>高阶函数</strong> ,所以可以把函数作为一个函数的返回值,或者一个函数的参数.<br />
<img src="http://oss.whaleluo.top/blog/Golang/type-1.png-picsmall" alt="" /></p>
<h2 id="类型别名"><a class="header" href="#类型别名">类型别名</a></h2>
<p>常常用于代码迁移,适配新旧代码.</p>
<pre><code class="language-go">//不是重新定义新的数据类型，只是给int起别名，和int可以通用,%T打印的类型还是int
type myint = int 
</code></pre>
<h2 id="非本地类型不能定义方法"><a class="header" href="#非本地类型不能定义方法">非本地类型不能定义方法</a></h2>
<p><code>time</code> 包下的 <code>Duration</code> 类型不是 <code>main</code> 包下的类型,所以不是本地类型.不能定义方法.</p>
<p><img src="http://oss.whaleluo.top/blog/Golang/type-3.png-picsmall" alt="" /></p>
<h2 id="在结构体成员嵌入时使用别名"><a class="header" href="#在结构体成员嵌入时使用别名">在结构体成员嵌入时使用别名</a></h2>
<p><img src="http://oss.whaleluo.top/blog/Golang/type-4.png-picsmall" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Golang 学习笔记——Goruntine并发协程
date: 2022-12-30 11:11:48
updated: 2022-12-30 11:11:48
categories: Golang
tags: [Golang, Coding]
description:
thumbnail: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall
banner_img: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall</p>
<hr />
<h1 id="golang-学习笔记goruntine-并发协程"><a class="header" href="#golang-学习笔记goruntine-并发协程">Golang 学习笔记——Goruntine 并发协程</a></h1>
<p>并发程序指同时进行多个任务的程序，Web 服务器会一次处理成千上万的请求。</p>
<p>Go 语言中的并发程序可以用两种手段来实现。本节讲解 goroutine 和 channel，其支持“<strong>顺序通信进程</strong>”（communicating sequential processes）或被简称为 CSP。</p>
<p>在这种编程模型中值会在不同的运行实例（goroutine）中传递，通过 channel 进行不同 Goroutine 间的数据共享。</p>
<p>可以简单地把 goroutine 类比作一个线程，当一个程序启动时，其主函数即在一个单独的 goroutine 中运行，我们叫它 main goroutine（主线程）。</p>
<p>新的 Goroutine 会用 go 语句来创建。在语法上，go 语句是<strong>一个普通的函数或方法调用前加上关键字 go</strong>。go 语句会使其语句中的函数在一个新创建的 goroutine 中运行。<strong>而 go 语句本身会迅速地完成</strong>。（非阻塞）</p>
<pre><code class="language-go">f()    // call f(); wait for it to return
go f() // create a new goroutine that calls f(); don't wait
</code></pre>
<p><strong>主函数返回</strong> 时，<strong>所有的 goroutine 都会被直接打断，程序退出</strong>。除了从主函数退出或者直接终止程序之外，没有其它的编程方法能够让一个 goroutine 来打断另一个的执行。</p>
<p>Go 显示一个加载动画函数，可以放在 <code>go spinner(100 * time.Millisecond)</code> 执行</p>
<pre><code class="language-go">func spinner(delay time.Duration) {
    for {
        for _, r := range `-\|/` {
            fmt.Printf(&quot;\r%c&quot;, r)
            time.Sleep(delay)
        }
    }
}
</code></pre>
<p><code>go</code> 后跟的 <strong>函数的参数</strong> 会在 go 语句自身执行时被求值，就是在 main goroutine 中被求值。</p>
<h2 id="channels"><a class="header" href="#channels">Channels</a></h2>
<p>Channel 是 goruntine 间的通信管道，每个 channel 都有一个可发送数据的类型。</p>
<p>可以使用 make 函数，创建一个 channel：</p>
<pre><code class="language-go">ch := make(chan int) // ch has type 'chan int'
// 返回一个 chan int 类型的
</code></pre>
<p>和 map 类似，channel 也对应一个 make 创建的 <strong>底层数据结构的引用</strong>。当我们复制一个 channel 或用于函数参数传递时，我们只是拷贝了一个 channel 引用，channel 的零值也是 nil。</p>
<h3 id="发送接收"><a class="header" href="#发送接收">发送&amp;接收</a></h3>
<pre><code class="language-go">ch &lt;- x  // 将 x 发送到 ch
x = &lt;-ch // 从 ch 取出一个值给 x
&lt;-ch     // 从 ch 取出一个值但是 Drop 掉
</code></pre>
<p>Channel 支持关闭 close 操作，关闭 channel 后对通道的任何发送操作都会 panic 但进行接收操作仍然可以接收到之前一键成功发送的数据，如果 channel 中已经没有数据了就返回一个零值数据。</p>
<pre><code class="language-go">chlose(ch)
</code></pre>
<h3 id="不带缓存的-channels"><a class="header" href="#不带缓存的-channels">不带缓存的 Channels</a></h3>
<p>一个无缓冲的 channel 的发送操作会导致发送者的 goroutine 堵塞，直到另一个 goruntine 在相同的 channel 上执行接收操作，堵塞才会解除，反之亦然。</p>
<p>当发送的值通过 channel 成功传输之后，两个 goroutine 才可以继续执行后面的语句。</p>
<pre><code class="language-go">func main() {
    // 建立 tcp 服务器
    conn, err := net.Dial(&quot;tcp&quot;, &quot;localhost:8000&quot;)
    if err != nil {
        log.Fatal(err)
    }
    // 信息事件
    done := make(chan int)
    go func() {
        io.Copy(os.Stdout, conn)
        log.Println(&quot;done&quot;)
        done &lt;- 1 // 发送一个 goruntine 已经完成的信息
    }()
    mustCopy(conn, os.Stdin)
    conn.Close()
    &lt;-done // 等待后台 goruntine 完成
}
</code></pre>
<h3 id="检查-channels-是否关闭"><a class="header" href="#检查-channels-是否关闭">检查 Channels 是否关闭</a></h3>
<p>接收 channels 的语句可以写成：第二个结果的一个 bool ，true 表示成功从 channels 接收到值，false 表示 channels 已经被关闭并且里面没有值可接收。</p>
<pre><code class="language-go">// 方法一
x, ok := &lt;-channel
if !ok {
    // channel error do something....
}
// 方法二
if x, ok := &lt;-channel;ok{
    // channel succues do something.....
}
</code></pre>
<p>因为这种处理模式很常见，Go 语言的 range 循环可以直接在 channels 上面迭代，它依次从 channel 接收数据，当 channel 被关闭并且没有值可接收时跳出循环。</p>
<pre><code class="language-go">for x := range channel {
    // rev channel to x and do something....
}
// 当 channel 被关闭时会主动跳出循环
close(channel)
</code></pre>
<p>不管一个 channel 是否被关闭，当它没有被引用时将会被 Go 语言的垃圾自动回收器回收。所以不需要显性的 <code>close(channel)</code></p>
<p>不要将关闭一个打开文件的操作和关闭一个 channel 操作混淆。<strong>对于每个打开的文件，都需要在不使用的时候调用对应的 Close 方法来关闭文件。</strong></p>
<h3 id="单方向的-channel"><a class="header" href="#单方向的-channel">单方向的 Channel</a></h3>
<p>当一个 channel <strong>作为一个函数参数</strong> 时，它一般总是被专门用于只发送或者只接收。这是为了防止滥用，可以定义只接收或只发送的 channel ，这种限制将在编译期检测。</p>
<pre><code class="language-go">chan &lt;- int // 只发送 int 的 channel
&lt;-chan int // 只接收 int 的 channel
</code></pre>
<p>close channel 只用于停止向 channel 发送新数据。但不能阻止接收 channel 的数据。所以 <strong>对一个只接受的 channel 调用 close 将引起编译错误</strong>。</p>
<pre><code class="language-go">channel := make(chan int)
// 单方向的 channel 通常用于函数参数
func inChannel(in &lt;-chan int) // 仅接收
func outChannel(out chan&lt;-int) // 仅发送
</code></pre>
<p>调用 <code>inChannel</code> 时 in 的类型将隐式地从 chan int 转换成 chan&lt;- int。任何双向 channel 向单向 channel 变量的赋值操作都将导致该隐式转换。但是反之不能将单向 channel 赋值给 双向 channel</p>
<h3 id="带缓存-buffer-的-channels"><a class="header" href="#带缓存-buffer-的-channels">带缓存 (<em>buffer</em>) 的 Channels</a></h3>
<pre><code class="language-go">ch = make(chan string, 3)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Golang 学习笔记——数据类型
date: 2022-04-21 18:30:48
categories: Golang
updated: 2022-04-21 18:30:48
tags: [Golang, Coding]
description:
thumbnail: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall
banner_img: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall</p>
<hr />
<h1 id="go-数据类型"><a class="header" href="#go-数据类型">Go 数据类型</a></h1>
<p>在 G0 编程语言中，数据类型用于 <strong>声明函数和变量</strong>，数据类型的出现是为了把数据分成所需<strong>内存大小</strong>不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以<strong>充分利用内存</strong>。</p>
<p>G0 语言按类别有以下几种数据类型：</p>
<ol>
<li>布尔型<br />
布尔型的值只可以是常量 <code>true</code> 或者 <code>false</code> 。一个简单的例子：<br />
<code>var b bool=true</code></li>
<li>数字类型<br />
整型 int 和浮点型 float32、float64,Go 语言支持整型和浮点型数字，并且支持复数，具中位的运算采用补码。</li>
<li>字符串类型<br />
字符串就是一串因定长度的字符连接起来的字符序列。G0 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本，</li>
<li>派生类型
<ol>
<li>指针类型 (Pointer)</li>
<li>数组类型 (c)</li>
<li>结构体类型 (struct)</li>
<li>Channel: 类型</li>
<li>函数类型</li>
<li>切片类型</li>
<li>接口类型</li>
<li>Map 类型</li>
</ol>
</li>
</ol>
<h2 id="格式化输出类型"><a class="header" href="#格式化输出类型">格式化输出类型</a></h2>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
 var name string = &quot;tom&quot;
 age := 20
 b := true
 // 格式化输出
 // %T 类型
 fmt.Printf(&quot;%T\n&quot;, name)
 fmt.Printf(&quot;%T\n&quot;, age)
 fmt.Printf(&quot;%T\n&quot;, b)
}
</code></pre>
<p>输出:</p>
<pre><code class="language-shell">string
int
bool
</code></pre>
<h2 id="布尔类型"><a class="header" href="#布尔类型">布尔类型</a></h2>
<p>go 语言中的布尔类型有两个常量值：<code>true</code> 和 <code>false</code>。布尔类型经常用在<strong>条件判断</strong>语句，或者<strong>循环语句</strong>。也可以用在<strong>逻辑表达式</strong>中。</p>
<h2 id="数值类型"><a class="header" href="#数值类型">数值类型</a></h2>
<h2 id="派生类型"><a class="header" href="#派生类型">派生类型</a></h2>
<h3 id="指针类型"><a class="header" href="#指针类型">指针类型</a></h3>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
    //指针类型
    a := 100
    p := &amp;a //取a的内存地址 p是指针类型
    fmt.Printf(&quot;%T&quot;, p) //*int
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Golang 学习笔记——标识符-关键字-命名规则
date: 2022-04-20 18:30:48
updated: 2022-04-20 18:30:48
categories: Golang
tags: [Golang, Coding]
description:
thumbnail: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall
banner_img: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall</p>
<hr />
<h1 id="go-标识符---关键字---命名规则"><a class="header" href="#go-标识符---关键字---命名规则">Go 标识符 - 关键字 - 命名规则</a></h1>
<h2 id="标识符"><a class="header" href="#标识符">标识符</a></h2>
<p>标识符的英文是 identifier,通俗的讲，就是给变量、常量、函数、方法、结构体、数组、切片、接口起名<br />
字。</p>
<p>标识符的组成:</p>
<ol>
<li>标识符由数字、字母和下划线 (_) 组成。<code>123abc_</code></li>
<li>只能以字母和下划线 (_) 开头。<code>abc123_sysVar123abc</code></li>
<li>标识符区分大小写。<code>nameName NAMET</code></li>
</ol>
<h2 id="标识符的命名"><a class="header" href="#标识符的命名">标识符的命名</a></h2>
<pre><code class="language-go">package main

func main() {
 // 正确的标识符
 var name string
 var age int
 var _sys int

 /*
  错误的标识符
  var 1name string
  var &amp;age int
 */

}
</code></pre>
<h2 id="go-关键字"><a class="header" href="#go-关键字">Go 关键字</a></h2>
<h2 id="go-语言命名规范"><a class="header" href="#go-语言命名规范">Go 语言命名规范</a></h2>
<p>Go 是一门区分大小写的语言。</p>
<p>命名规则涉及变量、常量、全局函数、结构、接口、方法等的命名。G0 语言从语法层面进行了以下限定：任何需要对外暴露的名字必须以大写字母开头，不需要对外暴露的则应该以小写字母开头。</p>
<h2 id="go-命名的可见性"><a class="header" href="#go-命名的可见性">Go 命名的可见性</a></h2>
<p>当命名 (包括常量、变量、类型、函数名、结构字段等等) 以一个大写字母开头，如：GetUserName,那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为 <strong>导出</strong>(像面向对象语言中的 public)；命名如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的 (像面向对象语言中的 private)</p>
<h3 id="包名称"><a class="header" href="#包名称">包名称</a></h3>
<p>保持 package 的名字和目录保持一致，尽量采取有意义的包名，简短，有意义，尽量和标准库不要冲突。包名应该为小写单词，不要使用下划线或者混合大小写。</p>
<pre><code class="language-go">package dao  
package service
</code></pre>
<h3 id="文件命名"><a class="header" href="#文件命名">文件命名</a></h3>
<p>尽量采取有意义的文件名，简短，有意义，应该为小写单词，使用下划线分隔各个单词。<code>customer_dao.go</code></p>
<h3 id="结构体命名"><a class="header" href="#结构体命名">结构体命名</a></h3>
<p>采用驼峰命名法，首字母根据访问控制大写或者小写 <code>struct</code> 申明和初始化格式采用多行，例如下面：</p>
<pre><code class="language-go">type CustomerOrder struct{
Name string
Address string
}
order:=CustomerOrder{&quot;tom&quot;,&quot;北京海淀&quot;}
</code></pre>
<h3 id="接口命名"><a class="header" href="#接口命名">接口命名</a></h3>
<p>命名规则基本和上面的结构体类型<br />
单个函数的结构名以“er”作为后缀，例如 Reader,Writer.</p>
<pre><code class="language-go">type Reader interface{
Read(p [] byte)(n int,err error)
}
</code></pre>
<h3 id="变量命名"><a class="header" href="#变量命名">变量命名</a></h3>
<p>和结构体类似，变量名称一般遵循驼峰法，首字母根据访问控制原则大写或者小写，但遇到特有名词时，需要遵循以下规则：<br />
如果变量为私有，且特有名词为首个单词，则使用小写，如 appService 若变量类型为 bool 类型，则名称应以 Has,Is,Can 或 Allow 开头</p>
<pre><code class="language-go">var isExist bool
var hasConflict bool
var canManage bool
var allowGitHook bool
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Golang 学习笔记——目录
date: 2023-02-03 8:30:48
updated: 2023-02-03 8:30:48
categories: Golang
tags: [Golang, Coding]
sticky: 1
description: 博客中 Golang 学习内容相关笔记的索引
thumbnail: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall
banner_img: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall</p>
<hr />
<h1 id="catalogue-golang-学习笔记目录"><a class="header" href="#catalogue-golang-学习笔记目录">【Catalogue】 Golang 学习笔记目录</a></h1>
<h2 id="前言-2"><a class="header" href="#前言-2">前言</a></h2>
<p>本博客用了大量的章节记录了我学习 Golang 语言的笔记，参考书是 <strong>《Go 语言圣经》</strong> ，非常详细实用的一本书。强烈安利！部分截图来自 Bilibili 一些教程的视频。算是自己学习 Golang 的一个速查册。</p>
<h2 id="catalogue"><a class="header" href="#catalogue">Catalogue</a></h2>
<ol>
<li><a href="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang//golang/golang-envbuild-note">Go 环境搭建</a></li>
<li><a href="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang//golang/golang-id-note">Go 标识符-关键字-命名规则</a></li>
<li><a href="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang//golang/golang-datatype-note">Go 数据类型</a></li>
<li><a href="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang//golang/golang-variable-note">Go 变量</a></li>
<li><a href="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang//golang/golang-const-note">const 常量</a></li>
<li><a href="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang//golang/golang-type-keyword-note">Type 关键字</a></li>
<li><a href="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang//golang/golang-pointer-note">Go 指针</a></li>
<li><a href="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang//golang/golang-map-note">复合数据结构-map 映射数据结构</a></li>
<li><a href="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang//golang/golang-struct-note">复合数据结构-struct 结构体</a></li>
<li><a href="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang//golang/golang-function-note">Go 函数</a></li>
<li><a href="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang//golang/golang-method-note">Go 方法</a></li>
<li><a href="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang//golang/golang-interface-note">Go 接口</a></li>
<li><a href="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang//golang/golang-package-note">Go 自定义包</a></li>
<li><a href="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang//golang/golang-error-note">Go 异常处理</a></li>
<li><a href="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang//golang/golang-project-and-gomod-note">Go go mod 包管理工具和项目结构</a></li>
<li><a href="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang//golang/golang-JSON-note">Go Json</a></li>
<li><a href="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang//golang/golang-HTML-note">Go HTML</a></li>
<li><a href="%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/_posts/Golang//golang/golang-goruntine-note">Go goruntine 协程并发</a> &lt;-- Current</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: Golang 学习笔记——文本和HTML模板
date: 2022-12-17 15:17:48
categories: Golang
updated: 2022-12-17 15:17:48
tags: [Golang, Coding]
description:
thumbnail: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall
banner_img: http://oss.whaleluo.top/blog/Golang/icon_img.png-picsmall</p>
<hr />
<h1 id="go-文本和-html-模板"><a class="header" href="#go-文本和-html-模板">GO 文本和 HTML 模板</a></h1>
<p>前面的例子，只是最简单的格式化，使用 Printf 是完全足够的。但是有时候会需要复杂的打印格式，这时候一般需要将格式化代码分离出来以便更安全地修改。这写功能是由 text/template 和 html/template 等模板包提供的，它们提供了一个将变量值填充到一个文本或 HTML 格式的模板的机制。</p>
<p>一个模板是一个字符串或一个文件，里面包含了一个或多个由双花括号包含的 <code>{{action}}</code> 对象。</p>
<p>通过 `` 定义字符串字面量。</p>
<pre><code class="language-go">const templ = `{{.TotalCount}} issues:{{range .Items}}----------------------------------------Number: {{.Number}}User: {{.User.Login}}Title: {{.Title | printf &quot;%.64s&quot;}}Age: {{.CreatedAt | daysAgo}} days{{end}}`
</code></pre>
<p>对于每一个 action，都有一个当前值的概念，对应点操作符，写作“.”,模板中 <code>{{.TotalCount}}</code> 对应 action 将展开为结构体中 TotalCount 成员</p>
<p>模板中 <code>{{range .Items}}</code> 和 <code>{{end}}</code> 对应一个循环 action ，因此它们直接的内容可能会被展开多次，循环每次迭代的当前值对应当前的 Items 元素的值。</p>
<p>在一个 action 中， | 操作符表示将前一个表达式的结果作为后一个函数的输入，类似于 UNIX 中管道的概念。</p>
<h2 id="生成模板"><a class="header" href="#生成模板">生成模板</a></h2>
<pre><code class="language-go">// 先解析模板
report, err := template.New(&quot;report&quot;).Funcs(template.FuncMap{&quot;daysAgo&quot;: daysAgo}).Parse(templ)
if err != nil {
    log.Fatal(err)
}
// 在执行模板，使用 result 作为输入源，os.Stdout 作为输出源。
if err := report.Execute(os.Stdout, result); err != nil {
    log.Fatal(err)
}
</code></pre>
<p><strong>方法调用链</strong> ：template.New 先创建并返回一个模板；Funcs 方法将 daysAgo 等自定义函数注册到模板中，并返回模板；最后调用 Parse 函数分析模板。</p>
<pre><code class="language-go">func Must(t *Template, err error) *Template {....}
var report = template.Must(report)
</code></pre>
<p>因为模板通常在编译时就测试好了，如果模板解析失败将是一个致命的错误。template.Must 辅助函数可以简化这个致命错误的处理：它接受一个模板和一个 error 类型的参数，检测 error 是否为 nil（如果不是 nil 则发出 panic 异常），然后返回传入的模板。</p>
<h2 id="htmltemplate"><a class="header" href="#htmltemplate">html/template</a></h2>
<p>使用和 text/template 包相同的 API 和模板语言，但是增加了一个将 <strong>字符串自动转义特性</strong>，这可以避免输入字符串和 HTML JavaScript、CSS 或 URL 语法产生冲突的问题。</p>
<pre><code class="language-go">func main() {
    const templ = `&lt;p&gt;A: {{.A}}&lt;/p&gt;&lt;p&gt;B: {{.B}}&lt;/p&gt;`
    t := template.Must(template.New(&quot;escape&quot;).Parse(templ))
    var data struct {
        A string // untrusted plain text
        B template.HTML // trusted HTML
    }
    data.A = &quot;&lt;b&gt;Hello!&lt;/b&gt;&quot;
    data.B = &quot;&lt;b&gt;Hello!&lt;/b&gt;&quot;
    if err := t.Execute(os.Stdout, data); err != nil {
        log.Fatal(err)
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript"><a class="header" href="#javascript">JavaScript</a></h1>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>title: JavaScript 快速上手指南
date: 2023-08-19 16:21:59
updated: 2023-08-19 16:21:59
categories: JavaScript
tags: [JavaScript, Guide]
description: 
thumbnail: 
banner_img:</h2>
<h1 id="javascript-快速上手指南"><a class="header" href="#javascript-快速上手指南">JavaScript 快速上手指南</a></h1>
<p>主要把 JavaScript 的基础语法过一遍，为接下来学习 Vue framework 打基础，因为是自用复习，所以会比较简洁。会加入一些 ES6 的语法特性，并参考以下文档： </p>
<p><a href="https://www.runoob.com/js/js-intro.html">JavaScript 简介 | 菜鸟教程</a></p>
<h2 id="语法syntax"><a class="header" href="#语法syntax">语法（Syntax）</a></h2>
<ol>
<li>每行末尾加分号 <code>;</code></li>
<li>注释：</li>
</ol>
<pre><code class="language-javascript">/* 下面的这些代码会输出 一个标题和一个段落 并将代表主页的开始 */
// 输出标题：
</code></pre>
<h2 id="变量数据类型data-types"><a class="header" href="#变量数据类型data-types">变量&amp;数据类型（Data types）</a></h2>
<p>值类型：<br />
1. Number 数字<br />
2. String 字符串<br />
3. Boolean 布尔<br />
4. Null 空<br />
5. Undefine 未定义<br />
6. Symbol 符号</p>
<p>引用数据类型：<br />
1. Object 对象 --&gt; RegExp 正则、Date 日期；<br />
2. Function 函数<br />
3. Array 数组</p>
<pre><code class="language-javascript">var length = 16;                                  // Number 通过数字字面量赋值  
var points = x * 10;                              // Number 通过表达式字面量赋值  
var lastName = &quot;Johnson&quot;;                         // String 通过字符串字面量赋值  
var cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];              // Array  通过数组字面量赋值  
var person = {firstName:&quot;John&quot;, lastName:&quot;Doe&quot;};  // Object 通过对象字面量赋值

// 声明变量类型
var carname=new String;  
var x=      new Number;  
var y=      new Boolean;  
var cars=   new Array;  
var person= new Object;

// 类型转换
String(obj);
Number(obj);

// 设置 null 来清空变量
cars=null;  
person=null;

// 你可以使用 typeof 操作符来检测变量的数据类型。
typeof &quot;John&quot;                // 返回 string  
typeof 3.14                  // 返回 number  
typeof false                 // 返回 boolean  
typeof [1,2,3,4]             // 返回 object  
typeof {name:'John', age:34} // 返回 object

// null 和 undefined 的值相等，但类型不等：
typeof undefined             // undefined  
typeof null                  // object  
// === ：值和类型进行比较；==：只比较值
null === undefined           // false  
null == undefined            // true
</code></pre>
<h3 id="string-字符串"><a class="header" href="#string-字符串">String 字符串</a></h3>
<p>字符串可以是对象</p>
<pre><code class="language-javascript">var x = &quot;John&quot;;
var y = new String(&quot;John&quot;);
typeof x //  返回 String
typeof y // 返回 Object
</code></pre>
<p>属性：</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>constructor</td><td>返回创建字符串属性的函数</td></tr>
<tr><td>length</td><td>返回字符串的长度</td></tr>
<tr><td>prototype</td><td>允许您向对象添加属性和方法</td></tr>
</tbody></table>
</div>
<p>方法：</p>
<p>…</p>
<p>模板字符串：</p>
<pre><code class="language-javascript">const name = 'Runoob';
const age = 30;
const message = `My name is ${name} and I'm ${age} years old.`;
</code></pre>
<h3 id="array-数组"><a class="header" href="#array-数组">Array 数组</a></h3>
<p>相当于 Python List 列表</p>
<pre><code class="language-javascript">var cars=new Array();  
cars[0]=&quot;Saab&quot;;  
cars[1]=&quot;Volvo&quot;;  
cars[2]=&quot;BMW&quot;;
// 或者  (condensed array)
var cars=new Array(&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;);
// 或者  (literal array)
var cars=[&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;];
</code></pre>
<h3 id="object-对象"><a class="header" href="#object-对象">Object 对象</a></h3>
<p>相当于 Python 字典 Dict，JavaScript 对象是变量的容器。</p>
<pre><code class="language-javascript">var person={firstname:&quot;John&quot;, lastname:&quot;Doe&quot;, id:5566};

var person={  
firstname : &quot;John&quot;,  
lastname  : &quot;Doe&quot;,  
id        :  5566,
// 可以添加对象方法
methodName : function() {
    // 代码 
    }
};

// 访问对象方法
person.methodName();

// 对象寻址
name=person.lastname;  
name=person[&quot;lastname&quot;];
</code></pre>
<h3 id="变量"><a class="header" href="#变量">变量</a></h3>
<ul>
<li>变量必须以字母开头</li>
<li>变量也能以 $ 和 _ 符号开头（不过我们不推荐这么做）</li>
<li>变量名称对大小写敏感（y 和 Y 是不同的变量）</li>
</ul>
<pre><code class="language-javascript">var lastname=&quot;Doe&quot;, age=30, job=&quot;carpenter&quot;;
var lastname=&quot;Doe&quot;,  
age=30,  
job=&quot;carpenter&quot;;
var carname; // undefined
</code></pre>
<p><strong>使用 let 和 const (ES6)</strong></p>
<p>let 声明的变量只在 let 命令所在的<strong>代码块</strong>内有效。<br />
const 声明一个只读的常量，一旦声明，常量的值就不能改变。<br />
在 ES6 之前，JavaScript 只有两种作用域： <strong>全局变量</strong> 与 <strong>函数内的局部变量</strong>。</p>
<pre><code class="language-javascript">var carName = &quot;Volvo&quot;; // 使用 var 定义为全局变量
const pi = 3.14; // 只读变量
function myFunction() { 
	// 使用 let 定义的变量只能在 Block Scope 块级作用域 {}
	let carName = &quot;inner&quot;;
	console.log(carName); 
}
</code></pre>
<h3 id="生命周期"><a class="header" href="#生命周期">生命周期</a></h3>
<p>JavaScript 变量的生命期从它们被声明的时间开始。<br />
局部变量会在函数运行以后被删除。<br />
全局变量会在页面关闭后被删除。</p>
<h3 id="block-scope-块级作用域"><a class="header" href="#block-scope-块级作用域">Block Scope 块级作用域</a></h3>
<p>使用 var 关键字声明的变量不具备块级作用域的特性，它在 {} 外依然能被访问到。<br />
ES6 可以使用 let 关键字来实现块级作用域。<br />
let 声明的变量只在 let 命令所在的代码块 <strong>{}</strong> 内有效，在 <strong>{}</strong> 之外不能访问。</p>
<h3 id="循环作用域-loop-scope"><a class="header" href="#循环作用域-loop-scope">循环作用域 loop scope</a></h3>
<pre><code class="language-javascript">var i = 5; 
// i 变量溢出去了
for (var i = 0; i &lt; 10; i++) {
// 一些代码… 
} 
// 这里输出 i 为 10

// 使用 let i 变量不溢出
var i = 5; for (let i = 0; i &lt; 10; i++) { // 一些代码… } // 这里输出 i 为 5
</code></pre>
<h2 id="分支语句循环判断控制流control-flow"><a class="header" href="#分支语句循环判断控制流control-flow">分支语句&amp;循环&amp;判断&amp;控制流（Control flow）</a></h2>
<h3 id="条件语句"><a class="header" href="#条件语句">条件语句</a></h3>
<pre><code class="language-javascript">if (time&lt;20)
{
    x=&quot;Good day&quot;;
}

if (time&lt;20)
{
    x=&quot;Good day&quot;;
}
else
{
    x=&quot;Good evening&quot;;
}

if (time&lt;10)
{
    document.write(&quot;&lt;b&gt;早上好&lt;/b&gt;&quot;);
}
else if (time&gt;=10 &amp;&amp; time&lt;20)
{
    document.write(&quot;&lt;b&gt;今天好&lt;/b&gt;&quot;);
}
else
{
    document.write(&quot;&lt;b&gt;晚上好!&lt;/b&gt;&quot;);
}
</code></pre>
<h3 id="switch-选择语句"><a class="header" href="#switch-选择语句">Switch 选择语句</a></h3>
<p>工作原理：首先设置表达式 <em>n</em>（通常是一个变量）。随后表达式的值会与结构中的每个 case 的值做比较。如果存在匹配，则与该 case 关联的代码块会被执行。请使用 <strong>break</strong> 来阻止代码自动地向下一个 case 运行。使用 default 关键词来规定匹配不存在时做的事情。</p>
<pre><code class="language-javascript">switch(n)
{
    case 1:
        执行代码块 1
        break;  // 阻止向下一个 case 运行
    case 2:
        执行代码块 2
        break;
    default:
        与 case 1 和 case 2 不同时执行的代码
}
</code></pre>
<h3 id="for-循环"><a class="header" href="#for-循环">For 循环</a></h3>
<p>Statement 1 在循环开始之前设置变量 (var i=0)。<br />
Statement 2 定义循环运行的条件（i 必须小于 5）。<br />
Statement 3 在每次代码块已被执行后增加一个值 (i++)。</p>
<pre><code class="language-javascript">for (var i=0;i&lt;cars.length;i++)
{ 
    document.write(cars[i] + &quot;&lt;br&gt;&quot;);
}

//  for/in 语句循环遍历对象的属性：
var person={fname:&quot;Bill&quot;,lname:&quot;Gates&quot;,age:56}; 
for (x in person) // x 为属性名 { txt=txt + person[x]; }

</code></pre>
<h3 id="while-循环"><a class="header" href="#while-循环">While 循环</a></h3>
<p>while 循环会在指定条件为真时循环执行代码块。<br />
<code>break;</code> <code>continue;</code> 同样用于跳出和继续循环。 </p>
<pre><code class="language-javascript">while (i&lt;5)
{
    x=x + &quot;The number is &quot; + i + &quot;&lt;br&gt;&quot;;
    i++;
}

do
{
    // do 里面的语句至少会执行一次
    // 即使为 false 也会执行一次
    x=x + &quot;The number is &quot; + i + &quot;&lt;br&gt;&quot;;
    i++;
}
while (i&lt;5);
</code></pre>
<h2 id="函数模块-functions"><a class="header" href="#函数模块-functions">函数&amp;模块 （Functions）</a></h2>
<ol>
<li>JS return 只能返回一个数据</li>
<li>JS Function 是一个函数对象： <code>typeof -&gt; function</code></li>
<li>JavaScript 函数有 <strong>属性</strong> 和 <strong>方法</strong>。<code>.length-&gt;返回接收的参数个数</code> <code>.toString()-&gt;将函数作为一个字符串返回</code></li>
</ol>
<pre><code class="language-javascript">function functionname()  
{  
    // 执行代码_  
}

// 含参参数
function myFunction(var1,var2)  
{  
//代码  
}

// 带返回值的参数
function myFunction()  
{  
    var x=5;  
    return x;  
}
var myVar=myFunction();
</code></pre>
<h3 id="函数表达式"><a class="header" href="#函数表达式">函数表达式</a></h3>
<p>JavaScript 函数可以通过一个表达式定义。<br />
函数表达式可以 <strong>存储在变量</strong> 中：</p>
<pre><code class="language-javascript">// 以分号结尾，因为这是一个执行语句
var x = function (a, b) {return a * b};
var z = x(4, 3);
</code></pre>
<p>以上函数实际上是一个 <strong>匿名函数</strong>  (类似 Python <code>limbda a:a+1</code> 函数没有名称)。<br />
函数存储在变量中，不需要函数名称，通常通过变量名来调用。</p>
<h3 id="function-构造函数-最好不用"><a class="header" href="#function-构造函数-最好不用">Function 构造函数 （最好不用）</a></h3>
<blockquote>
<p>在 JavaScript 中，很多时候，你需要避免使用 <strong>new</strong> 关键字。</p>
</blockquote>
<p>函数本质上是一个 object ，可以通过 <code>new Function()</code> 函数构造器定义。 </p>
<pre><code class="language-javascript">var myFunction = new Function(&quot;a&quot;, &quot;b&quot;, &quot;return a * 
	b&quot;);
var x = myFunction(4, 3);
</code></pre>
<h3 id="函数提升-hoisting"><a class="header" href="#函数提升-hoisting">函数提升 （Hoisting）</a></h3>
<p>类似 <code>var</code> 时的变量提升，使用表达式定义函数时无法提升。</p>
<ul>
<li>提升（Hoisting）是 JavaScript 默认将当前作用域提升到前面去的行为。</li>
<li>提升（Hoisting）应用在变量的声明与函数的声明。</li>
</ul>
<pre><code class="language-javascript">myFunction(5);

function myFunction(y) {
    return y * y;
}
</code></pre>
<h3 id="匿名函数anonymous-function"><a class="header" href="#匿名函数anonymous-function">匿名函数（Anonymous function）</a></h3>
<h3 id="自调用函数-self-invoking"><a class="header" href="#自调用函数-self-invoking">自调用函数 （self invoking）</a></h3>
<ul>
<li><strong>函数表达式</strong> 可以 &quot; 自调用 &quot;。</li>
<li>自调用表达式会自动调用。</li>
<li>如果表达式后面紧跟 () ，则会自动调用。</li>
<li>不能自调用声明的函数。</li>
<li><strong>通过添加括号，来说明它是一个函数表达式</strong>：</li>
</ul>
<pre><code class="language-javascript">(function () {
    var x = &quot;Hello!!&quot;;      // 我将调用自己
})();
</code></pre>
<p>以上函数实际上是一个 <strong>匿名自我调用的函数</strong> (没有函数名)。</p>
<h3 id="箭头函数-es6"><a class="header" href="#箭头函数-es6">箭头函数 ES6</a></h3>
<pre><code class="language-javascript">(参数1, 参数2, …, 参数N) =&gt; { 函数声明 }
(参数1, 参数2, …, 参数N) =&gt; 表达式(单一)
// 相当于：(参数1, 参数2, …, 参数N) =&gt;{ return 表达式; }
</code></pre>
<p>当只有一个参数时，圆括号是可选的：</p>
<pre><code class="language-javascript">(单一参数) =&gt; {函数声明}
单一参数 =&gt; {函数声明}
</code></pre>
<p>没有参数的函数应该写成一对圆括号:</p>
<pre><code class="language-javascript">() =&gt; {函数声明}
</code></pre>
<p>e.g.</p>
<pre><code class="language-javascript">// ES5
var x = function(x, y) {
     return x * y;
}
 
// ES6
const x = (x, y) =&gt; x * y;
</code></pre>
<ol>
<li>箭头函数都<strong>没有</strong>自己的 <strong>this</strong>。 不适合定义一个 <strong>对象的方法</strong>。</li>
<li>当我们使用箭头函数的时候，箭头函数会默认帮我们<strong>绑定外层 this 的值</strong>，所以在箭头函数中 this 的值和外层的 this 是一样的。</li>
<li>箭头函数是<strong>不能提升</strong>的，所以需要在使用之前定义。</li>
<li>使用 <strong>const</strong> 比使用 <strong>var</strong> 更安全，因为函数表达式始终是一个常量。</li>
<li>如果<strong>函数部分只是一个语句</strong>，则可以省略 return 关键字和大括号 {}，这样做是一个比较好的习惯:</li>
</ol>
<pre><code class="language-javascript">const x = (x, y) =&gt; x * y;
const x = (x, y) =&gt; { return x * y };
</code></pre>
<h3 id="函数参数-args--arguments"><a class="header" href="#函数参数-args--arguments">函数参数 (args ==&gt; arguments)</a></h3>
<h4 id="parameters-显性参数-arguments-隐式参数"><a class="header" href="#parameters-显性参数-arguments-隐式参数">Parameters （显性参数） Arguments （隐式参数）</a></h4>
<p>JavaScript 函数有个内置的对象 arguments 对象。<br />
arguments 对象包含了函数调用的参数数组，<strong>可以传入不定数量的参数。</strong></p>
<pre><code class="language-javascript">// 找到最大的数
x = findMax(1, 123, 500, 115, 44, 88);
 
function findMax() {
	// arguments 包含传入函数参数的数组;
    let arg = arguments[0];
    
    if(arguments.length &lt; 2) return arg;
	 
    for (let i = 0; i &lt; arguments.length; i++) {
        if (arguments[i] &gt; max) {
            max = arguments[i];
        }
    }
    return max;
}

// 计算加和
x = sumAll(1, 123, 500, 115, 44, 88);
 
function sumAll() {
    let i, sum = 0;
    for (i = 0; i &lt; arguments.length; i++) {
        sum += arguments[i];
    }
    return sum;
}
</code></pre>
<h4 id="default-args-默认参数"><a class="header" href="#default-args-默认参数">Default Args (默认参数)</a></h4>
<p>如果函数在调用时未提供隐式参数，参数会默认设置为： <strong>undefined</strong></p>
<pre><code class="language-javascript">function myFunction(x, y) {
    if (y === undefined) {
          y = 0;
    } 
}

// simple way
// 如果 y 已经定义，y || 0 返回 y，因为 y 是 true，否则返回 0，因为 undefined 为 false。
function myFunction(x, y) {
    y = y || 0; 
}

// in ES6
// ES6 支持函数带有默认参数，就判断 undefined 和 || 的操作：
function myFunction(x, y = 10) {
    // y is 10 if not passed or undefined
    return x + y;
}
 
myFunction(0, 2) // 输出 2
myFunction(5); // 输出 15, y 参数的默认值
</code></pre>
<h4 id="值传递和引用对象传递"><a class="header" href="#值传递和引用对象传递">值传递和引用对象传递</a></h4>
<ul>
<li>通过值传递给函数，函数对值的更改，在函数外部是不可见的。</li>
<li>通过引用对象传递给函数，函数接收到的是 <strong>引用对象的指针</strong>，在函数内部对引用对象的修改是可以影响到函数外部原本的对象的。</li>
</ul>
<h3 id="函数调用function-invoking"><a class="header" href="#函数调用function-invoking">函数调用（function invoking）</a></h3>
<p>in general. <code>this</code> 指向函数执行时当前的对象。<br />
在浏览器环境，<code>this</code> 指向的是 windows 对象，为浏览器环境的全局对象。</p>
<pre><code class="language-javascript">function myFunction(a, b) {
    return a * b;
}
window.myFunction(10, 2);    // window.myFunction(10, 2) 返回 20
</code></pre>
<p>全局对象：</p>
<pre><code class="language-javascript">function myFunction() {
    return this;
}
myFunction();                // 返回 window 对象
</code></pre>
<p>func as obj methods invoking:</p>
<pre><code class="language-javascript">var myObject = {
    firstName:&quot;John&quot;,
    lastName: &quot;Doe&quot;,
    fullName: function () {
	    // this 值为对象本身
        return this;
    }
}
myObject.fullName();          // 返回 [object Object] (所有者对象)
</code></pre>
<p>使用构造函数调用函数：<br />
如果在函数调用前使用了 <code>new</code> 关键字，就是调用了构造函数。</p>
<pre><code class="language-javascript">// 构造函数:
// 构造函数中 this 关键字没有任何的值。
// this 的值在实例化 new object 时候创建
function myFunction(arg1, arg2) {
    this.firstName = arg1;
    this.lastName  = arg2;
}
 
// This creates a new object
var x = new myFunction(&quot;John&quot;,&quot;Doe&quot;);
x.firstName;                             // 返回 &quot;John&quot;
</code></pre>
<p>作为函数方法调用函数：</p>
<p>function 就是一个 object 他有自己的 attribute 和 methods.</p>
<p><code>call()</code> <code>apply()</code> 是预定义的函数方法，这两个方法用于调用函数，第一个参数必须是函数 this 的对象本身：</p>
<pre><code class="language-javascript">myObject = {
name: &quot;21211&quot;,
method: args =&gt; {
	console.log(&quot;test&quot;+args);
}
}

function myFunction(a, b) {
	// 输出 21211
	console.log(this.name)
    return a * b;
}
// call() 按顺序传入参数 第一个参数会成为函数 this 的值
myObject = myFunction.call(myObject, 10, 2);     // 返回 20

function myFunction(a, b) {
    return a * b;
}
myArray = [10, 2];
// apply() 传入一个参数数组
myObject = myFunction.apply(myObject, myArray);  // 返回 20
</code></pre>
<h3 id="函数闭包-function-closure"><a class="header" href="#函数闭包-function-closure">函数闭包 （Function Closure）</a></h3>
<ol>
<li>变量的生命周期</li>
<li>变量的作用域：所有函数都能访问全局变量。在 JavaScript 中，所有函数 <strong>都能访问它们上一层的作用域</strong>。</li>
</ol>
<pre><code class="language-javascript">function add() {
    var counter = 0;
    function plus() {
	    // 可以访问到父函数的 counter 变量
	    counter += 1;
    }
    plus();
    return counter; 
}
</code></pre>
<p>闭包是一种保护函数私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰：</p>
<blockquote>
<p>匿名函数内部定义的变量和函数 <strong>只能在函数内部访问</strong>，外部无法直接访问，从而实现了信息的封装和隐藏。<br />
如果要实现外部访问，可以通过 <code>return</code> 一个函数或者 obj 来实现外部访问。</p>
</blockquote>
<pre><code class="language-javascript">// 自调用函数
// 使得 add() 函数拥有私有变量 counter
// 计数器受匿名函数的作用域保护，只能通过 add 方法修改。
var add = (function () {
    let counter = 0; // 立即 invoke 且只会执行一次,设置计数器为0并返回函数表达式
    return function () {
	    return counter += 1;
    }
})();
 
add();
add();
add();
 
// 计数器为 3
</code></pre>
<h3 id="js-import-模块"><a class="header" href="#js-import-模块">JS import 模块</a></h3>
<p>Ref：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import">import - JavaScript | MDN</a></p>
<h2 id="类-class对象"><a class="header" href="#类-class对象">类 （class）对象</a></h2>
<h3 id="create-class-创建类"><a class="header" href="#create-class-创建类">Create class 创建类</a></h3>
<p><strong>类是用于创建对象的模板。</strong></p>
<p>使用 class 关键字来创建一个类，类体在一对大括号 {} 中，我们可以在大括号 {} 中定义类成员的位置，如方法或构造函数。</p>
<p>每个类中包含了一个特殊的方法 <code>constructor()</code> （构造器），它是类的 <strong>构造函数</strong> （类似 Py <code>def __init__(self)</code>），这种方法用于创建和初始化一个由 <strong>class</strong> 创建的对象，初始化对象的 attribute。</p>
<pre><code class="language-javascript">// 创建一个类并初始化了两个属性
class ClassName{
	constructor(name, url) {
		this.name = name;
		this.url = url;
		this.year = 2023;	
	}
	// add methods
	method_1() { … } 
	method_2() { … } 
	method_3() { … }
	age() { let date = new Date(); return date.getFullYear() - this.year; }
}

// 创建对象时自动运行 constructor method
let site = new ClassName(&quot;落落の博客&quot;, &quot;https://whaleluo.top&quot;);
console.log(site.age())
</code></pre>
<p>类表达式：<br />
类表达式是定义类的另一种方法。类表达式 <strong>可以命名或不命名</strong>。命名类表达式的名称是该类体的局部名称。</p>
<pre><code class="language-javascript">// 未命名/匿名类
let Runoob = class {
  constructor(name, url) {
    this.name = name;
    this.url = url;
  }
};
console.log(Runoob.name);
// output: &quot;Runoob&quot;
 
// 命名类
let Runoob = class Runoob2 {
  constructor(name, url) {
    this.name = name;
    this.url = url;
  }
};
console.log(Runoob.name);
// 输出: &quot;Runoob2&quot;
</code></pre>
<h3 id="extends-class-继承类"><a class="header" href="#extends-class-继承类">Extends class 继承类</a></h3>
<p><code>super()</code> 用于调用父类的构造函数 <code>constructor()</code> </p>
<pre><code class="language-javascript">// 基类
class Animal {
    constructor(where) {
	    this.where = where;
    }
    eat() { ... }
    sleep() { ... }
};

// 派生类 Dog 类继承自 Animal
class Dog extends Animal {
    constructor(where, age) {
	    super(where); // 调用父类的初始化函数
	    this.age = age;
    }
    bark() {
	    console.log(&quot;The dog in&quot;+this.where+&quot; age:&quot;+this.age);
    }
};

let dog = new Dog(&quot;china&quot;,&quot;21&quot;);
</code></pre>
<p>JavaScript 并没有像其他编程语言一样具有传统的类，而是基于 <strong>原型的继承模型</strong>。<br />
<strong>ES6</strong> 引入了类和 class 关键字，但底层机制仍然基于原型继承。<br />
<strong>ES6</strong> 引入了 class 关键字，使得定义类和继承更加清晰，<code>extends</code> 关键字用于建立继承关系，<code>super</code> 关键字用于在子类构造函数中调用父类的构造函数。</p>
<p>基于 <strong>原型链 (prototype <code>/ˈprəʊ.tə.taɪp/</code> )</strong> 的继承：</p>
<p>在下面实例中，Animal 是一个基类，Dog 是一个继承自 Animal 的子类<br />
<code>Dog.prototype</code> 使用 <code>Object.create(Animal.prototype)</code> 来创建一个新对象，它继承了 <code>Animal.prototype</code> 的方法和属性，通过将 <code>Dog.prototype.constructor</code> 设置为 Dog，确保继承链上的构造函数正确。</p>
<pre><code class="language-javascript">function Animal(name) {
  this.name = name;
}
 
Animal.prototype.eat = function() {
  console.log(this.name + &quot; is eating.&quot;);
};
 
function Dog(name, breed) {
  Animal.call(this, name);
  this.breed = breed;
}
 
// 建立原型链，让 Dog 继承 Animal
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;
 
Dog.prototype.bark = function() {
  console.log(this.name + &quot; is barking.&quot;);
};
 
var dog = new Dog(&quot;Buddy&quot;, &quot;Labrador&quot;);
dog.eat();  // 调用从 Animal 继承的方法
dog.bark(); // 调用 Dog 的方法
</code></pre>
<h3 id="getter-and-setter"><a class="header" href="#getter-and-setter">Getter and setter</a></h3>
<p>类中我们可以使用 <code>getter</code> 和 <code>setter</code> 来获取和设置值，<code>getter</code> 和 <code>setter</code> 都需要在严格模式下执行。<code>getter</code> 和 <code>setter</code> 可以使得我们对属性的操作变的很灵活。</p>
<ol>
<li>类中添加 getter 和 setter 使用的是 <code>get</code> 和 <code>set</code> 关键字。</li>
<li>即使 getter 是一个方法，当你想 <strong>获取属性值时也不要使用括号</strong>。</li>
<li>使用 setter，请使用与设置属性值时相同的语法，虽然 set 是一个方法，但需要 <strong>不带括号</strong></li>
<li><code>getter/setter</code> 方法的名称不能与属性的名称相同，在本例中属名为 <code>sitename</code>。</li>
<li>很多开发者在属性名称前使用下划线字符 <code>_</code> 将 <code>getter/setter</code> 与实际属性分开：</li>
</ol>
<pre><code class="language-javascript">class Runoob {
  constructor(name) {
    this._sitename = name;
  }
  get sitename() {
    return this.sitename;
  }
  set sitename(x) {
    this.sitename = x;
  }
}
 
let noob = new Runoob(&quot;菜鸟教程&quot;);
noob.sitename = &quot;121&quot; // 相当于调用 sitename(&quot;121&quot;)
documen2t.getElementById(&quot;demo&quot;).innerHTML = noob.sitename;
</code></pre>
<h3 id="类提升class-hoisting"><a class="header" href="#类提升class-hoisting">类提升（class hoisting）</a></h3>
<p>函数声明和类声明之间的一个重要区别在于, <strong>函数声明会提升，类声明不会。</strong><br />
你首先需要声明你的类，然后再访问它，否则将抛出 ReferenceError</p>
<h3 id="class-static-method-类静态方法"><a class="header" href="#class-static-method-类静态方法">Class static method (类静态方法)</a></h3>
<p>静态方法是使用 static 关键字修饰的方法，又叫类方法，<strong>属于类的，但不属于对象</strong>，在实例化对象之前可以通过 <code>类名.方法名</code> 调用静态方法。</p>
<p><strong>静态方法不能在对象上调用，只能在类中调用。</strong></p>
<pre><code class="language-javascript">class Animal {
	constructor(name) {
		this._name = name;
	}
	// 类初始化后对象的方法
	hello() {
		return &quot;The &quot;+this.name+&quot;say hello!&quot;
	}
	// 类的静态方法
	static state() {
		return &quot;static method&quot;
	}
	get name() {
		return this._name()
	}
}

// 可以在类上直接调用 static 方法,不用 new 实例化类
Animal.state()

let dog = new Animal();
dog.state() // 不可以在类实例化后的对象中调用类的静态方法
</code></pre>
<h3 id="this-keyword-this-关键字"><a class="header" href="#this-keyword-this-关键字">This keyword this 关键字</a></h3>
<p>面向对象语言中 this 表示当前对象的一个引用。</p>
<p>但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。</p>
<ul>
<li>在方法中，this 表示该方法所属的对象。</li>
<li>如果单独使用，this 表示全局对象。</li>
<li>在函数中，this 表示全局对象。</li>
<li>在函数中，在严格模式下，this 是未定义的 (undefined)。</li>
<li>在事件中，this 表示接收事件的元素。</li>
<li>类似 <code>call()</code> 和 <code>apply()</code> 方法可以将 this 引用到任何对象。（#1）</li>
</ul>
<pre><code class="language-javascript">// 单独使用 this 在浏览器中，window 就是该全局对象为 [**object Window**]:
var x = this;

var person = {
  firstName: &quot;John&quot;,
  lastName : &quot;Doe&quot;,
  id       : 5566,
  // 方法中的 this 表示方法所属于的对象
  fullName : function() {
    return this.firstName + &quot; &quot; + this.lastName;
  }
};
</code></pre>
<p>显式函数绑定：</p>
<p>在 JavaScript 中函数也是对象，对象则有方法，<code>apply 和 call 就是函数对象的方法</code>。这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。<br />
在下面实例中，当我们使用 person2 作为参数来调用 person1.fullName 方法时, <strong>this</strong> 将指向 person2, 即便它是 person1 的方法：</p>
<pre><code class="language-javascript">var person1 = {
  fullName: function() {
    return this.firstName + &quot; &quot; + this.lastName;
  }
}
var person2 = {
  firstName:&quot;John&quot;,
  lastName: &quot;Doe&quot;,
}
person1.fullName.call(person2);  // 返回 &quot;John Doe&quot;
</code></pre>
<h2 id="异常处理-exception-handling"><a class="header" href="#异常处理-exception-handling">异常处理 （Exception handling）</a></h2>
<p>当错误发生时，当事情出问题时，JavaScript 引擎通常会停止，并生成一个错误消息。<br />
描述这种情况的技术术语是：JavaScript 将**抛出 (throw)**一个错误。</p>
<pre><code class="language-javascript">try {
    …    //异常的抛出
    throw exception; // throw 语句抛出错误
} catch(e) {
    …    //异常的捕获与处理
} finally {
		  // finally 语句不论之前的 try 和 catch 中是否产生异常都会执行该代码块。
    …    //结束处理
}
</code></pre>
<h2 id="javascriptvoid0-含义"><a class="header" href="#javascriptvoid0-含义">javascript:void(0) 含义</a></h2>
<p>javascript:void(0) 中最关键的是 <strong>void</strong> 关键字， <strong>void</strong> 是 JavaScript 中非常重要的关键字，<strong>该操作符指定要计算一个表达式但是不返回值。</strong></p>
<pre><code class="language-javascript">void(func())
javascript:void(func())

function getValue(){
   var a,b,c;
   a = void ( b = 5, c = 7 ); // 运行 b = 5, c = 7 但不赋值给 a
   // a = undefind
   document.write('a = ' + a + ' b = ' + b +' c = ' + c );
}
</code></pre>
<h2 id="javascript-asynchronous-异步"><a class="header" href="#javascript-asynchronous-异步">JavaScript asynchronous 异步</a></h2>
<p>JavaScript 中的异步操作函数往往通过 <strong>回调函数</strong> 来实现异步任务的结果处理。<br />
回调函数就是一个函数，它是在我们启动一个异步任务的时候就告诉它：等你完成了这个任务之后要干什么。这样一来主线程几乎不用关心异步任务的状态了，他自己会善始善终。</p>
<pre><code class="language-javascript">function print() {
    document.getElementById(&quot;demo&quot;).innerHTML=&quot;RUNOOB!&quot;;
}
setTimeout(print, 3000);

setTimeout(function () {
    document.getElementById(&quot;demo&quot;).innerHTML=&quot;RUNOOB!&quot;;
}, 3000);
</code></pre>
<p><a href="https://www.runoob.com/js/js-promise.html">JavaScript Promise | 菜鸟教程</a></p>
<h3 id="js-promise"><a class="header" href="#js-promise">JS Promise</a></h3>
<p><strong>Promise</strong> 是一个 ECMAScript 6 提供的类，目的是更加优雅地书写复杂的异步任务。</p>
<p>Promise 对象代表一个异步操作，有三种状态：<strong>Pending</strong>（进行中）、<strong>Resolved</strong>（已完成，又称 Fulfilled）和 <strong>Rejected</strong>（已失败）。</p>
<p>通过回调里的 <strong>resolve(data)</strong> 将这个 Promise 标记为 <strong>resolverd</strong>，然后进行下一步 then((data)=&gt;{//do something})，resolve 里的参数就是你要传入 then 的数据。</p>
<pre><code class="language-javascript">new Promise(function (resolve, reject) {
    // 要做的事情…
});
</code></pre>
<p>用于多次调用异步函数，避免回调地狱，如：</p>
<pre><code class="language-javascript">setTimeout(function () {
    console.log(&quot;First&quot;);
    setTimeout(function () {
        console.log(&quot;Second&quot;);
        setTimeout(function () {
            console.log(&quot;Third&quot;);
        }, 3000);
    }, 4000);
}, 1000);
</code></pre>
<p>用 Promise 实现相同功能：</p>
<p> <strong>Promise 将嵌套格式的代码变成了顺序格式的代码。</strong></p>
<pre><code class="language-javascript">new Promise(function (resolve, reject) {
    setTimeout(function () {
        console.log(&quot;First&quot;);
        resolve();
    }, 1000);
}).then(function () {
    return new Promise(function (resolve, reject) {
        setTimeout(function () {
            console.log(&quot;Second&quot;);
            resolve();
        }, 4000);
    });
}).then(function () {
    setTimeout(function () {
        console.log(&quot;Third&quot;);
    }, 3000);
});
</code></pre>
<p>Promise 构造函数是 JavaScript 中用于创建 Promise 对象的内置构造函数。</p>
<p>Promise 构造函数接受一个函数作为参数，该函数是同步的并且会被立即执行，所以我们称之为<strong>起始函数</strong>。起始函数包含两个参数 <code>resolve</code> 和 <code>reject</code>，分别表示 <code>Promise</code> 成功和失败的状态。</p>
<p>起始函数执行成功时，它应该调用 <code>resolve</code> 函数并传递成功的结果。当起始函数执行失败时，它应该调用 <code>reject</code> 函数并传递失败的原因。</p>
<p>Promise 构造函数返回一个 Promise 对象，该对象具有以下几个方法：</p>
<ul>
<li><code>then</code>：用于处理 Promise 成功状态的回调函数。</li>
<li><code>catch</code>：用于处理 Promise 失败状态的回调函数。</li>
<li><code>finally</code>：无论 Promise 是成功还是失败，都会执行的回调函数。</li>
</ul>
<pre><code class="language-javascript">// new Promise obj 需要传入一个起始函数作为参数
// 下面使用了 Javascript 匿名函数 (函数参数) =&gt;{ 函数体 }
const promise = new Promise((resolve, reject) =&gt; {
  // 异步操作
  // 使用 setTimeout 模拟了一个异步操作。如果异步操作成功，则调用 resolve 函数并传递成功的结果；如果异步操作失败，则调用 reject 函数并传递失败的原因。
  setTimeout(() =&gt; {
    if (Math.random() &lt; 0.5) {
      resolve('success'); // 执行成功传递给 than 方法 result
    } else {
      reject('error'); // 执行错误传递给 catch 方法 error
    }
  }, 1000);
});

// 使用 then 方法处理 Promise 成功状态的回调函数，使用 catch 方法处理 Promise 失败状态的回调函数。
promise.then(result =&gt; {
  console.log(result);
}).catch(error =&gt; {
  console.log(error);
}).finally(
// 成功与否都会执行的函数
() =&gt; { 
	console.log(&quot;End&quot;); 
}
);
</code></pre>
<ul>
<li>resolve 和 reject 的作用域只有起始函数，不包括 then 以及其他序列；</li>
<li>resolve 和 reject 并不能够使起始函数停止运行，别忘了 return。</li>
</ul>
<p>then 方法可以接收两个回调函数作为参数，第一个回调函数是 Promise 对象的状态改变为 resoved 是调用，第二个回调函数是 Promise 对象的状态变为 rejected 时调用。<strong>其中第二个参数可以省略</strong>。</p>
<pre><code class="language-javascript">var promise =new Promise(function(resolve,reject){
    //To Do 要异步执行的事情，这个异步执行的事情有可能成功执行完毕，那么Promise将是fulfilled状态，如果执行失败则是rejected;
    //下面测试代码，人为设置为rejected状态;
    reject(&quot;将当前构建的Promise对象的状态由pending（进行中）设置为rejected（已拒绝）&quot;); //当然此处也可以设置为fulfilled(已完成)状态
})

promise.then(//调用第一个then()
    success=&gt;{
        console.log(&quot;异步执行成功，状态为：fulfilled，成功后返回的结果是：&quot;+success);
        return(&quot; 当前 success &quot;);
    },
    error=&gt;{
        console.log(&quot;异步执行失败，状态为rejected，失败后返回的结果是：&quot;+error);
        return(&quot; 当前 error &quot;);
    }
).then(
    //调用第二个then() 因为调用第一个then()方法返回的是一个新的promise对象，此对象的状态由上面的success或者error两个回调函数的执行情况决定的：
    //如果回调函数能正常执行完毕，则新的promise对象的状态为fulfilled，下面执行success2,如果回调函数无法正常执行，则promise状态为rejected;下面执行error2
    success2=&gt;{
        console.log(&quot;第一个then的回调函数执行成功 成功返回结果：&quot;+success2);
        throw(&quot; 当前 success2 &quot;);//自定义异常抛出
    },
    error2=&gt;{
        console.log(&quot;第一个then的回调函数执行失败 失败返回结果：&quot;+error2);
        return(&quot; 当前 error2 &quot;);
    }
).catch(err=&gt;{
    //当success2或者error2执行报错时，catch会捕获异常;
    console.log(&quot;捕获异常：&quot;+err);
});

//上述代码,打印如下:
//异步执行失败，状态为rejected，失败后返回的结果是：将当前构建的Promise对象的状态由pending（进行中）设置为rejected（已拒绝）
//第一个then的回调函数执行成功 成功返回结果： 当前 error
//捕获异常： 当前 success2
</code></pre>
<p>这种返回值为一个 <code>Promise</code> 对象的函数称作 <code>Promise</code> 函数，它常常用于开发基于异步操作的库。</p>
<pre><code class="language-javascript">function print(delay, message) {
    return new Promise(function (resolve, reject) {
        setTimeout(function () {
            console.log(message);
            resolve();
        }, delay);
    });
}

print(1000, &quot;First&quot;).then(function () {
    return print(4000, &quot;Second&quot;);
}).then(function () {
    print(3000, &quot;Third&quot;);
});

</code></pre>
<h3 id="异步函数-async-function"><a class="header" href="#异步函数-async-function">异步函数 async function</a></h3>
<p>一个返回 Promise 对象的 Promise 函数：</p>
<pre><code class="language-javascript">function print(delay, message){
	return new Promise(
		(resolve, reject) =&gt; {
		
			setTimeout(
				() =&gt; {
					console.log(message);
					resolve();
				}
			)
			return;
		}
	)

}
</code></pre>
<p>用不同的时间将 <strong>顺序输出</strong> 三行文本：</p>
<pre><code class="language-javascript">print(1000, &quot;First&quot;).than(
	() =&gt; { return print(4000, &quot;Second&quot;); }
).than(
	() =&gt; { return print(3000,&quot;Third&quot;); }
)
</code></pre>
<p>可以使用 <code>await</code> 等待异步函数的执行完成，增加代码可读性：<br />
异步函数 <code>async function</code> 中可以使用 await 指令，<code>await</code> 指令后必须跟着一个 <code>Promise</code>，异步函数会在这个 <code>Promise</code> 运行中暂停，直到其运行结束再继续运行。</p>
<pre><code class="language-javascript">async function asyncFunc(){
	await print(1000, &quot;First&quot;);
	await print(4000, &quot;Second&quot;);
	await print(3000, &quot;Third&quot;);
}

asyncFunc();
</code></pre>
<p>处理异常也可以用 <code>thy-catch</code> 机制实现：</p>
<pre><code class="language-javascript">async function asyncFunc(){
	try {
		await new Promise(
			(resolve, reject) =&gt; {
				throw &quot;Some Error&quot;;
				// 或者 reject(&quot;Some Eroor&quot;);
			} 
		);
	} catch (err) {
		// 输出 &quot;Some Error&quot;
		console.log(err);
	}
}

asyncFunc();
</code></pre>
<p>如果 Promise 有一个正常的返回值，await 语句也会返回它：</p>
<pre><code class="language-javascript">async function asyncFunc() {
    let value = await new Promise(
        function (resolve, reject) {
			// 相当于 return &quot;Return value&quot;
            resolve(&quot;Return value&quot;);
        }
    );
    console.log(value);
}
asyncFunc();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>title: Vue3 正式学习笔记
date: 2023-08-22 15:35:04
updated: 2023-08-22 15:35:04
categories: Vue
tags: [JS, JavaScript, 前端, Vue, Element-UI, UI]
description: 
thumbnail: 
banner_img:</h2>
<h1 id="vue3-正式学习笔记"><a class="header" href="#vue3-正式学习笔记">Vue3 正式学习笔记</a></h1>
<p>经过了前面 Javascript 和 Nodejs 前置知识的铺垫，我想我应该可以正式学习 Vue 这个前端框架了叭。</p>
<p>先看视频放松下过一遍：<br />
<a href="https://www.bilibili.com/video/BV1Rs4y127j8/?">【2023最新版】Vue3从入门到精通，零基础小白也能听得懂，写得出，web前端快速入门教程_哔哩哔哩_bilibili</a></p>
<blockquote>
<p>上面的视频虽然说得是 Vue3 但是是按照 <strong>组合式 API</strong> 讲解的，Vue3 文档推荐使用 <strong>响应式 API</strong> 编写代码。</p>
</blockquote>
<p>reference：<a href="https://cn.vuejs.org/guide/essentials/application.html">创建一个 Vue 应用 | Vue.js</a></p>
<h2 id="fast-start"><a class="header" href="#fast-start">Fast Start</a></h2>
<p>Install vue framework in NodeJS</p>
<pre><code class="language-shell">npm install vue@latest -g # 全局安装

npm create vue@latest # 创建 vue3 项目

cd &lt;your-project-name&gt;
npm install
npm run dev

npm run build # 发布到生产环境 ./dist
</code></pre>
<h2 id="响应式-api-和组合式-api"><a class="header" href="#响应式-api-和组合式-api">响应式 API 和组合式 API</a></h2>
<p>HelloWorld.vue</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;h1&gt;{{ msg }} Start Learning Vue Framework&lt;/h1&gt;
  &lt;button @click=&quot;switchName&quot;&gt;switchName&lt;/button&gt;
&lt;/template&gt;

&lt;script setup&gt;
  // 响应式 API 写法
  import { ref } from 'vue'
  const msg = ref(&quot;WhaleFall&quot;);

  // switch name
  function switchName() {
      msg.value = msg.value == &quot;WhaleFall&quot; ? &quot;颖怡&quot; : &quot;WhaleFall&quot;;
  }
&lt;/script&gt;

&lt;script&gt;
  // 组合式 API 写法
  export default {
      data: function () {
          return {
              msg: &quot;Mess&quot;
          }
      },
      methods: {
          switchName() {
              this.msg = this.msg == &quot;WhaleFall&quot; ? &quot;颖怡&quot; : &quot;WhaleFall&quot;;
          }
      },

  }
&lt;/script&gt;

</code></pre>
<p>App.vue</p>
<pre><code class="language-html">&lt;template&gt;
    &lt;HelloWorld /&gt;
&lt;/template&gt;
&lt;script setup&gt;
import HelloWorld from './components/HelloWorld.vue';
&lt;/script&gt;
&lt;style scoped&gt;&lt;/style&gt;
</code></pre>
<p>main.js</p>
<pre><code class="language-js">import { createApp } from 'vue'
import App from './App.vue'
const app = createApp(App);
app.mount('#app');
</code></pre>
<h2 id="声明响应式状态"><a class="header" href="#声明响应式状态">声明响应式状态</a></h2>
<p>在组合式 API 中，推荐使用 <a href="https://cn.vuejs.org/api/reactivity-core.html#ref"><code>ref()</code></a> 函数来声明响应式状态，定义响应式依赖。</p>
<pre><code class="language-javascript">import { ref } from 'vue'
const count = ref(0) // 初始化数值
</code></pre>
<h2 id="计算属性-computed"><a class="header" href="#计算属性-computed">计算属性 computed</a></h2>
<p>返回值为一个<strong>计算属性 ref</strong>，通过 <code>publishedBooksMessage.value</code> 访问计算结果，计算属性 ref 也会在模板中自动解包，因此在模板表达式中引用时无需添加 <code>.value</code>。</p>
<p><strong>计算属性值会基于其响应式依赖被缓存</strong></p>
<pre><code class="language-javascript">const publishedBooksMessage = computed(
// 依赖于 author 对象
// 只要 `author.books` 不改变，无论多少次访问 `publishedBooksMessage` 都会立即返回先前的计算结果，而不用重复执行 getter 函数。
() =&gt; { return author.books.length &gt; 0 ? 'Yes' : 'No' }
)
</code></pre>
<p>计算属性默认是只读的。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建。</p>
<pre><code class="language-javascript">&lt;script setup&gt;
import { ref, computed } from 'vue'

const firstName = ref('John')
const lastName = ref('Doe')

const fullName = computed({
  // getter
  // 应只做计算而没有任何其他的副作用
  // **不要在 getter 中做异步请求或者更改 DOM**！
  get() {
    return firstName.value + ' ' + lastName.value
  },
  // setter
  set(newValue) {
    // 注意：我们这里使用的是解构赋值语法
    [firstName.value, lastName.value] = newValue.split(' ')
  }
})
&lt;/script&gt;
</code></pre>
<h2 id="watch-监听器"><a class="header" href="#watch-监听器">watch 监听器</a></h2>
<p>每次响应式状态变化时触发回调函数：</p>
<pre><code class="language-javascript">&lt;script setup&gt;
import { ref, watch } from 'vue'

const question = ref('')
const answer = ref('Questions usually contain a question mark. ;-)')

// 可以直接侦听一个 ref
watch(question, async (newQuestion, oldQuestion) =&gt; {
  if (newQuestion.indexOf('?') &gt; -1) {
    answer.value = 'Thinking…'
    try {
      const res = await fetch('https://yesno.wtf/api')
      answer.value = (await res.json()).answer
    } catch (error) {
      answer.value = 'Error! Could not reach the API. ' + error
    }
  }
})
&lt;/script&gt;

&lt;template&gt;
  &lt;p&gt;
    Ask a yes/no question:
    &lt;input v-model=&quot;question&quot; /&gt;
  &lt;/p&gt;
  &lt;p&gt;{{ answer }}&lt;/p&gt;
&lt;/template&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>title: NodeJS 速通笔记
date: 2023-08-22 14:40:10
updated: 2023-08-22 14:40:10
categories: JavaScript
tags: [NodeJS, JS, JavaScript]
description: 
thumbnail: 
banner_img:</h2>
<h1 id="nodejs-速通笔记"><a class="header" href="#nodejs-速通笔记">NodeJS 速通笔记</a></h1>
<p><a href="https://www.runoob.com/nodejs/nodejs-tutorial.html">Node.js 教程 | 菜鸟教程</a></p>
<p>Nodejs 是运行在服务端的 JavaScript 环境。速通 NodeJS 也可以为开发 <strong>Vue</strong> 应用打下基础。<br />
使用 NodeJs 时，不仅实现了应用还实现了一整个 HTTP 服务器，可以避免使用 Nginx 进行提供 HTTP 服务。<br />
<code>NPM</code> 是 <code>NodeJS</code> 的一个包管理工具，类似 <code>Python pip</code>。</p>
<p>NodeJS 是 <strong>单线程单进程</strong> 的应用程序，但是 V8 引擎提供了异步执行回调的接口，通过接口可以处理大量并发。</p>
<pre><code class="language-shell">node -v
npm -v
</code></pre>
<h2 id="npm-包管理工具"><a class="header" href="#npm-包管理工具">Npm 包管理工具</a></h2>
<pre><code class="language-shell"># 更新 npm 版本
npm install npm -g
# 使用淘宝的 npm 镜像
npm install -g cnpm --registry=https://registry.npmmirror.com

# 安装模块 web 框架模块 express
npm install express

npm install express          # 本地安装
npm install express -g   # 全局安装

npm list -g # 查看安装信息
npm uninstall express # 卸载模块
npm ls # 查看安装的模块
npm update express # 更新模块
npm search express # 搜索模块
npm cache clear # 清空 NPM 本地缓存
npm install
</code></pre>
<p>本地安装好之后，<code>express</code> 包就放在了工程目录下的 <code>node_modules</code> 目录中，因此在代码中只需要通过 <code>require('express')</code> 的方式就好，无需指定第三方包路径。</p>
<pre><code class="language-js">var express = require(&quot;express&quot;) 
</code></pre>
<p>npm 的包安装分为本地安装（local）、全局安装（global）两种。使用 <code>-g</code> 指定全局安装。</p>
<p>在工程目录使用 <code>package.json</code> 定义包的属性，类似 Python 中的 <code>requirements.txt</code></p>
<h2 id="nodejs-回调函数"><a class="header" href="#nodejs-回调函数">Nodejs 回调函数</a></h2>
<p>异步编程依托于 <strong>回调</strong> 来实现。Node 使用了大量的回调函数。</p>
<p>例如可以一边读取文件一边执行其他命令，在文件读取完成后，可以将文件内容作为回调函数的参数返回，这样在执行代码时候就没有堵塞和等待 I/O 操作</p>
<p>回调函数一般作为函数的最后一个参数出现：</p>
<pre><code class="language-js">function foo(name, age, dealine, callback){
	// 执行 I/O 操作
	...
	// 执行完毕进行回调
	callback(content);
}
</code></pre>
<p>例如读取文件：</p>
<pre><code class="language-js">var fs = require(&quot;fs&quot;); // 导入文件操作包

var data = fs.readFileSync('input.txt'); // 堵塞了

console.log(data.toString());
console.log(&quot;程序执行结束!&quot;);

</code></pre>
<p>非堵塞：</p>
<pre><code class="language-js">var fs = require(&quot;fs&quot;);
fs.readFile('input.txt', function (err, data) {
	// 回调函数
    if (err) return console.error(err);
    console.log(data.toString());
});
console.log(&quot;程序执行结束!&quot;); // 先弹出
</code></pre>
<p>因此，阻塞是按顺序执行的，而非阻塞是<strong>不需要按顺序</strong>的，所以如果需要处理<strong>回调函数的参数</strong>，我们就需要写在回调函数内。</p>
<h2 id="nodejs-event-loop-事件循环"><a class="header" href="#nodejs-event-loop-事件循环">NodeJS event loop 事件循环</a></h2>
<p>Node.js 单线程类似进入一个 <code>while(true)</code> 的事件循环，直到没有事件观察者退出，每个异步事件都生成一个<strong>事件观察者</strong>，如果有事件发生就调用该 <strong>回调函数</strong>.</p>
<p>本质上就是一个 <strong>事件驱动程序</strong></p>
<pre><code class="language-js">// 引入 events 模块
var events = require('events');
// 创建 eventEmitter 对象 事件发射器
var eventEmitter = new events.EventEmitter(); 
 
// 创建事件处理程序
var connectHandler = function connected() {
   console.log('连接成功。');
  
   // 触发 data_received 事件 
   eventEmitter.emit('data_received');
}
 
// 绑定 connection 事件处理程序
eventEmitter.on('connection', connectHandler);
 
// 使用匿名函数绑定 data_received 事件
eventEmitter.on('data_received', function(args){
   console.log('数据接收成功。'+args);
});
 
// 触发 connection 事件 
// 发射一个 connection 事件到事件队列
// nodejs 触发对应的回调函数,可以跟参数发射到回调函数
eventEmitter.emit('connection', &quot;param&quot;);
 
console.log(&quot;程序执行完毕。&quot;);
</code></pre>
<p>Node.js 所有的异步 I/O 操作在完成时都 会<strong>发送一个事件到事件队列</strong>。</p>
<p>Node.js 里面的许多对象都会分发事件：一个 <code>net.Server</code> 对象会在每次有新连接时触发一个事件， 一个 <code>fs.readStream</code> 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 <code>events.EventEmitter</code> 的实例。</p>
<h2 id="nodejs-buffer-缓冲区"><a class="header" href="#nodejs-buffer-缓冲区">Nodejs Buffer 缓冲区</a></h2>
<p>js 语言没有二进制类型，但是处理 tcp 流或者文件流时候必须使用二进制数据。</p>
<p>使用 <strong>Buffer</strong> 类（自带的不需要引入），可以创建一个专门存放二进制数据的缓冲区。</p>
<pre><code class="language-js">const buf = Buffer.from('runoob', 'ascii');

// 输出 72756e6f6f62
console.log(buf.toString('hex'));

// 输出 cnVub29i
console.log(buf.toString('base64'));
</code></pre>
<p>详细请参考：<a href="https://www.runoob.com/nodejs/nodejs-buffer.html">Node.js Buffer(缓冲区) | 菜鸟教程</a></p>
<h2 id="nodejs-模块系统"><a class="header" href="#nodejs-模块系统">NodeJs 模块系统</a></h2>
<h3 id="引入模块"><a class="header" href="#引入模块">引入模块</a></h3>
<pre><code class="language-js">// 引入当前目录下的 hello.js 文件
var hello = require('./hello');
hello.world(); // 调用 hello.js 文件的 world() 函数
</code></pre>
<p>Node.js 提供了 <code>exports</code> 和 <code>require</code> 两个对象，其中 <code>exports</code> 是模块<strong>公开的接口</strong>，<code>require</code> 用于<strong>从外部获取一个模块的接口</strong>，即所获取模块的 exports 对象。</p>
<p>hello.js</p>
<pre><code class="language-js">// 可以从外部引入，导出到外部
exports.world = function() {
  console.log('Hello World');
}

// hello.js 
function Hello() {
	// object create 对象构造器
    var name; 
    this.setName = function(thyName) { 
        name = thyName; 
    }; 
    this.sayHello = function() { 
        console.log('Hello ' + name); 
    }; 
}; 
module.exports = Hello;  // 把一个对象封装到模块中

</code></pre>
<p>在以上示例中，hello.js 通过 exports 对象把 world 作为 <strong>模块的访问接口</strong>，在 main.js 中通过 <code>require('./hello')</code> 加载这个模块，然后就可以直接访 问 hello.js 中 exports 对象的成员函数了。</p>
<p>main.js</p>
<pre><code class="language-js">//main.js 
var Hello = require('./hello'); 
hello = new Hello(); // 直接引用 
hello.setName('BYVoid'); 
hello.sayHello(); 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><hr />
<h2>title: TypeScript 快速入门☞北
date: 2023-09-01 21:50:74
updated: 2023-09-01 21:50:74
categories: JavaScript
tags: [Vue, TypeScript, TS, Javascript]
description: 
thumbnail: 
banner_img:</h2>
<h1 id="typescript-快速入门北"><a class="header" href="#typescript-快速入门北">TypeScript 快速入门☞北</a></h1>
<p>因为在学习 Vue Framework 的过程中，碰到了很多 TypeScript 之类的知识和语法以及 Vue 源码也是通过 ts 写的，所以有必要去了解一下 TypeScript 这个语言语法。</p>
<p>reference: <a href="https://www.runoob.com/typescript/ts-tutorial.html">TypeScript 教程 | 菜鸟教程</a></p>
<ol>
<li>TypeScript ==&gt; JavaScript 的一个 <strong>超集</strong>，支持 ECMAScript 6 标准</li>
<li>TypeScript 由 <strong>微软</strong> 爸爸开发。</li>
<li>TypeScript 设计目标是开发大型应用，它可以 <strong>编译成纯 JavaScript</strong>，编译出来的 JavaScript 可以运行在任何浏览器上。</li>
</ol>
<p>TypeScript 是一种给 JavaScript 添加特性的语言扩展，他主要添加了 对 JS <strong>类型</strong> 的支持 ，相当于 Python 的 <code>function hint</code> (函数暗示) <code>Pydantic BaseModel</code>、<code>typing</code> 等给弱类型的动态语言 <strong>提供类型支持</strong>。</p>
<h2 id="install-2"><a class="header" href="#install-2">INSTALL</a></h2>
<p>TS 基于 NodeJS</p>
<pre><code class="language-shell">npm config set registry https://registry.npmmirror.com # 换 npm 源
npm install -g typescript

tsc -v # 查看 version
</code></pre>
<p>编写 main.ts</p>
<pre><code class="language-typescript">var message:string = &quot;Hello World&quot;
console.log(message)
</code></pre>
<p>然后执行以下命令将 TypeScript 转换为 JavaScript 代码：</p>
<pre><code class="language-shell">tsc main.ts
node main.js # 执行编译完成的 JS 文件
</code></pre>
<p>TypeScript ==&gt; TypeScript Compiler ==&gt; JavaScript</p>
<h2 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h2>
<pre><code class="language-typescript">let anywhere: any = null; // any 任何类型
let decLiteral: number = 6;    // 数字类型
let name: string = &quot;Runoob&quot;; // 字符串
let flag: boolean = true; // 布尔
let array:number[] = [1, 2]; // 数组
// 元组
let x: [string, number];
x = ['Runoob', 1];

// enumerate 枚举
enum Color {Red, Green, Blue};
let c: Color = Color.Blue;
console.log(c);    // 输出 2

// void 空的 用于标记方法返回值的类型，表示没有返回值
function hello(): void {
    alert(&quot;Hello Runoob&quot;);
}
// never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值。
// 函数中它通常表现为抛出异常或无法执行到终止点 例如无限循环
never
// 返回值为 never 的函数可以是无法被执行到的终止点的情况
function loop(): never {
    while (true) {}
}

// 可以用 | 来支持多种类型
// 启用 --strictNullChecks
let x: number | null | undefined;
x = 1; // 编译正确
x = undefined;    // 编译正确
x = null;    // 编译正确
</code></pre>
<h2 id="各种循环-loop"><a class="header" href="#各种循环-loop">各种循环 loop</a></h2>
<p>TypeScript 还支持 for…of 、forEach、every 和 some 循环。</p>
<pre><code class="language-typescript">let someArray = [1, &quot;string&quot;, false];
 
for (let entry of someArray) {
    console.log(entry); // 1, &quot;string&quot;, false
}

let list = [4, 5, 6];
list.forEach((val, idx, array) =&gt; {
    // val: 当前值
    // idx：当前index
    // array: Array
});

let list = [4, 5, 6];
list.every((val, idx, array) =&gt; {
    // val: 当前值
    // idx：当前index
    // array: Array
    return true; // Continues
    // Return false will quit the iteration
});
</code></pre>
<h2 id="function-函数"><a class="header" href="#function-函数">Function 函数</a></h2>
<pre><code class="language-typescript">function function_name():return_type { 
    // 语句
    return value; 
}

// 带参数
function add(x: number, y: number): number {
    return x + y;
}
console.log(add(1,2))

// parameter? 可选参数
function buildName(firstName: string, lastName?: string) {
    if (lastName)
        return firstName + &quot; &quot; + lastName;
    else
        return firstName;
}
 
let result1 = buildName(&quot;Bob&quot;);  // 正确
let result2 = buildName(&quot;Bob&quot;, &quot;Adams&quot;, &quot;Sr.&quot;);  // 错误，参数太多了
let result3 = buildName(&quot;Bob&quot;, &quot;Adams&quot;);  // 正确

// set default parameter
function calculate_discount(price:number,rate:number = 0.50) { 
    var discount = price * rate; 
    console.log(&quot;计算结果: &quot;,discount); 
} 
calculate_discount(1000) 
calculate_discount(1000,0.30)

// 剩余参数 ...parameter 得到一个参数 list Array
function buildName(firstName: string, ...restOfName: string[]) {
    return firstName + &quot; &quot; + restOfName.join(&quot; &quot;);
}
  
let employeeName = buildName(&quot;Joseph&quot;, &quot;Samuel&quot;, &quot;Lucas&quot;, &quot;MacKinzie&quot;);

// Lambda 函数 箭头函数
var foo = (x:number)=&gt;10 + x 
console.log(foo(100))      //输出结果为 110

</code></pre>
<h2 id="interface-接口"><a class="header" href="#interface-接口">Interface 接口</a></h2>
<p>对象实现接口。类是对象的构造器。</p>
<p>与 Golang 接口的概念一样，接口是 <strong>method</strong> 和 <strong>attribute</strong> 的集合，需要有对应的类去实现，如果类实现了接口中的所有 methods 就可以说这个类实现了这个接口。</p>
<pre><code class="language-typescript">interface IPerson { 
    firstName:string, 
    lastName:string, 
    sayHi: ()=&gt;string 
} 

// customer 类实现了 IPerson 接口
var customer:IPerson = { 
    firstName:&quot;Tom&quot;,
    lastName:&quot;Hanks&quot;, 
    sayHi: ():string =&gt;{return &quot;Hi there&quot;} 
} 
 
console.log(&quot;Customer 对象 &quot;) 
console.log(customer.firstName) 
console.log(customer.lastName) 
console.log(customer.sayHi())  
</code></pre>
<p>interface 中使用 union type</p>
<pre><code class="language-typescript">interface RunOptions { 
    program:string; 
    // commandline 可以是一个 字符串列表，可以是一个字符串，也可以是一个 return 字符串的函数
    commandline:string[]|string|(()=&gt;string); 
} 
 
// commandline 是字符串
var options:RunOptions = {program:&quot;test1&quot;,commandline:&quot;Hello&quot;}; 
console.log(options.commandline)  
 
// commandline 是字符串数组
options = {program:&quot;test1&quot;,commandline:[&quot;Hello&quot;,&quot;World&quot;]}; 
console.log(options.commandline[0]); 
console.log(options.commandline[1]);  
 
// commandline 是一个函数表达式
options = {program:&quot;test1&quot;,commandline:()=&gt;{return &quot;**Hello World**&quot;;}}; 
 
var fn:any = options.commandline; 
console.log(fn());
</code></pre>
<p>接口中可以为数组的 index 和 content 设置类型</p>
<pre><code class="language-typescript">interface ages { 
   [index:string]:number 
} 
 
var agelist:ages; 
 // 类型正确 
agelist[&quot;runoob&quot;] = 15  
 
// 类型错误，输出  error TS2322: Type '&quot;google&quot;' is not assignable to type 'number'.
// agelist[2] = &quot;google&quot;
</code></pre>
<h3 id="接口继承"><a class="header" href="#接口继承">接口继承</a></h3>
<p>接口可以通过其他接口来扩展自己，可以继承多个接口，使用 <code>extends</code> 语句</p>
<pre><code class="language-typescript">interface Person { 
   age:number 
} 

// Musician 继承了 Person 接口，有 Person 接口的所有 methods 和 attribute
interface Musician extends Person { 
   instrument:string 
} 
 
var drummer = &lt;Musician&gt;{}; 
drummer.age = 27 
drummer.instrument = &quot;Drums&quot; 
console.log(&quot;年龄:  &quot;+drummer.age)
console.log(&quot;喜欢的乐器:  &quot;+drummer.instrument)
</code></pre>
<p>允许多继承：</p>
<pre><code class="language-typescript">interface IParent1 { 
    v1:number 
} 
 
interface IParent2 { 
    v2:number 
} 
 
interface Child extends IParent1, IParent2 { } 
var Iobj:Child = { v1:12, v2:23} 
console.log(&quot;value 1: &quot;+Iobj.v1+&quot; value 2: &quot;+Iobj.v2)
</code></pre>
<h2 id="class-类"><a class="header" href="#class-类">Class 类</a></h2>
<p>Class 类是对象的构造器：与 JS 的使用方法相同</p>
<pre><code class="language-typescript">class Car { 
   // 字段
   engine:string; 
   
   // 构造函数
   constructor(engine:string) { 
      this.engine = engine 
   }  
   
   // 方法
   disp():void { 
      console.log(&quot;函数中显示发动机型号  :   &quot;+this.engine) 
   } 
} 
 
// 创建一个对象
var obj = new Car(&quot;XXSY1&quot;)
 
// 访问字段
console.log(&quot;读取发动机型号 :  &quot;+obj.engine)  
 
// 访问方法
obj.disp()
</code></pre>
<p>类的继承：</p>
<pre><code class="language-typescript">class Shape { 
   Area:number // 指定 attribute 的 type
   
   constructor(a:number) { 
      this.Area = a 
   } 
} 
 
class Circle extends Shape { 
   disp():void { 
      console.log(&quot;圆的面积:  &quot;+this.Area) 
   } 
}
  
var obj = new Circle(223); 
obj.disp()
</code></pre>
<p>需要注意的是 <strong>子类只能继承一个父类</strong>，TypeScript <strong>不支持继承多个类</strong>，但支持多重继承：</p>
<pre><code class="language-typescript">class Root { 
   str:string; 
} 
 
class Child extends Root {} 
class Leaf extends Child {} // 多重继承，继承了 Child 和 Root 类
 
var obj = new Leaf(); 
obj.str =&quot;hello&quot; 
console.log(obj.str)
</code></pre>
<p>static 静态 methods 、attribute，可直接通过类名来调用，不需要 <code>New</code></p>
<pre><code class="language-typescript">class StaticMem {  
   static num:number; 
   
   static disp():void { 
      console.log(&quot;num 值为 &quot;+ StaticMem.num) 
   } 
} 
 
StaticMem.num = 12     // 初始化静态变量
StaticMem.disp()       // 调用静态方法
</code></pre>
<p>instanceof [/ˈɪnstəns/] 运算符，用于判断对象是否为指定类：</p>
<pre><code class="language-typescript">class Person{ } 
var obj = new Person() 
var isPerson = obj instanceof Person; 
console.log(&quot;obj 对象是 Person 类实例化来的吗？ &quot; + isPerson);
</code></pre>
<p>类的访问控制：</p>
<ul>
<li><strong>public（默认）</strong> : 公有，可以在任何地方被访问。</li>
<li><strong>protected</strong> : 受保护，可以被其 <strong>自身</strong> 以及其 <strong>子类</strong> 访问。</li>
<li><strong>private</strong> : <strong>私有</strong>，只能被其定义所在的类访问。</li>
</ul>
<pre><code class="language-typescript">class Encapsulate { 
   str1:string = &quot;hello&quot; 
   private str2:string = &quot;world&quot; 
}
 
var obj = new Encapsulate() 
console.log(obj.str1)     // 可访问 
console.log(obj.str2)   // 编译错误， str2 是私有的

</code></pre>
<h3 id="类实现接口"><a class="header" href="#类实现接口">类实现接口</a></h3>
<p><strong>对象实现接口。类是对象的构造器。</strong></p>
<p>使用 implements [英 /ˈɪmplɪment/ vt. 使生效 n.用具] 关键字</p>
<pre><code class="language-typescript">interface ILoan { 
   interest:number 
} 
 
class AgriLoan implements ILoan { 
   interest:number 
   rebate:number 
   
   constructor(interest:number,rebate:number) { 
      this.interest = interest 
      this.rebate = rebate 
   } 
} 
 
var obj = new AgriLoan(10,1) 
console.log(&quot;利润为 : &quot;+obj.interest+&quot;，抽成为 : &quot;+obj.rebate )
</code></pre>
<h2 id="dock-typing-鸭子类型"><a class="header" href="#dock-typing-鸭子类型">Dock Typing 鸭子类型</a></h2>
<p>鸭子类型（英语：duck typing）是动态类型的一种风格，是多态 (polymorphism [英 /ˌpɒlɪ'mɔːfɪz(ə)m/]) 的一种形式。</p>
<blockquote>
<p>&quot; 当看到一只鸟 <strong>走</strong> 起来像鸭子、<strong>游泳</strong> 起来像鸭子、<strong>叫</strong> 起来也像鸭子，那么这只鸟就可以被称为 <strong>鸭子</strong>。&quot; ——《落落前传》</p>
</blockquote>
<p>在 <strong>鸭子类型</strong> 中，关注的是 object 的 方法 <code>methods</code> ，而不是 object 的类型。<br />
换言之如果一个类型 A 实现了 <code>run()</code> 和 <code>eat()</code> 的方法（即实现了行为接口）就可以通过接口类型调用这个方法，<strong>不需要知道类型是什么</strong>。</p>
<pre><code class="language-typescript">interface IPoint { 
    x:number 
    y:number 
} 
// p1： 实现了 IPoint 接口的对象，即有 x,y 两个 parameter
function addPoints(p1:IPoint,p2:IPoint):IPoint { 
    var x = p1.x + p2.x 
    var y = p1.y + p2.y 
    return {x:x, y:y} 
} 
 
// 正确
var newPoint = addPoints({x:3,y:4},{x:5,y:1})  
 
// 错误 
var newPoint2 = addPoints({x:1},{x:4,y:3})

</code></pre>
<h2 id="命名空间"><a class="header" href="#命名空间">命名空间</a></h2>
<p>命名空间可以解决重复命名的问题。</p>
<pre><code class="language-typescript">// 定义了一个命名空间 SomeNameSpaceName
namespace SomeNameSpaceName { 
   // export 用于在外部导入 SomeNameSpaceName 中的类和接口
   export interface ISomeInterfaceName {      }  
   export class SomeClassName {      }  
}
</code></pre>
<h2 id="module-模块"><a class="header" href="#module-模块">Module 模块</a></h2>
<ol>
<li>可以更改的组织代码</li>
<li>模块在自身的作用域执行，定义在模块里面的变量、函数和类在外部是不可见的，除非使用 <code>export</code> 导出，并在外部使用 <code>import</code> 导入。</li>
</ol>
<p>SomeInterFace.ts</p>
<pre><code class="language-typescript">// 使用 export 导出
export interface SomeInterface { 
   // 代码部分
}
</code></pre>
<p>mian.ts</p>
<pre><code class="language-typescript">// 使用 import 导入
import someInterfaceRef = require(&quot;./SomeInterface&quot;);
</code></pre>
<p>使用 tsc 编译代码：</p>
<pre><code class="language-typescript">tsc --module amd main.ts
// 或者
tsc --module commonjs TestShape.ts
</code></pre>
<h2 id="end"><a class="header" href="#end">end</a></h2>
<p>至此，我应该了解了 <code>TypeScript</code> 这个语言的大概，继续学习 Vue 去了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="study-1"><a class="header" href="#study-1">Study</a></h1>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: 😭2021年广东数学中考体验
date: 2021-06-28 19:37:48
updated: 2021-06-28 19:37:48
categories: Study
tags: [Maths, Study]
description:
thumbnail: http://oss.whaleluo.top/blog/old/20210629014311.png
banner_img: http://oss.whaleluo.top/blog/old/20210629014311.png</p>
<hr />
<h1 id="2021-年广东数学中考体验"><a class="header" href="#2021-年广东数学中考体验">😭😭😭2021 年广东数学中考体验</a></h1>
<h2 id="个人感受"><a class="header" href="#个人感受">个人感受</a></h2>
<blockquote>
<p><strong>不请自来，这张试卷太气人了。这几个月刷了那么多道题，做了那么多练习，根本没什么卵用，考的都是什么奇奇怪怪的东西，选择题不知道第几题开始，人都傻了，那个秦九韶老师都没讲过，也没做过相关练习，还有就是证明圆相切，最后压轴题就真的气人！！！本来想着冲一波高分，现在别说高分，及格都不一定，一大堆没写完。</strong></p>
</blockquote>
<blockquote>
<p><strong>试题可以接地气，不可以接地府</strong>.</p>
</blockquote>
<blockquote>
<p><strong>“出题人是神经病”</strong></p>
</blockquote>
<blockquote>
<p><strong>数学最后一题，深圳 18 年高三一模原题</strong></p>
</blockquote>
<p><img src="http://oss.whaleluo.top/blog/old/20210629023311.jpeg-picsmall" alt="img" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210629023333.jpeg-picsmall" alt="img" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210629023357.jpeg-picsmall" alt="img" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210629023434.jpeg-picsmall" alt="img" /></p>
<hr />
<p><strong>好吧。当我见到答题卡的时候，简单的图形，没有圆，尺规作图在第二十题（因为那里是个孤零零的直角三角形），二十四题貌似是个手拉手，二十五题没有图。</strong></p>
<p>等到试卷发下来，通览全卷，问题感觉不大。考试开始…..</p>
<p><strong>发下答题卡，25 没图？？？24 没圆？？？</strong></p>
<p>我察觉到了<strong>危险</strong>。</p>
<p>发下试卷，翻到最后，25 最后一小问平行<strong>四边形存在性问题</strong>，还好是<strong>送分</strong>。</p>
<p>问题是第一问是什么？！二次不等式？！</p>
<p>我深吸一口气，决定这次做快点。</p>
<p>翻回去，考前五分钟做会选择。</p>
<p>第三题概率是我做<strong>概率选择题最久的一题</strong>（因为一般都是在几个中选几个，这次绕了点），这足以说明试卷的水平不简单。</p>
<p>第九题<strong>海伦公式</strong>,听说过,不会写,跳!</p>
<p>第十题类型题我刷过，那个 AB 会过定点，<strong>辅助线是三垂直</strong>，但是没有记的情况是定点 (0,1)，当时为了赶时间（<strong>别问为什么这么赶</strong>，只有 90 分钟啊，90 分钟！！！）我跳了这题。</p>
<p><strong>第十五题</strong>为什么不是 $x^{2}+\frac{1}{x^{2}}$ 而是 $x^{2}-\frac{1}{x^{2}}$<br />
完了，<strong>硬算很费时间</strong>，跳了。</p>
<p>第十六题<strong>暴力三角函数相似勾股</strong>，有点费。但是算对了.</p>
<p>第十七题，<strong>定弦对等角出隐圆</strong>，作等腰直角三角形顶点就是圆心，<del>挺简单的</del>。</p>
<p>到大题了，第十八题居然<strong>不是算术</strong>，感觉不对劲。</p>
<p>第二十一题做着感觉没问题，出答案的时候 k 值有两个？！完了我<strong>漏解没了</strong>。。。</p>
<p>当我做<strong>二十三折叠题</strong>的时候，抬了下头，不到 30 分钟了？？？！！！</p>
<p>不行了，后面还有道证明题，这折叠题算了,写了几个<strong>可能的步骤</strong>.跳!</p>
<blockquote>
<p>时间还剩 20 分钟……</p>
</blockquote>
<p>证明题二十四题<strong>第一问还行，送分</strong>。</p>
<p>第二问我圆呢？自己作？算了这题跳了，<strong>写下取 AD 中点 M，设半径，不知道有没有分</strong>。</p>
<p>第三问我标了下长度，发现了三角形的<strong>面积</strong>可以通过<strong>等积变形</strong>转换,又有两个<strong>三角函数</strong>,求出<strong>底和高</strong>,搞定!。</p>
<blockquote>
<p>时间还剩<strong>10 分钟</strong>左右…</p>
</blockquote>
<p>最后一道压轴题，<strong>第一问我满脸问号？？？这什么玩意儿？？</strong></p>
<p>我求下导，画下草图，这形式有点像<strong>夹逼定理</strong>！（只是<strong>看着像而已</strong>）</p>
<p>一番惊奇过后，我认真思考下，要求不等式<strong>两边函数的切点</strong>，我求了，然后满脑空白，<strong>不知道接下来要做什么。。。</strong></p>
<p>抬头看了时间，<strong>我苦笑了下，五分钟不到了。</strong></p>
<p>于是我就开始<strong>蒙 a 的值</strong>，太大怕和上面的抛物线相交，太小又怕和下面那条直线相交。</p>
<p>我痛定思痛，<strong>就蒙 a=2（然而答案是 1）</strong>，把抛物线求了出来，仅此而已。</p>
<p><strong>我跳回去，选择第十题蒙 C</strong>（答案是 A，而且图里也没有 30° 之类的东西，不可能出现这种数，大意了，但都快要收卷了谁还会管呀），填空<strong>第十五题蒙了</strong>。</p>
<blockquote>
<p><strong>打铃，收卷。</strong></p>
</blockquote>
<h2 id="网上看到的一个关于-广东中考-的段子"><a class="header" href="#网上看到的一个关于-广东中考-的段子">网上看到的一个关于 <code>广东中考</code> 的段子</a></h2>
<blockquote>
<p>我站在<strong>望北哨所</strong>，手里拿着<strong>红绸带</strong>，脑中思索着<strong>隐圆计算</strong>，收到了 2kg 荔枝，但是我只想吃<strong>豆沙粽</strong>和<strong>猪肉粽</strong>。恍惚间，我看到一辆跑车超速驶来，我连忙用<strong>超声波计算</strong>，制止了他的行为。我郑重的说:“ 先生，你这样不利于实现<strong>碳达峰和碳中和</strong>。他的眼中饱含泪水，注视着我，大喊一声:“这才是<strong>少年应有的模样</strong>!&quot;</p>
</blockquote>
<h2 id="2021-年-广东中考数学-今年-题目--解析"><a class="header" href="#2021-年-广东中考数学-今年-题目--解析"><strong>2021</strong> 年 <strong>广东中考数学</strong> (<strong>今年</strong>) 题目 + 解析</a></h2>
<p><img src="http://oss.whaleluo.top/blog/old/20210629015828.png-picsmall" alt="" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210629015859.png-picsmall" alt="img" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210629015950.png-picsmall" alt="img" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210629020000.png-picsmall" alt="img" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210629020011.png-picsmall" alt="img" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210629020026.png-picsmall" alt="img" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210629020045.png-picsmall" alt="img" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210629020057.png-picsmall" alt="img" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210629020109.png-picsmall" alt="img" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210629020123.png-picsmall" alt="img" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210629020134.png-picsmall" alt="img" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210629020207.png-picsmall" alt="img" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210629020229.png-picsmall" alt="img" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210629020320.png-picsmall" alt="img" /></p>
<blockquote>
<p>附: <strong>2020</strong>年 <strong>广东中考数学</strong> (去年的,对比一下)</p>
</blockquote>
<p><img src="http://oss.whaleluo.top/blog/old/20210629014918.jpg-picsmall" alt="第1页(共4页)" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210629014936.jpg-picsmall" alt="第2页(共4页)" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210629015036.jpg-picsmall" alt="第3页(共4页)" /></p>
<p><img src="http://oss.whaleluo.top/blog/old/20210629015051.jpeg-picsmall" alt="第4页(共4页)" /></p>
<div style="break-before: page; page-break-before: always;"></div><hr />
<p>title: 高二上期末考语文小抄
date: 2023-01-11 1:37:48
updated: 2023-01-11 1:37:48
categories: Study
tags: [Study, Chinese]
thumbnail:
banner_img:</p>
<hr />
<h1 id="高二上期末考语文小抄"><a class="header" href="#高二上期末考语文小抄">高二上期末考语文小抄</a></h1>
<h2 id="论语十二章"><a class="header" href="#论语十二章">论语十二章</a></h2>
<ol>
<li>子曰：“君子食无求饱，居无求安，敏于事而慎于言，就有道而正焉，可谓好学也已。”（《学而》）</li>
<li>子曰：“人而不仁，如礼何？ 人而不仁，如乐何？”(《八佾》)</li>
<li>子曰：“朝闻道，夕死可矣。”(《里仁》)</li>
<li>子曰：“君子喻于义，小人喻于利。”(《里仁》)</li>
<li>子曰：“见贤思齐焉，见不贤而内自省也。”(《里仁》)</li>
<li>子曰：“质胜文则野，文胜质则史。文质彬彬，然后君子。”(《雍也》)</li>
<li>曾子曰：“士不可以不弘毅，任重而道远。仁以为己任，不亦重乎？死而后已，不亦远乎？”(《泰伯》)</li>
<li>子曰：“譬如为山，未成一篑，止，吾止也。譬如平地，虽覆一篑，进，吾往也。”(《子罕》)</li>
<li>子曰：“知者不惑，仁者不忧，勇者不惧。”(《子罕》)</li>
<li>颜渊问仁。子曰：“克己复礼为仁。一日克己复礼，天下归仁焉。为仁由己，而由人乎哉？”颜渊曰：“请问其目。”子曰：“非礼勿视，非礼勿听，非礼勿言，非礼勿动。”颜渊曰：“回虽不敏，请事斯语矣。”(《颜渊》)</li>
<li>子贡问曰：“有一言而可以终身行之者乎？”子曰：“其‘恕’乎！己所不欲，勿施于人。”(《卫灵公》)</li>
<li>子曰：“小子何莫学夫《诗》？《诗》可以兴，可以观，可以群，可以怨。迩之事父，远之事君。多识于鸟兽草木之名。”(《阳货》)</li>
</ol>
<hr />
<p>翻译：</p>
<ol>
<li>孔子说：“做人如果没有仁爱之心，如何谈礼仪制度呢？做人如果没有仁爱之心，又从何谈音乐呢？”</li>
<li>孔子说：“早晨能够得知真理，即使当晚死去，也没有遗憾。”</li>
<li>孔子说：“君子通晓的是道义，小人只通晓利益。”</li>
<li>孔子说：“看见有才能的人（德才兼备的人）就向他学习，希望能向他看齐；看见不贤的人，就反省自己有没有和他一样的缺点，有要改正。”</li>
<li>孔子说：“质朴胜过了文饰就会粗野，文饰胜过了质朴就会虚浮，质朴和文饰比例恰当，然后才可以成为君子。”</li>
<li>曾子说：“士不可不志向远大，意志坚强，因为他肩负重大责任，路途漫长遥远。以实行仁道为己任，不是很重大的责任吗？直到身死才能结束，不是很漫长遥远的吗？”</li>
<li>孔子说：“譬如用土堆山，只差一筐土就完成了，这时停下来，那是我自己要停下来；譬如填平洼地，虽然只倒下一筐，这时虽然只有一筐，但我也在前进。”</li>
<li>孔子说：“聪明人不会迷惑，有仁德的人不会忧愁，勇敢的人不会畏惧。”</li>
<li>颜渊请教什么是仁。孔子说：“约束自己返归于周礼就是仁。一旦所有的人都约束自己返归于周礼，天下的人都会称赞你是仁人。对仁的追求完全取决于自己，难道还靠别人吗？”颜渊说：“请问具体的做法。”孔子说：“不合于礼的不要看，不合于礼的不要听，不合于礼的不要说，不合于礼的不要做。”颜渊说：“我虽然愚笨，也要照您的话去做。”</li>
<li>子贡问孔子问道：“有没有一个字可以终身奉行的呢？”孔子回答说：“那就是‘恕’吧！自己不喜欢的事物，不要强加于别人身上。”</li>
<li>孔子说：“学生们为什么没有人学《诗经》呢？《诗经》可以激发心志，可以观察政治的得失，风俗的盛衰，可以培养群体观念，可以学得讽刺方法。近则可以用其中的道理来侍奉父母；远可以用来侍奉君主，还可以多认识鸟兽草木的名称。”</li>
</ol>
<h2 id="大学之道礼记"><a class="header" href="#大学之道礼记">大学之道——《礼记》</a></h2>
<p>大学之道，在明明德，在亲民，在止于至善。知止而后有定，定而后能静，静而后能安，安而后能虑，虑而后能得。 物有本末，事有终始。知所先后，则近道矣。</p>
<p>古之欲明明德于天下者，先治其国。欲治其国者，先齐其家。欲齐其家者，先修其身。欲修其身者，先正其心。欲正其心者，先诚其意。欲诚其意者，先致其知。致知在格物。物格而后知至，知至而后意诚，意诚而后心正，心正而后身修，身修而后家齐，家齐而后国治，国治而后天下平。自天子以至于庶人，壹是皆以修身为本。</p>
<p>其本乱而末治者，否矣。其所厚者薄，而其所薄者厚，未之有也。此谓知本，此谓知之至也。</p>
<hr />
<p>翻译：大学的宗旨在于弘扬光明正大的品德，学习和应用于生活，使人达到最完善的境界。 知道应达到的境界才能够志向坚定；志向坚定才能够镇静不躁；镇静不躁才能使内心安定；心安理得才能够思虑周详；思虑周详才能够处事合宜。每一样东西都有根本有始末，每件事情都有开始有终结。明白了这本末始终的道理，就接近事物发展的规律了。 　</p>
<p>古代那些要想在天下弘扬光明正大品德的人，先要治理好自己的国家；要想治理好自己的国家，先要管理好自己的家庭和家族；要想管理好自己的家庭和家族，先要修养自身的品性；要想修养自身的品性，先要端正自己的心思；要想端正自己的心思，先要使自己的意念真诚；要想使自己的意念真诚，先要使自己获得知识；获得知识的途径在于认识、研究万事万物。通过对万事万物的认识、研究后才能获得知识；获得知识后意念才能真诚；意念真诚后心思才能端正；心思端正后才能修养品性；品性修养后才能管理好家庭和家族；管理好家庭和家族后才能治理好国家；治理好国家后天下才能太平。上至天子下至平民百姓，都应该以修养自身的品德为根本。 　</p>
<p>通过推究事物的原理，而彰显明德，认识本心，表里如一。意念才能真诚；意念真诚后心思才能端正；心思端正后才能修养品性；品性修养后才能管理好家庭和家族；管理好家庭和家族后才能治理好国家；治理好国家后天下才能太平。上自国家君王，下至平民百姓，人人都要以修养品性为根本。 　</p>
<p>若这个根本被扰乱了，家庭、家族、国家、天下要治理好是不可能的。不分轻重缓急、本末倒置却想做好事情，这也同样是不可能的！这就叫知道了根本，这就是认知的最高境界。</p>
<h2 id="人皆有不忍人之心孟子"><a class="header" href="#人皆有不忍人之心孟子">人皆有不忍人之心《孟子》</a></h2>
<p>　　孟子曰：“人皆有不忍人之心。先王有不忍人之心，斯有不忍人之政矣；以不忍人之心，行不忍人之政，治天下可运之掌上。所以谓人皆有不忍人之心者：今人乍见孺子将入于井，皆有怵惕恻隐之心；非所以内交于孺子之父母也，非所以要誉于乡党朋友也，非恶其声而然也。由是观之，无恻隐之心，非人也；无羞恶之心，非人也；无辞让之心，非人也；无是非之心，非人也。恻隐之心，仁之端也；羞恶之心，义之端也；辞让之心，礼之端也；是非之心，智之端也。人之有是四端也，犹其有四体也。有是四端而自谓不能者，自贼者也；谓其君不能者，贼其君者也。凡有四端于我者，知皆扩而充之矣，若火之始然，泉之始达。苟能充之，足以保四海；苟不充之，不足以事父母。”</p>
<hr />
<p>翻译：孟子说：“每个人都有怜悯体恤别人的心情。古代圣王由于怜悯体恤别人的心情，所以才有怜悯体恤百姓的政治。用怜悯体恤别人的心情，施行怜悯体恤百姓的政治，治理天下就可以像在手掌心里面运转东西一样容易了。之所以说每个人都有怜悯体恤别人的心情，是因为，如果今天有人突然看见一个小孩要掉进井里面去了，必然会产生惊惧同情的心理——这不是因为要想去和这孩子的父母拉关系，不是因为要想在乡邻朋友中博取声誉，也不是因为厌恶这孩子的哭叫声才产生这种惊惧同情心理的。由此看来，没有同情心，简直不是人；没有羞耻心，简直不是人；没有谦让心，简直不是人；没有是非心，简直不是人。同情心是仁的发端；羞耻心是义的发端；谦让心是礼的发端；是非心是智的发端。人有这四种发端，就像有四肢一样。有了这四种发端却自认为不行的，是自暴自弃的人；认为他的君主不行的，是暴弃君主的人。凡是有这四种发端的人，都知道要扩大充实它们，就像火刚刚开始燃烧，泉水刚刚开始流淌。如果能够扩充它们，便足以安定天下，如果不能够扩充它们，就连赡养父母都成问题。”</p>
<h2 id="选必一-古诗词诵读"><a class="header" href="#选必一-古诗词诵读">选必一 古诗词诵读</a></h2>
<h3 id="无衣"><a class="header" href="#无衣">无衣</a></h3>
<p>岂曰无衣？与子同袍。王于兴师，修我戈矛，与子同仇！<br />
岂日无衣？与子同泽。王于兴师，修我矛戟，与子偕作！<br />
岂日无衣？与子同裳。王于兴师，修我甲兵，与子偕行！</p>
<h3 id="春江花月夜-张若虚"><a class="header" href="#春江花月夜-张若虚">春江花月夜 张若虚</a></h3>
<p>春江潮水连海平，海上明月共潮生。<br />
滟滟随波千万里，何处春江无月明！<br />
江流宛转绕芳甸，月照花林皆似霰。<br />
空里流霜不觉飞，汀上白沙看不见。<br />
江天一色无纤尘，皎皎空中孤月轮。<br />
江畔何人初见月？江月何年初照人？<br />
人生代代无穷已，江月年年望相似。<br />
不知江月待何人，但见长江送流水。<br />
白云一片去悠悠，青枫浦上不胜愁。<br />
谁家今夜扁舟子？何处相思明月楼？<br />
可怜楼上月裴回，应照离人妆镜台。<br />
玉户帘中卷不去，捣衣砧上拂还来。<br />
此时相望不相闻，愿逐月华流照君。<br />
鸿雁长飞光不度，鱼龙潜跃水成文。<br />
昨夜闲潭梦落花，可怜春半不还家。<br />
江水流春去欲尽，江潭落月复西斜。<br />
斜月沉沉藏海雾，碣石潇湘无限路。<br />
不知乘月几人归，落月摇情满江树。</p>
<h3 id="将进酒-唐-李白"><a class="header" href="#将进酒-唐-李白">将进酒 唐 李白</a></h3>
<p>君不见黄河之水天上来，奔流到海不复回。<br />
君不见高堂明镜悲白发，朝如青丝暮成雪。<br />
人生得意须尽欢，莫使金樽空对月。<br />
天生我材必有用，千金散尽还复来。<br />
烹羊宰牛且为乐，会须一饮三百杯。<br />
岑夫子，丹丘生，将进酒，杯莫停。<br />
与君歌一曲，请君为我倾耳听。<br />
钟鼓馔玉不足贵，但愿长醉不愿醒。<br />
古来圣贤皆寂寞，惟有饮者留其名。<br />
陈王昔时宴平乐，斗酒十千恣欢谑。<br />
主人何为言少钱，径须沽取对君酌。<br />
五花马、千金裘，呼儿将出换美酒，与尔同销万古愁。</p>
<h3 id="江城子乙卯正月二十日夜记梦-宋-苏轼"><a class="header" href="#江城子乙卯正月二十日夜记梦-宋-苏轼">江城子·乙卯正月二十日夜记梦 宋 苏轼</a></h3>
<p>十年生死两茫茫，不思量，自难忘。千里孤坟，无处话凄凉。纵使相逢应不识，尘满面，鬓如霜。</p>
<p>夜来幽梦忽还乡，小轩窗，正梳妆。相顾无言，惟有泪千行。料得年年肠断处，明月夜，短松冈。</p>
<h2 id="选必二古诗词诵读"><a class="header" href="#选必二古诗词诵读">选必二古诗词诵读</a></h2>
<h3 id="燕歌行并序-高适"><a class="header" href="#燕歌行并序-高适">燕歌行并序 高适</a></h3>
<p>汉家烟尘在东北，汉将辞家破残贼。<br />
男儿本自重横行，天子非常赐颜色。<br />
摐金伐鼓下榆关，旌旗逶迤碣石间。<br />
校尉羽书飞瀚海，单于猎火照狼山。<br />
山川萧条极边土，胡骑凭陵杂风雨。<br />
战士军前半死生，美人帐下犹歌舞。<br />
大漠穷秋塞草腓，孤城落日斗兵稀。<br />
身当恩遇常轻敌，力尽关山未解围。<br />
铁衣远戍辛勤久，玉筋应啼别离后。<br />
少妇城南欲断肠，征人蓟北空回首。<br />
边风飘飘那可度，绝域苍茫更何有。<br />
杀气三时作阵云，寒声一夜传刁斗。<br />
相看白刃血纷纷，死节从来岂顾勋。<br />
君不见沙场征战苦，至今犹忆李将军。</p>
<h3 id="李凭箜篌引-李贺"><a class="header" href="#李凭箜篌引-李贺">李凭箜篌引 李贺</a></h3>
<p>吴丝蜀桐张高秋，空山凝云颓不流。<br />
江娥啼竹素女愁，李凭中国弹箜篌。<br />
昆山玉碎凤凰叫，芙蓉泣露香兰笑。<br />
十二门前融冷光，二十三丝动紫皇。<br />
女娲炼石补天处，石破天惊逗秋雨。<br />
梦入神山教神妪，老鱼跳波瘦蛟舞。<br />
吴质不眠倚桂树，露脚斜飞湿寒兔。</p>
<h3 id="锦瑟-李商隐"><a class="header" href="#锦瑟-李商隐">锦瑟 李商隐</a></h3>
<p>锦瑟无端五十弦，一弦一柱思华年。<br />
庄生晓梦迷蝴蝶，望帝春心托杜鹃。<br />
沧海月明珠有泪，蓝田日暖玉生烟。<br />
此情可待成追忆，只是当时已惘然。</p>
<h3 id="书愤-陆游"><a class="header" href="#书愤-陆游">书愤 陆游</a></h3>
<p>早岁那知世事艰，中原北望气如山。<br />
楼船夜雪瓜洲渡，铁马秋风大散关。<br />
塞上长城空自许，镜中衰鬓已先斑。<br />
出师一表真名世，千载谁堪伯仲间！</p>
<h2 id="老子四章"><a class="header" href="#老子四章">老子四章</a></h2>
<ol>
<li>三十辐共一毂，当其无，有车之用。埏埴以为器，当其无，有器之用。凿户牖以为室，当其无，有室之用。故有之以为利，无之以为用。</li>
<li>企者不立，跨者不行，自见者不明，自是者不彰，自伐者无功，自矜者不长。其在道也，曰余食赘行，物或恶之。故有道者不处。</li>
<li>知人者智，自知者明。胜人者有力，自胜者强。知足者富，强行者有志。不失其所者久，死而不亡者寿。</li>
<li>其安易持，其未兆易谋，其脆易泮，其微易散。为之于未有，治之于未乱。合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。为者败之，执者失之。是以圣人无为，故无败；无执，故无失。民之从事，常于几成而败之。慎终如始，则无败事。是以圣人欲不欲，不贵难得之货，学不学，复众人之所过，以辅万物之自然而不敢为。</li>
</ol>
<hr />
<p>翻译：</p>
<ol>
<li>三十根辐条汇集到一根毂中的孔洞当中，有了车毂中空的地方，才有车的作用。揉和陶土做成器皿，有了器具中空的地方，才有器皿的作用。开凿门窗建造房屋，有了门窗四壁内的空虚部分，才有房屋的作用。所以，“有”给人便利，“无”发挥了它的作用。</li>
<li>踮踮着脚跟的人站不牢，跨步行的人走不远，(就好像) 自逞己见的人反而不能明理，自以为是的人则是非不明，自我炫耀功劳的人反而不能成就大功，自尊自大的人反而得不到敬重。用道的观点来看，是吃剩下的食物或身体上的肉瘤，众人常常厌恶这些。所以有道的人是绝不会这样做的。</li>
<li>了解别人的人聪明，了解自己的人圣明。战胜别人的人有力量，战胜自己的人刚强。知道满足的人就是富人。确定不移、竭力实行的人有意志。不丧失合适位置的人能够长久。死而不朽的人就是长寿。</li>
<li>局面安定时容易保持和维护，事变没有出现迹象时容易图谋；事物脆弱时容易消解；事物细微时容易散失；做事情要在它尚未发生以前就处理妥当；治理国政，要在祸乱没有产生以前就早做准备。合抱的大树，生长于细小的萌芽；九层的高台，筑起于每一堆泥土；千里的远行，是从脚下第一步开始走出来的。有所作为的将会招致失败，有所执着的将会遭受损害。因此圣人无所作为所以也不会招致失败，无所执着所以也不遭受损害。人们做事情，总是在快要成功时失败，所以当事情快要完成的时候，也要像开始时那样慎重，就没有办不成的事情。因此，有道的圣人追求人所不追求的，不稀罕难以得到的货物，学习别人所不学习的，补救众人所经常犯的过错。这样遵循万物的自然本性而不会妄加干预。”</li>
</ol>
<h2 id="报任安书-司马迁"><a class="header" href="#报任安书-司马迁">报任安书 司马迁</a></h2>
<p>古者富贵而名摩灭，不可胜记，唯倜傥非常之人称焉。盖文王拘而演《周易》；仲尼厄而作《春秋》；屈原放逐，乃赋《离骚》；左丘失明，厥有《国语》；孙子膑脚，《兵法》修列；不韦迁蜀，世传《吕览》；韩非囚秦，《说难》《孤愤》；《诗》三百篇，大底圣贤发愤之所为作也。此人皆意有所郁结，不得通其道，故述往事、思来者。乃如左丘无目，孙子断足，终不可用，退而论书策，以舒其愤，思垂空文以自见。</p>
<p>仆窃不逊，近自托于无能之辞，网罗天下放失旧闻，略考其行事，综其终始，稽其成败兴坏之纪，上计轩辕，下至于兹，为十表，本纪十二，书八章，世家三十，列传七十，凡百三十篇。亦欲以究天人之际，通古今之变，成一家之言。草创未就，会遭此祸，惜其不成，是以就极刑而无愠色。仆诚以著此书，藏之名山，传之其人，通邑大都，则仆偿前辱之责，虽万被戮，岂有悔哉！然此可为智者道，难为俗人言也！</p>
<hr />
<p>翻译：古时候，富贵而湮没不闻的人数不胜数，多得数不清，只有那些不为世俗所拘的卓异之士才能见称于后世。西伯姬昌被拘禁而扩写《周易》；孔子受困窘而作《春秋》；屈原被放逐，才写了《离骚》；左丘明失去视力，才有《国语》。孙膑被截去膝盖骨，《兵法》才撰写出来；吕不韦被贬谪蜀地，后世才能流传《吕氏春秋》；韩非被囚禁在秦国，写出《说难》、《孤愤》；《诗》三百篇，大都是一些圣贤们抒发愤懑而写作的。这些都是人们感情有压抑郁结不解的地方，不能实现其理想，所以记述过去的事迹，让将来的人了解他的志向。就像左丘明没有了视力，孙膑断了双脚，终生不能被人重用，便退隐著书立说来抒发他们的怨愤，想到活下来从事著作来表现自己的思想。</p>
<p>我私下里也自不量力，近来用我那不高明的文辞，收集天下散失的历史传闻，粗略地考订其事实，综述其事实的本末，推究其成败盛衰的道理，上自黄帝，下至于当今，写成十篇表，十二篇本纪，八篇书，三十篇世家，七十篇列传，一共一百三十篇，也是想探求天道与人事之间的关系，贯通古往今来变化的脉络，成为一家之言。刚开始草创还没有完毕，恰恰遭遇到这场灾祸，我痛惜这部书不能完成，因此便接受了最残酷的刑罚而不敢有怒色。我现在真正的写完了这部书，打算把它藏进名山，传给可传的人，再让它流传进都市之中，那么，我便抵偿了以前所受的侮辱，即便是让我千次万次地被侮辱，又有什么后悔的呢！然而这些话只能对智者去说，却很难向世俗之人讲清楚啊！</p>
<h2 id="大道之行也礼记"><a class="header" href="#大道之行也礼记">大道之行也《礼记》</a></h2>
<p>大道之行也，天下为公。选贤与能，讲信修睦。故人不独亲其亲，不独子其子，使老有所终，壮有所用，幼有所长，矜、寡、孤、独、废疾者皆有所养，男有分，女有归。货恶其弃于地也，不必藏于己；力恶其不出于身也，不必为己。是故谋闭而不兴，盗窃乱贼而不作，故外户而不闭。是谓大同。</p>
<hr />
<p>翻译：大道在天下实行时，把天下作为大家所共有的，把品德高尚的人、能干的人选拔出来。人们都讲求诚信，培养和睦的气氛。因此人们不只是把自己的父母当做父母，把自己的孩子当做孩子，让老人能够终其天年，成年人能够为社会效力，年幼的人能够顺利地成长。使老而无妻的人、老而无夫的人、幼而无父的人、老而无子的人、残疾人都能得到供养。男子有职务，女子有归宿。对于财货，人们都憎恨把它扔在地上的行为，却不一定要自己私藏。人们都愿意为公众之事竭尽全力，而不一定为自己谋私利。因此，奸邪之谋不会发生，盗窃、造反和害人的事情不发生，家家户户都不用关大门了。这就是理想社会。</p>
<h2 id="山居秋瞑-王维"><a class="header" href="#山居秋瞑-王维">山居秋瞑 王维</a></h2>
<p>空山新雨后，天气晚来秋。<br />
明月松间照，清泉石上流。<br />
竹喧归浣女，莲动下渔舟。<br />
随意春芳歇，王孙自可留。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
