<!DOCTYPE HTML>
<html lang="cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Python-async - WhaleFall Obsidian Notes</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Keep Notes everyday">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../../favicon.svg">
        <link rel="shortcut icon" href="../../../favicon.png">
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        <link rel="stylesheet" href="../../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../../index.html"><strong aria-hidden="true">1.</strong> 落落的Notes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../SUMMARY.html"><strong aria-hidden="true">1.1.</strong> SUMMARY</a></li><li class="chapter-item expanded "><a href="../../../test/index.html"><strong aria-hidden="true">1.2.</strong> test</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../test/落落-OpenWRT-导航页.html"><strong aria-hidden="true">1.2.1.</strong> 落落-OpenWRT-导航页</a></li><li class="chapter-item expanded "><a href="../../../test/思源笔记自动同步测试.html"><strong aria-hidden="true">1.2.2.</strong> 思源笔记自动同步测试</a></li><li class="chapter-item expanded "><a href="../../../test/Obsidian-Hexo-模板测试.html"><strong aria-hidden="true">1.2.3.</strong> Obsidian-Hexo-模板测试</a></li></ol></li><li class="chapter-item expanded "><a href="../../../高中事件/index.html"><strong aria-hidden="true">1.3.</strong> 高中事件</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../高中事件/举报信.html"><strong aria-hidden="true">1.3.1.</strong> 举报信</a></li><li class="chapter-item expanded "><a href="../../../高中事件/举报中小学教师违规方法论.html"><strong aria-hidden="true">1.3.2.</strong> 举报中小学教师违规方法论</a></li><li class="chapter-item expanded "><a href="../../../高中事件/举报法律依据.html"><strong aria-hidden="true">1.3.3.</strong> 举报法律依据</a></li></ol></li><li class="chapter-item expanded "><a href="../../../博客文章/index.html"><strong aria-hidden="true">1.4.</strong> 博客文章</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../博客文章/博客文章_post.html"><strong aria-hidden="true">1.4.1.</strong> 博客文章_post</a></li><li class="chapter-item expanded "><a href="../../../博客文章/博客文章测试.html"><strong aria-hidden="true">1.4.2.</strong> 博客文章测试</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/index.html"><strong aria-hidden="true">1.4.3.</strong> _posts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../博客文章/_posts/onedrive-guide.html"><strong aria-hidden="true">1.4.3.1.</strong> onedrive-guide</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Samba4-config.html"><strong aria-hidden="true">1.4.3.2.</strong> Samba4-config</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Depression-medicine.html"><strong aria-hidden="true">1.4.3.3.</strong> Depression-medicine</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/clash-proxy-guide.html"><strong aria-hidden="true">1.4.3.4.</strong> clash-proxy-guide</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Kali-Linux-Help.html"><strong aria-hidden="true">1.4.3.5.</strong> Kali-Linux-Help</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/how-to-ues-free-ChatGPT-in-China.html"><strong aria-hidden="true">1.4.3.6.</strong> how-to-ues-free-ChatGPT-in-China</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/radio-SWshort.html"><strong aria-hidden="true">1.4.3.7.</strong> radio-SWshort</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Wky-help.html"><strong aria-hidden="true">1.4.3.8.</strong> Wky-help</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Freedom-network.html"><strong aria-hidden="true">1.4.3.9.</strong> Freedom-network</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/openwebrx-sdr.html"><strong aria-hidden="true">1.4.3.10.</strong> openwebrx-sdr</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Linux-note.html"><strong aria-hidden="true">1.4.3.11.</strong> Linux-note</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Vim-config.html"><strong aria-hidden="true">1.4.3.12.</strong> Vim-config</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Server-all.html"><strong aria-hidden="true">1.4.3.13.</strong> Server-all</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Hexo-blog-format.html"><strong aria-hidden="true">1.4.3.14.</strong> Hexo-blog-format</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/openwrt-lede-build-notes.html"><strong aria-hidden="true">1.4.3.15.</strong> openwrt-lede-build-notes</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Linux-iptables.html"><strong aria-hidden="true">1.4.3.16.</strong> Linux-iptables</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Github-workflow.html"><strong aria-hidden="true">1.4.3.17.</strong> Github-workflow</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Rpi-1.html"><strong aria-hidden="true">1.4.3.18.</strong> Rpi-1</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/cpp-guide-book.html"><strong aria-hidden="true">1.4.3.19.</strong> cpp-guide-book</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Rpi-2.html"><strong aria-hidden="true">1.4.3.20.</strong> Rpi-2</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Rpi-3.html"><strong aria-hidden="true">1.4.3.21.</strong> Rpi-3</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Python/index.html"><strong aria-hidden="true">1.4.3.22.</strong> Python</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Python/Flask-Web-note.html"><strong aria-hidden="true">1.4.3.22.1.</strong> Flask-Web-note</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Python/Python-Generator-Iterator-decorater.html"><strong aria-hidden="true">1.4.3.22.2.</strong> Python-Generator-Iterator-decorater</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Python/Python-async.html" class="active"><strong aria-hidden="true">1.4.3.22.3.</strong> Python-async</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Python/Python-Tkinter-GUI.html"><strong aria-hidden="true">1.4.3.22.4.</strong> Python-Tkinter-GUI</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Python/Python-Concurrent.html"><strong aria-hidden="true">1.4.3.22.5.</strong> Python-Concurrent</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Python/python-black-magic.html"><strong aria-hidden="true">1.4.3.22.6.</strong> python-black-magic</a></li></ol></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Golang/index.html"><strong aria-hidden="true">1.4.3.23.</strong> Golang</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Golang/Golang-id-note.html"><strong aria-hidden="true">1.4.3.23.1.</strong> Golang-id-note</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Golang/Golang-interface-note.html"><strong aria-hidden="true">1.4.3.23.2.</strong> Golang-interface-note</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Golang/Golang-method-note.html"><strong aria-hidden="true">1.4.3.23.3.</strong> Golang-method-note</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Golang/Golang-struct-note.html"><strong aria-hidden="true">1.4.3.23.4.</strong> Golang-struct-note</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Golang/Golang-datatype-note.html"><strong aria-hidden="true">1.4.3.23.5.</strong> Golang-datatype-note</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Golang/Golang-variable-note.html"><strong aria-hidden="true">1.4.3.23.6.</strong> Golang-variable-note</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Golang/Golang-error-note.html"><strong aria-hidden="true">1.4.3.23.7.</strong> Golang-error-note</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Golang/Golang-goruntine-note.html"><strong aria-hidden="true">1.4.3.23.8.</strong> Golang-goruntine-note</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Golang/Golang-HTML-note.html"><strong aria-hidden="true">1.4.3.23.9.</strong> Golang-HTML-note</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Golang/Golang-package-note.html"><strong aria-hidden="true">1.4.3.23.10.</strong> Golang-package-note</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Golang/Golang-project-and-gomod-note.html"><strong aria-hidden="true">1.4.3.23.11.</strong> Golang-project-and-gomod-note</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Golang/Golang-pointer-note.html"><strong aria-hidden="true">1.4.3.23.12.</strong> Golang-pointer-note</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Golang/Golang-type-keyword-note.html"><strong aria-hidden="true">1.4.3.23.13.</strong> Golang-type-keyword-note</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Golang/Golang-map-note.html"><strong aria-hidden="true">1.4.3.23.14.</strong> Golang-map-note</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Golang/Golang-function-note.html"><strong aria-hidden="true">1.4.3.23.15.</strong> Golang-function-note</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Golang/Golang-const-note.html"><strong aria-hidden="true">1.4.3.23.16.</strong> Golang-const-note</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Golang/Golang-JSON-note.html"><strong aria-hidden="true">1.4.3.23.17.</strong> Golang-JSON-note</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Golang/Golang-note-catalogue.html"><strong aria-hidden="true">1.4.3.23.18.</strong> Golang-note-catalogue</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Golang/Golang-envbuild-note.html"><strong aria-hidden="true">1.4.3.23.19.</strong> Golang-envbuild-note</a></li></ol></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Study/index.html"><strong aria-hidden="true">1.4.3.24.</strong> Study</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Study/Zhongkao-maths.html"><strong aria-hidden="true">1.4.3.24.1.</strong> Zhongkao-maths</a></li><li class="chapter-item expanded "><a href="../../../博客文章/_posts/Study/Ancient-poems.html"><strong aria-hidden="true">1.4.3.24.2.</strong> Ancient-poems</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../../CutBoard/index.html"><strong aria-hidden="true">1.5.</strong> CutBoard</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../CutBoard/无线电爬取脚本.html"><strong aria-hidden="true">1.5.1.</strong> 无线电爬取脚本</a></li></ol></li><li class="chapter-item expanded "><a href="../../../业余无线电Ham/index.html"><strong aria-hidden="true">1.6.</strong> 业余无线电Ham</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../业余无线电Ham/业余无线电笔记.html"><strong aria-hidden="true">1.6.1.</strong> 业余无线电笔记</a></li><li class="chapter-item expanded "><a href="../../../业余无线电Ham/泉盛-K5-音质优化.html"><strong aria-hidden="true">1.6.2.</strong> 泉盛-K5-音质优化</a></li><li class="chapter-item expanded "><a href="../../../业余无线电Ham/广播.html"><strong aria-hidden="true">1.6.3.</strong> 广播</a></li><li class="chapter-item expanded "><a href="../../../业余无线电Ham/Opengd77-Firmware-教程.html"><strong aria-hidden="true">1.6.4.</strong> Opengd77-Firmware-教程</a></li><li class="chapter-item expanded "><a href="../../../业余无线电Ham/业余无线电采购.html"><strong aria-hidden="true">1.6.5.</strong> 业余无线电采购</a></li><li class="chapter-item expanded "><a href="../../../业余无线电Ham/通联日志.html"><strong aria-hidden="true">1.6.6.</strong> 通联日志</a></li><li class="chapter-item expanded "><a href="../../../业余无线电Ham/附近航空频率.html"><strong aria-hidden="true">1.6.7.</strong> 附近航空频率</a></li><li class="chapter-item expanded "><a href="../../../业余无线电Ham/广播/index.html"><strong aria-hidden="true">1.6.8.</strong> 广播</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../业余无线电Ham/广播/广播收听报告-2023.05.23.html"><strong aria-hidden="true">1.6.8.1.</strong> 广播收听报告-2023.05.23</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../../other/index.html"><strong aria-hidden="true">1.7.</strong> other</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../other/模拟飞行.html"><strong aria-hidden="true">1.7.1.</strong> 模拟飞行</a></li><li class="chapter-item expanded "><a href="../../../other/OPENAI-KEY.html"><strong aria-hidden="true">1.7.2.</strong> OPENAI-KEY</a></li><li class="chapter-item expanded "><a href="../../../other/未命名.html"><strong aria-hidden="true">1.7.3.</strong> 未命名</a></li><li class="chapter-item expanded "><a href="../../../other/写给v友的一段话.html"><strong aria-hidden="true">1.7.4.</strong> 写给v友的一段话</a></li></ol></li><li class="chapter-item expanded "><a href="../../../碎碎念/index.html"><strong aria-hidden="true">1.8.</strong> 碎碎念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../碎碎念/知乎精选.html"><strong aria-hidden="true">1.8.1.</strong> 知乎精选</a></li><li class="chapter-item expanded "><a href="../../../碎碎念/思源笔记本使用感想.html"><strong aria-hidden="true">1.8.2.</strong> 思源笔记本使用感想</a></li><li class="chapter-item expanded "><a href="../../../碎碎念/online-class.html"><strong aria-hidden="true">1.8.3.</strong> online-class</a></li><li class="chapter-item expanded "><a href="../../../碎碎念/奇思妙想.html"><strong aria-hidden="true">1.8.4.</strong> 奇思妙想</a></li><li class="chapter-item expanded "><a href="../../../碎碎念/手机卡分销类型.html"><strong aria-hidden="true">1.8.5.</strong> 手机卡分销类型</a></li><li class="chapter-item expanded "><a href="../../../碎碎念/freedom.html"><strong aria-hidden="true">1.8.6.</strong> freedom</a></li><li class="chapter-item expanded "><a href="../../../碎碎念/手机卡分销.html"><strong aria-hidden="true">1.8.7.</strong> 手机卡分销</a></li><li class="chapter-item expanded "><a href="../../../碎碎念/记录.html"><strong aria-hidden="true">1.8.8.</strong> 记录</a></li><li class="chapter-item expanded "><a href="../../../碎碎念/福芝talk.html"><strong aria-hidden="true">1.8.9.</strong> 福芝talk</a></li><li class="chapter-item expanded "><a href="../../../碎碎念/猫猫.html"><strong aria-hidden="true">1.8.10.</strong> 猫猫</a></li><li class="chapter-item expanded "><a href="../../../碎碎念/闲鱼文案模板.html"><strong aria-hidden="true">1.8.11.</strong> 闲鱼文案模板</a></li><li class="chapter-item expanded "><a href="../../../碎碎念/文案.html"><strong aria-hidden="true">1.8.12.</strong> 文案</a></li><li class="chapter-item expanded "><a href="../../../碎碎念/猫猫/index.html"><strong aria-hidden="true">1.8.13.</strong> 猫猫</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../碎碎念/猫猫/多多.html"><strong aria-hidden="true">1.8.13.1.</strong> 多多</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../../Study/index.html"><strong aria-hidden="true">1.9.</strong> Study</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../Study/Math/index.html"><strong aria-hidden="true">1.9.1.</strong> Math</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../Study/Math/第一讲-集合与常用逻辑用语.html"><strong aria-hidden="true">1.9.1.1.</strong> 第一讲-集合与常用逻辑用语</a></li><li class="chapter-item expanded "><a href="../../../Study/Math/函数.html"><strong aria-hidden="true">1.9.1.2.</strong> 函数</a></li></ol></li><li class="chapter-item expanded "><a href="../../../Study/Physical/index.html"><strong aria-hidden="true">1.9.2.</strong> Physical</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../Study/Physical/第六讲.html"><strong aria-hidden="true">1.9.2.1.</strong> 第六讲</a></li><li class="chapter-item expanded "><a href="../../../Study/Physical/第一讲-运动的描述.html"><strong aria-hidden="true">1.9.2.2.</strong> 第一讲-运动的描述</a></li><li class="chapter-item expanded "><a href="../../../Study/Physical/第5讲-力的正交分解.html"><strong aria-hidden="true">1.9.2.3.</strong> 第5讲-力的正交分解</a></li><li class="chapter-item expanded "><a href="../../../Study/Physical/第二讲-比例问题.html"><strong aria-hidden="true">1.9.2.4.</strong> 第二讲-比例问题</a></li><li class="chapter-item expanded "><a href="../../../Study/Physical/第7讲.html"><strong aria-hidden="true">1.9.2.5.</strong> 第7讲</a></li></ol></li><li class="chapter-item expanded "><a href="../../../Study/Chemistry/index.html"><strong aria-hidden="true">1.9.3.</strong> Chemistry</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../Study/Chemistry/第一讲-离子反应的基础概念.html"><strong aria-hidden="true">1.9.3.1.</strong> 第一讲-离子反应的基础概念</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../../English-Study/index.html"><strong aria-hidden="true">1.10.</strong> English-Study</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../English-Study/英语音标学习.html"><strong aria-hidden="true">1.10.1.</strong> 英语音标学习</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">WhaleFall Obsidian Notes</h1>

                    <div class="right-buttons">
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <hr />
<p>title: Python asyncio 异步协程百万并发
date: 2021-08-18 19:37:48
updated: 2021-08-18 19:37:48
categories: Python
tags: [Python, Coding]
description: Python 异步协程百万并发
thumbnail: http://oss.whaleluo.top/blog/img/Python-Asyncio-banner.png-picsmall
banner_img: http://oss.whaleluo.top/blog/img/Python-Asyncio-banner.png-picsmall
excerpt: Python 异步百万并发全文最详细笔记！！</p>
<hr />
<p><img src="http://oss.whaleluo.top/blog/img/Python-Asyncio-banner.png-picsmall" alt="banner" /></p>
<h1 id="python-asyncio-异步协程百万并发"><a class="header" href="#python-asyncio-异步协程百万并发">Python Asyncio 异步协程百万并发</a></h1>
<h2 id="协程coroutine"><a class="header" href="#协程coroutine">协程（coroutine）</a></h2>
<p>本质就是一个 <strong>函数</strong></p>
<h2 id="事件循环event_loop"><a class="header" href="#事件循环event_loop">事件循环——(event_loop)</a></h2>
<p><strong>协程函数</strong>，不是像普通函数那样直接调用运行的，必须<strong>添加到事件循环</strong>中，然后由<strong>事件循环</strong>去运行，单独运行协程函数是不会有结果的，看一个简单的例子：</p>
<pre><code class="language-python">import time
import asyncio
async def say_after_time(delay,what):
        await asyncio.sleep(delay)
        print(what)
 
async def main():
        print(f&quot;开始时间为： {time.time()}&quot;)
        await say_after_time(1,&quot;hello&quot;)
        await say_after_time(2,&quot;world&quot;)
        print(f&quot;结束时间为： {time.time()}&quot;)
 
loop=asyncio.get_event_loop()    #创建事件循环对象
# loop=asyncio.new_event_loop()   #与上面等价，创建新的事件循环
loop.run_until_complete(main())  #通过事件循环对象运行协程函数
loop.close()
</code></pre>
<p>在 python3.6 版本中，如果我们单独像执行普通函数那样执行一个协程函数，只会返回一个 coroutine 对象（python3.7）如下所示：</p>
<pre><code class="language-python">&gt;&gt;&gt; main()
&lt;coroutine object main at 0x1053bb7c8&gt;
</code></pre>
<h3 id="获取事件循环对象的几种方式"><a class="header" href="#获取事件循环对象的几种方式">获取事件循环对象的几种方式</a></h3>
<pre><code>loop = asyncio.get_event_loop()
</code></pre>
<p>它是 python3.7 中新添加的，<strong>获得一个事件循环</strong>，如果当前线程<strong>还没有事件循环</strong>，则<strong>创建一个新的事件循环 loop；</strong></p>
<h3 id="通过事件循环运行协程函数的两种方式"><a class="header" href="#通过事件循环运行协程函数的两种方式">通过事件循环运行协程函数的两种方式</a></h3>
<ol>
<li>
<p>创建事件循环对象 loop，即 <code>asyncio.get_event_loop()</code>，<strong>通过事件循环运行协程函数</strong>.</p>
</li>
<li>
<p>直接通过 <code>asyncio.run(function_name)</code> 运行<strong>协程函数。</strong></p>
<blockquote>
<p><strong>但是需要注意的是，首先 run 函数是 python3.7 版本新添加的，前面的版本是没有的；</strong></p>
</blockquote>
</li>
</ol>
<p>其次，这个 run 函数总是<strong>会创建一个新的事件循环并在 run 结束之后关闭事件循环</strong>，所以，如果在<strong>同一个线程</strong>中已经有了一个事件循环，则<strong>不能再使用这个函数</strong>了，因为<strong>同一个线程不能有两个事件循环</strong>，而且这个 run 函数<strong>不能同时运行两次</strong>，因为他已经创建一个了。即<strong>同一个线程中是不允许有多个事件循环 loop 的</strong>。</p>
<h2 id="task-任务"><a class="header" href="#task-任务">Task 任务</a></h2>
<h3 id="创建任务两种方法"><a class="header" href="#创建任务两种方法">创建任务（两种方法）</a></h3>
<ol>
<li>
<p><code>task = asyncio.create_task(coro())</code></p>
<blockquote>
<p><strong>这是 3.7 版本新添加的</strong>,<strong>可以传协程函数</strong></p>
</blockquote>
</li>
<li>
<p><code>task = asyncio.ensure_future(coro())</code></p>
</li>
<li>
<p>也可以：</p>
<pre><code class="language-python">loop.create_future()
loop.create_task(coro)
</code></pre>
</li>
</ol>
<h3 id="获取某一个任务的方法"><a class="header" href="#获取某一个任务的方法">获取某一个任务的方法</a></h3>
<ol>
<li>
<p><code>task=asyncio.current_task(loop=None)</code></p>
<blockquote>
<p>返回在某一个指定的 loop 中，<strong>当前正在运行的任务</strong>，<strong>如果没有任务正在运行，则返回 None</strong>；<br />
如果 loop 为 None，<strong>则默认为在当前的事件循环中获取</strong>.</p>
</blockquote>
</li>
<li>
<p><code>asyncio.all_tasks(loop=None)</code></p>
<blockquote>
<p>返回某一个<strong>loop 中还没有结束的任务</strong></p>
</blockquote>
</li>
</ol>
<h2 id="异步函数的结果获取"><a class="header" href="#异步函数的结果获取">异步函数的结果获取</a></h2>
<p>对于异步编程、异步函数而言，最重要的就是<strong>异步函数调用结束之后，获取异步函数的返回值</strong>，我们可以有以下几种方式<strong>来获取函数的返回值</strong>，第一是直接通过 <code>Task.result()</code> 来获取；第二种是<strong>绑定一个回调函数</strong>来获取，<strong>即函数执行完毕后调用一个函数来获取异步函数的返回值。</strong></p>
<ol>
<li>
<p>直接通过 <code>result</code> 来获取.</p>
<pre><code class="language-python">import asyncio
import time


async def hello1(a,b):
    print(&quot;Hello world 01 begin&quot;)
    await asyncio.sleep(3)  #模拟耗时任务3秒
    print(&quot;Hello again 01 end&quot;)
    return a+b

coroutine=hello1(10,5)
loop = asyncio.get_event_loop()                #第一步：创建事件循环
task = asyncio.ensure_future(coroutine)         #第二步:将多个协程函数包装成任务列表
loop.run_until_complete(task)                  #第三步：通过事件循环运行
print('-------------------------------------')
print(task.result())
loop.close() 

'''运行结果为
Hello world 01 begin
Hello again 01 end
-------------------------------------
15
'''
</code></pre>
</li>
<li>
<p>通过定义<strong>回调函数</strong>来获取</p>
</li>
</ol>
<pre><code class="language-python">import asyncio
import time
   
  async def hello1(a,b):
      print(&quot;Hello world 01 begin&quot;)
      await asyncio.sleep(3)  #模拟耗时任务3秒
      print(&quot;Hello again 01 end&quot;)
    return a+b
   
def callback(future):   #定义的回调函数,需要传future参数
    print(future.result())
 
loop = asyncio.get_event_loop()                #第一步：创建事件循环
task=asyncio.ensure_future(hello1(10,5))       #第二步:将多个协程函数包装成任务
task.add_done_callback(callback)                      #并被任务绑定一个回调函数，默认传入结果参数
 
loop.run_until_complete(task)                  #第三步：通过事件循环运行
loop.close()                                   #第四步：关闭事件循环
 
 
'''运行结果为：
Hello world 01 begin
Hello again 01 end
15
'''
</code></pre>
<blockquote>
<p><strong>注意：<strong>​<strong><strong>所谓的</strong></strong>​</strong>回调函数</strong>，就是指协程函数 coroutine<strong>执行结束时候会调用回调函数</strong>。并通过<strong>参数 future 获取协程执行的结果</strong>。我们创建的<strong>task 和回调里的 future 对象</strong>，实际上是<strong>同一个对象</strong>，因为 task 是 future 的子类。</p>
</blockquote>
<h2 id="asyncio-异步编程的基本模板"><a class="header" href="#asyncio-异步编程的基本模板">Asyncio 异步编程的基本模板</a></h2>
<h3 id="第一步构造事件循环"><a class="header" href="#第一步构造事件循环">第一步：构造事件循环</a></h3>
<ol>
<li>
<p><code>loop = asyncio.get_running_loop()</code></p>
<blockquote>
<p>返回（获取）在当前线程中<strong>正在运行的事件循环</strong>，如果没有正在运行的事件循环，则会显示错误；它是<strong>python3.7 中新添加的</strong></p>
</blockquote>
</li>
<li>
<p><code>loop = asyncio.get_event_loop()</code></p>
<blockquote>
<p><strong>获得一个事件循环</strong>，如果当前线程还没有事件循环，则<strong>创建一个新的事件循环 loop</strong>；</p>
</blockquote>
</li>
<li>
<p><code>loop=asyncio.set_event_loop(thread)</code></p>
<blockquote>
<p>设置一个事件循环<strong>为当前线程的事件循环</strong>；</p>
</blockquote>
</li>
<li>
<p><code>loop=asyncio.new_event_loop()</code></p>
<blockquote>
<p><strong>创建一个新的事件循环</strong></p>
</blockquote>
</li>
</ol>
<h3 id="第二步将一个或者是多个协程函数包装成任务-task"><a class="header" href="#第二步将一个或者是多个协程函数包装成任务-task">第二步：将一个或者是多个协程函数包装成任务 Task</a></h3>
<ol>
<li>
<p><code>task = asyncio.create_task(coro(参数列表))</code></p>
<blockquote>
<p><strong>这是 3.7 版本新添加的</strong></p>
</blockquote>
</li>
<li>
<p><code>task = asyncio.ensure_future(coro(参数列表))</code></p>
</li>
</ol>
<blockquote>
<p>需要注意的是，在使用 <code>Task.result()</code> 获取<strong>协程函数结果</strong>的时候，使用 <code>asyncio.create_task()</code> 却会显示错，但是使用 <code>asyncio.ensure_future</code> 却正确</p>
</blockquote>
<h3 id="第三步通过事件循环运行"><a class="header" href="#第三步通过事件循环运行">第三步：通过事件循环运行</a></h3>
<ol>
<li>
<p><code>loop.run_until_complete(asyncio.wait(tasks))</code></p>
<blockquote>
<p>通过 <code>asyncio.wait()</code>​<strong>整合多个 task</strong></p>
</blockquote>
</li>
<li>
<p><code>loop.run_until_complete(asyncio.gather(tasks))</code></p>
<blockquote>
<p>通过 <code>asyncio.gather()</code>​<strong>整合多个 task</strong></p>
</blockquote>
</li>
<li>
<p><code>loop.run_until_complete(task_1)</code></p>
<blockquote>
<p><strong>单个任务则不需要整合</strong></p>
</blockquote>
</li>
<li>
<p><del>loop.run_forever()</del></p>
<blockquote>
<p><del>但是这个方法在新版本已经取消，不再推荐使用，因为使用起来不简洁</del></p>
</blockquote>
</li>
</ol>
<h4 id="使用-gather-和-wait-整合-task-注册多个服务"><a class="header" href="#使用-gather-和-wait-整合-task-注册多个服务">使用 <code>gather</code> 和 <code>wait</code> 整合 Task 注册多个服务</a></h4>
<ol>
<li>
<h4 id="参数形式不一样"><a class="header" href="#参数形式不一样"><strong>参数形式不一样</strong></a></h4>
<p><strong>gather</strong>的参数为 coroutines_or_futures,即如这种形式：</p>
<pre><code class="language-python">tasks = asyncio.gather(*[task1,task2,task3])
tasks = asyncio.gather(task1,task2,task3)
loop.run_until_complete(tasks)
</code></pre>
<p><strong>wait</strong>的参数为<strong>列表或者集合</strong>的形式，如下:</p>
<pre><code class="language-python">tasks = asyncio.wait([task1,task2,task3])
loop.run_until_complete(tasks)
</code></pre>
</li>
<li>
<p><strong>返回的值不一样</strong></p>
<p><strong>gather 返回的是每一个任务运行的结果</strong>：</p>
<blockquote>
<h6 id="要以传入一个列表可变参数"><a class="header" href="#要以传入一个列表可变参数">要以传入一个列表可变参数</a></h6>
</blockquote>
<p><strong>可变参数允许在调用参数的时候传入多个参数,这些参数在调用时被自动组装为一个 tuple</strong></p>
<p><code>results = await asyncio.gather(*[tasks])</code></p>
<p><code>results = await asyncio.gather(task1,task2,task3)</code></p>
<p><strong>wait 返回 dones 是已经完成的任务，pending 是未完成的任务，都是集合类型</strong>：<br />
<code>done, pending = yield from asyncio.wait(fs)</code></p>
</li>
</ol>
<blockquote>
<p>简单来说：<strong>async.wait 会返回两个值:done 和 pending</strong>，done 为已完成的协程 Task，pending 为超时未完成的协程 Task，<strong>需通过 future.result 调用 Task 的 result。</strong></p>
<p>而 <code>async.gather</code> 返回的是<strong>已完成 Task 的 result</strong>。</p>
</blockquote>
<h3 id="第四步关闭事件循环"><a class="header" href="#第四步关闭事件循环">第四步：关闭事件循环</a></h3>
<pre><code class="language-python">loop.close()
# 以上示例都没有调用 loop.close，好像也没有什么问题。所以到底要不要调 loop.close 呢？
</code></pre>
<h2 id="注意"><a class="header" href="#注意">注意</a></h2>
<h3 id="协程阻塞问题"><a class="header" href="#协程阻塞问题">协程阻塞问题</a></h3>
<p><strong>异步方式依然会有阻塞的</strong>，当我们定义的很多个异步方法<strong>彼此之间有一来</strong>的时候，比如，我必须要等到函数 1 执行完毕，<strong>函数 2 需要用到函数 1 的返回值</strong>，就会造成<strong>阻塞</strong>，这也是异步编程的难点之一，如何合理配置这些资源，尽量<strong>减少函数之间的明确依赖</strong>，这是很重要的。</p>
<p><strong>结论</strong>：在有<strong>很多个异步方式</strong>的时候，一定要尽量避免这种<strong>异步函数的直接调用</strong>，这和同步是没什么区别的，一定要<strong>通过事件循环 loop</strong>，<strong>“让事件循环在各个异步函数之间不停游走”</strong>，这样才不会造成阻塞。</p>
<h2 id="代码片段"><a class="header" href="#代码片段">代码片段</a></h2>
<h3 id="使用-gather-同时注册多个任务实现并发"><a class="header" href="#使用-gather-同时注册多个任务实现并发">使用 Gather 同时注册多个任务，实现并发</a></h3>
<pre><code class="language-python">import asyncio
import time
async def hello1(a,b):
    print(&quot;Hello world 01 begin&quot;)
    await asyncio.sleep(3)  #模拟耗时任务3秒
    print(&quot;Hello again 01 end&quot;)
    return a+b
 
async def hello2(a,b):
    print(&quot;Hello world 02 begin&quot;)
    await asyncio.sleep(2)   #模拟耗时任务2秒
    print(&quot;Hello again 02 end&quot;)
    return a-b
 
async def hello3(a,b):
    print(&quot;Hello world 03 begin&quot;)
    await asyncio.sleep(4)   #模拟耗时任务4秒
    print(&quot;Hello again 03 end&quot;)
    return a*b
 
async def main():  #封装多任务的入口函数
    # 用列表表达式创建任务
    tasks = [
        asyncio.ensure_future(hello1(10,5))
        for i in range(10)
    ]
    results = await asyncio.gather(tasks)   
    for result in results:    #通过迭代获取函数的结果，每一个元素就是相对应的任务的返回值，顺序都没变
        print(result)
 
 
loop = asyncio.get_event_loop()               
loop.run_until_complete(main())
loop.close()
</code></pre>
<h3 id="异步--多线程"><a class="header" href="#异步--多线程">异步 + 多线程</a></h3>
<pre><code class="language-python">import asyncio 
import asyncio,time,threading
 
#需要执行的耗时异步任务
async def func(num):
    print(f'准备调用func,大约耗时{num}')
    await asyncio.sleep(num)
    print(f'耗时{num}之后,func函数运行结束')
 
#定义一个专门创建事件循环loop的函数，在另一个线程中启动它
def start_loop(loop):
    asyncio.set_event_loop(loop)
    # 启动事件循环并持续运行
    loop.run_forever()
 
#定义一个main函数
def main():
    coroutine1 = func(3)
    coroutine2 = func(2)
    coroutine3 = func(1)
 
    new_loop = asyncio.new_event_loop()                        #在当前线程下创建时间循环，（未启用），在start_loop里面启动它
    t = threading.Thread(target=start_loop,args=(new_loop,))   #通过当前线程开启新的线程去启动事件循环
    t.start()
 
    asyncio.run_coroutine_threadsafe(coroutine1,new_loop)  #这几个是关键，代表在新线程中事件循环不断“游走”执行
    asyncio.run_coroutine_threadsafe(coroutine2,new_loop)
    asyncio.run_coroutine_threadsafe(coroutine3,new_loop)
 
    for i in &quot;iloveu&quot;:
        print(str(i)+&quot;    &quot;)
 
if __name__ == &quot;__main__&quot;:
    main()
 
'''运行结果为：
i    准备调用func,大约耗时3
l    准备调用func,大约耗时2
o    准备调用func,大约耗时1
v
e
u
耗时1之后,func函数运行结束
耗时2之后,func函数运行结束
耗时3之后,func函数运行结束
'''
</code></pre>
<h3 id="httpx-aiohttp-之异步请求"><a class="header" href="#httpx-aiohttp-之异步请求">Httpx Aiohttp 之异步请求</a></h3>
<ul>
<li><strong>aiohttp 实现</strong></li>
</ul>
<pre><code class="language-python">import aiohttp
import asyncio
 
async def main():
    async with aiohttp.ClientSession() as client:
         async with client.get('http://httpbin.org/get') as resp:
              assert resp.status == 200
              html= await resp.text()
              print(html)
</code></pre>
<ul>
<li><strong>httpx 实现</strong></li>
</ul>
<pre><code class="language-python">async with httpx.AsyncClient() as client:
    resp = await client.get('http://httpbin.org/get')
    assert resp.status_code == 200
    html = resp.text
</code></pre>
<p>感觉总体上比较 <code>aiohttp</code> 写起来舒服多了**，少写很多异步代码。**</p>
<blockquote>
<p>之前使用 aiohttp 中的 resp.status 来获取状态码的时候写了 status_code，应该是使用 requests 习惯了吧，这下好了使用 httpx 不用担心这个写错的问题了。</p>
</blockquote>
<h1 id="深入理解-python-协程"><a class="header" href="#深入理解-python-协程">深入理解 Python 协程</a></h1>
<blockquote>
<p>参考: <a href="https://docs.python.org/zh-cn/3/library/asyncio.html">Python Asyncio 文档</a></p>
</blockquote>
<h2 id="协程"><a class="header" href="#协程">协程</a></h2>
<pre><code class="language-python">import asyncio
import time

# 协程函数返回的是一个协程对象
async def say_after(delay, what):
    await asyncio.sleep(delay)
    print(what)

async def main():
    print(f&quot;started at {time.strftime('%X')}&quot;)

    # 等待1s后再等待2s,不能做到并行运行
    await say_after(1, 'hello') # await 等待协程运行结束
    await say_after(2, 'world')

    print(f&quot;finished at {time.strftime('%X')}&quot;)

# asyncio.run() 函数用来运行最高层级的入口点 &quot;main()&quot; 函数
asyncio.run(main())
</code></pre>
<p><code>asyncio.create_task()</code> 函数用来运行作为 <code>asyncio</code> 任务的多个协程。</p>
<pre><code class="language-python">async def main():
    task1 = asyncio.create_task(
        say_after(1, 'hello'))

    task2 = asyncio.create_task(
        say_after(2, 'world'))

    print(f&quot;started at {time.strftime('%X')}&quot;)

    # 等待两个 task 完成,并行运行,只需要 2s.
    await task1
    await task2

    print(f&quot;finished at {time.strftime('%X')}&quot;)
</code></pre>
<h2 id="可等待对象"><a class="header" href="#可等待对象">可等待对象</a></h2>
<p>如果一个对象可以在 <code>await</code> 语句中使用，那么它就是 <strong>可等待</strong> 对象。</p>
<blockquote>
<p>可等待对象有三种主要类型: <strong>协程</strong>, <strong>任务</strong> 和 <strong>Future</strong>.</p>
</blockquote>
<h3 id="协程-1"><a class="header" href="#协程-1">协程</a></h3>
<p><strong>协程函数</strong>: 定义形式为 <code>async def</code> 的函数;<br />
<strong>协程对象</strong>: 调用 <strong>协程函数</strong> 所返回的对象。</p>
<pre><code class="language-python">import asyncio

# 协程函数
async def nested():
    return 42

async def main():
    # 调用协程函数返回的是协程对象(coroutine object),不能运行
    nested()

    # 协程通过 await 可等待的方式运行
    print(await nested())

asyncio.run(main())
</code></pre>
<h3 id="任务"><a class="header" href="#任务">任务</a></h3>
<p><strong>任务</strong>: 被用来 “并行的” 调度协程<br />
当一个协程通过 <code>asyncio.create_task(coro,*,name=None)</code> 等函数被封装为一个任务，该协程会被 <strong>自动调度</strong> 执行:</p>
<p>该任务会在 <code>get_running_loop()</code> 返回的循环中执行，如果当前线程没有在运行的循环则会引发 <strong>RuntimeError</strong>。</p>
<p><code>task.add_done_callback(func)</code> 设置任务完成的回调函数</p>
<pre><code class="language-python">import asyncio

async def nested():
    return 42

async def main():
    # 将协程封装成一个任务
    task = asyncio.create_task(nested())

    # 等待直到它完成
    await task

asyncio.run(main())
</code></pre>
<p><code>create_task</code> 会把可等待对象被封装为一个任务,该协程会被 <strong>自动调度</strong> 执行,所以不用 <code>await</code></p>
<pre><code class="language-python">import asyncio

async def wait(times: int):
    print(f&quot;等待{times}s&quot;)
    await asyncio.sleep(times)
    print(&quot;等待结束!&quot;)

async def main():
    # asyncio.wait_for(wait(3), 2) 不 await 就出错: RuntimeWarning: coroutine 'wait_for' was never awaited

    # create_task 会把可等待对象被封装为一个任务，该协程会被 **自动调度** 执行,
    # 所以不用 await 也能执行, await 了就表示等待这个任务执行完成!

    asyncio.create_task(asyncio.sleep(5))
    await asyncio.create_task(wait(100))  # 可用于堵塞事件循环,不退出

if __name__ == &quot;__main__&quot;:
    asyncio.run(main())
</code></pre>
<h3 id="futures"><a class="header" href="#futures">Futures</a></h3>
<p><code>Future</code> 是一种特殊的 低层级 可等待对象，表示一个异步操作的 <strong>最终结果</strong>。</p>
<p><strong>通常情况下没有必要在应用层级的代码中创建 ​</strong>​**<code>Future</code><strong>​</strong>​ 对象。**</p>
<h2 id="运行-asyncio-协程"><a class="header" href="#运行-asyncio-协程">运行 Asyncio 协程</a></h2>
<p><code>asyncio.run(coro, *, debug=False)</code><br />
执行 <code>coroutine coro</code> 并返回结果。<br />
此函数会运行传入的协程，负责管理 asyncio 事件循环，终结异步生成器，并关闭线程池。</p>
<p>当有其他 <code>asyncio</code> 事件循环在同一线程中运行时，此函数不能被调用。</p>
<p>如果 debug 为 True，事件循环将以调试模式运行。</p>
<p><strong>此函数总是会创建一个新的事件循环并在结束时关闭之。它应当被用作 asyncio 程序的主入口点，理想情况下应当只被调用一次。</strong></p>
<h2 id="并发运行任务"><a class="header" href="#并发运行任务">并发运行任务</a></h2>
<p><code>asyncio.gather(*aws, return_exceptions=False)</code></p>
<p>并发运行 aws 序列中的可等待对象。<br />
如果 aws 中的某个可等待对象为协程，它将自动被作为一个任务 (asyncio.create_task) 调度。</p>
<p>如果 <code>return_exceptions</code> 为 False (默认)，所引发的首个异常会立即传播给<strong>等待 gather() 的任务</strong>。aws 序列中的其他可等待对象 不会被取消 并将继续运行。</p>
<p>如果 return_exceptions 为 True，异常会和成功的结果一样处理，并聚合至结果列表。</p>
<pre><code class="language-python">import asyncio


async def factorial(name, number):
    &quot;&quot;&quot;计算 number! 阶乘并返回
    example: 3!=1*2*3
    &quot;&quot;&quot;
    # 测试如果出现异常
    if name == &quot;error&quot;:
        print(f&quot;任务名:{name} 出现异常!&quot;)
        raise EOFError
    f = 1
    for i in range(2, number + 1):
        print(f&quot;任务名:{name}:计算阶乘({number}), i={i}...&quot;)
        await asyncio.sleep(1)  # await 使协程等待,让出给其他协程使用
        f *= i
    print(f&quot;任务名{name}: {number}! = {f}&quot;)
    return f

async def main():
    # gather 一起执行可等待对象,并按调用顺序返回
    # gather 会阻塞直到 gather 中的所有可等待对象完成
    print(&quot;async start!&quot;)
    L = await asyncio.gather(
        factorial(&quot;error&quot;, None),
        factorial(&quot;A&quot;, 2),
        factorial(&quot;B&quot;, 3),
        factorial(&quot;C&quot;, 4), return_exceptions=False
    )
    # 当 return_exceptions 为 False 时引发的首个异常会传播给 gather 可等待对象列表的任务
    # 整个程序停摆,未执行完的可等待对象也会取消

    # 当 return_exceptions 为 True，异常会和成功的结果一样处理，并聚合至结果列表。
    # 并不会引发整个程序的异常
    print(f&quot;async result:{L}&quot;)
    print(&quot;async end....&quot;)
asyncio.run(main())
</code></pre>
<p>如果 gather 本身被取消，则无论 <code>return_exceptions</code> 取值为何，消息都会被传播。</p>
<pre><code class="language-python">if name == &quot;error&quot;:
    print(f&quot;任务名:{name} 出现异常!&quot;)
    gather_waiting_object.cancel()  # 取消 gather
# 错误: asyncio.exceptions.CancelledError
</code></pre>
<h2 id="超时"><a class="header" href="#超时">超时</a></h2>
<p>协程 (可等待对象) <code>asyncio.wait_for(aw, timeout)</code></p>
<p>等待 aw 可等待对象 完成，指定 <code>timeout</code> 秒数后超时。<br />
如果 aw 是一个协程，它将自动被作为任务 ((asyncio.create_task)) 调度。<br />
<code>timeout</code> 可以为 None，也可以为 float 或 int 型数值表示的等待秒数。如果 timeout 为 None，则等待直到完成。</p>
<p>如果发生超时，任务将取消并引发 asyncio.TimeoutError.</p>
<p>要避免任务 取消，可以加上 shield()。</p>
<p>此函数将等待直到 Future 确实被取消，所以总等待时间可能超过 timeout。 如果在取消期间发生了异常，异常将会被传播。</p>
<p>如果等待被取消，则 aw 指定的对象也会被取消。</p>
<h2 id="简单等待"><a class="header" href="#简单等待">简单等待</a></h2>
<p>coroutine <code>asyncio.wait(aws, *, timeout=None, return_when=ALL_COMPLETED)</code></p>
<p>并发地运行 aws 可迭代对象中的 <code>可等待对象</code>(不能直接传入协程对象需要转换为 Task) 并进入阻塞状态直到满足 return_when 所指定的条件。</p>
<p>return_when 指定此函数应在何时返回:</p>
<ul>
<li>FIRST_COMPLETED: 在第一个可等待对象运行完毕后返回</li>
<li>FIRST_EXCEPTION: 在任意可等待对象抛出异常后返回,不会结束其他可等待对象,并在程序结束最后抛出异常</li>
<li>ALL_COMPLETED(默认): 在所有可等待对象执行完毕后返回</li>
</ul>
<p>aws 可迭代对象必须不为空。 返回两个 Task/Future 集合: (done, pending)</p>
<p><code>(done, panding)</code>: done: 已完成的协程;panding: 正在等待的协程; 支持通过 <code>if</code> 判断</p>
<pre><code class="language-python">import asyncio


async def wait(name, times: int):
    if name == &quot;A&quot;:
        raise EOFError
    print(f&quot;{name}等待{times}s&quot;)
    await asyncio.sleep(times)
    print(f&quot;{name}等待结束!&quot;)
    return times


async def main():

    task, pending = await asyncio.wait(
        (
            wait(&quot;A&quot;, 3),
            wait(&quot;B&quot;, 2),
            wait(&quot;C&quot;, 1)
        ), return_when=asyncio.FIRST_COMPLETED
    )
    print(&quot;已完成:&quot;, task, &quot;\n等待:&quot;, pending)
    await asyncio.sleep(5)
    print(&quot;抛出异常&quot;)

if __name__ == &quot;__main__&quot;:
    asyncio.run(main())
</code></pre>
<p>(和男朋友出去喝奶茶了,未完待续,可能会继续写一些应用场景,或者和 Golang 的 Goruntine 进行对比)……..<br />
2022/8/24 18:34</p>
<p>所谓「异步 IO」，就是你发起一个 IO 操作，却不用等它结束，你可以继续做其他事情，当它结束时，你会得到通知。</p>
<p>Asyncio 是并发（concurrency）的一种方式。对 Python 来说，并发还可以通过线程（threading）和多进程（multiprocessing）来实现。</p>
<p>Asyncio 并不能带来真正的并行（parallelism）。当然，因为 GIL（全局解释器锁）的存在，Python 的多线程也不能带来真正的并行。</p>
<p>可交给 asyncio 执行的任务，称为协程（coroutine）。一个协程可以放弃执行，把机会让给其它协程（即 <code>yield from</code> 或 <code>await</code>）。`</p>
<h2 id="定义协程"><a class="header" href="#定义协程">定义协程</a></h2>
<p>协程的定义，需要使用 <code>async def</code> 语句。</p>
<p>async def do_some_work(x): pass</p>
<p><code>do_some_work</code> 便是一个协程。<br />
准确来说，<code>do_some_work</code> 是一个协程函数，可以通过 <code>asyncio.iscoroutinefunction</code> 来验证：</p>
<p>print(asyncio.iscoroutinefunction(do_some_work)) # True</p>
<p>这个协程什么都没做，我们让它睡眠几秒，以模拟实际的工作量 ：</p>
<p>async def do_some_work(x):<br />
print(&quot;Waiting &quot; + str(x))<br />
await asyncio.sleep(x)</p>
<p>在解释 <code>await</code> 之前，有必要说明一下协程可以做哪些事。协程可以：</p>
<ul>
<li>等待一个 future 结束</li>
<li>等待另一个协程（产生一个结果，或引发一个异常）</li>
<li>产生一个结果给正在等它的协程</li>
<li>引发一个异常给正在等它的协程</li>
</ul>
<p><code>asyncio.sleep</code> 也是一个协程，所以 <code>await asyncio.sleep(x)</code> 就是等待另一个协程。可参见 <code>asyncio.sleep</code> 的文档：</p>
<p>sleep(delay, result=None, *, loop=None)<br />
Coroutine that completes after a given time (in seconds).</p>
<h2 id="运行协程"><a class="header" href="#运行协程">运行协程</a></h2>
<p>调用协程函数，协程并不会开始运行，只是返回一个协程对象，可以通过 <code>asyncio.iscoroutine</code> 来验证：</p>
<p>print(asyncio.iscoroutine(do_some_work(3))) # True</p>
<p>此处还会引发一条警告：</p>
<p>async1.py:16: RuntimeWarning: coroutine 'do_some_work' was never awaited<br />
print(asyncio.iscoroutine(do_some_work(3)))</p>
<p>要让这个协程对象运行的话，有两种方式：</p>
<ul>
<li>在另一个已经运行的协程中用 <code>await</code> 等待它</li>
<li>通过 <code>ensure_future</code> 函数计划它的执行</li>
</ul>
<p>简单来说，只有 loop 运行了，协程才可能运行。<br />
下面先拿到当前线程缺省的 loop ，然后把协程对象交给 <code>loop.run_until_complete</code>，协程对象随后会在 loop 里得到运行。</p>
<p>loop = asyncio.get_event_loop()<br />
loop.run_until_complete(do_some_work(3))</p>
<p><code>run_until_complete</code> 是一个阻塞（blocking）调用，直到协程运行结束，它才返回。这一点从函数名不难看出。<br />
<code>run_until_complete</code> 的参数是一个 future，但是我们这里传给它的却是协程对象，之所以能这样，是因为它在内部做了检查，通过 <code>ensure_future</code> 函数把协程对象包装（wrap）成了 future。所以，我们可以写得更明显一些：</p>
<p>loop.run_until_complete(asyncio.ensure_future(do_some_work(3)))</p>
<p>完整代码：</p>
<p>import asyncio</p>
<p>async def do_some_work(x):<br />
print(&quot;Waiting &quot; + str(x))<br />
await asyncio.sleep(x)</p>
<p>loop = asyncio.get_event_loop()<br />
loop.run_until_complete(do_some_work(3))</p>
<p>运行结果：</p>
<p>Waiting 3<br />
&lt;三秒钟后程序结束&gt;</p>
<h2 id="回调"><a class="header" href="#回调">回调</a></h2>
<p>假如协程是一个 IO 的读操作，等它读完数据后，我们希望得到通知，以便下一步数据的处理。这一需求可以通过往 future 添加回调来实现。</p>
<p>def done_callback(futu):<br />
print('Done')</p>
<p>futu = asyncio.ensure_future(do_some_work(3))<br />
futu.add_done_callback(done_callback)</p>
<p>loop.run_until_complete(futu)</p>
<h2 id="多个协程"><a class="header" href="#多个协程">多个协程</a></h2>
<p>实际项目中，往往有多个协程，同时在一个 loop 里运行。为了把多个协程交给 loop，需要借助 <code>asyncio.gather</code> 函数。</p>
<p>loop.run_until_complete(asyncio.gather(do_some_work(1), do_some_work(3)))</p>
<p>或者先把协程存在列表里：</p>
<p>coros = [do_some_work(1), do_some_work(3)]<br />
loop.run_until_complete(asyncio.gather(*coros))</p>
<p>运行结果：</p>
<p>Waiting 3<br />
Waiting 1<br />
&lt;等待三秒钟&gt;<br />
Done</p>
<p>这两个协程是并发运行的，所以等待的时间不是 1 + 3 = 4 秒，而是以耗时较长的那个协程为准。</p>
<p>参考函数 <code>gather</code> 的文档：</p>
<blockquote>
<p>gather(*coros_or_futures, loop=None, return_exceptions=False)<br />
Return a future aggregating results from the given coroutines or futures.</p>
</blockquote>
<p>发现也可以传 futures 给它：</p>
<p>futus = [asyncio.ensure_future(do_some_work(1)),<br />
asyncio.ensure_future(do_some_work(3))]</p>
<p>loop.run_until_complete(asyncio.gather(*futus))</p>
<p><code>gather</code> 起聚合的作用，把多个 futures 包装成单个 future，因为 <code>loop.run_until_complete</code> 只接受单个 future。</p>
<h2 id="run_until_complete-和-run_forever"><a class="header" href="#run_until_complete-和-run_forever">run_until_complete 和 run_forever</a></h2>
<p>我们一直通过 <code>run_until_complete</code> 来运行 loop ，等到 future 完成，<code>run_until_complete</code> 也就返回了。</p>
<pre><code class="language-python">async def do_some_work(x):
    print('Waiting ' + str(x))
    await asyncio.sleep(x)
    print('Done')

loop = asyncio.get_event_loop()

coro = do_some_work(3)
loop.run_until_complete(coro)
</code></pre>
<p>输出：</p>
<pre><code class="language-test">Waiting 3
&lt;等待三秒钟&gt;
Done
&lt;程序退出&gt;
</code></pre>
<p>现在改用 <code>run_forever</code>：</p>
<pre><code class="language-python">async def do_some_work(x):  
    print('Waiting ' + str(x))  
    await asyncio.sleep(x)  
    print('Done')

loop = asyncio.get_event_loop()

coro = do_some_work(3)  
asyncio.ensure_future(coro)

loop.run_forever()
</code></pre>
<p>输出：</p>
<pre><code class="language-text">Waiting 3  
&lt;等待三秒钟&gt;  
Done  
&lt;程序没有退出&gt;
</code></pre>
<p>三秒钟过后，future 结束，但是程序并不会退出。<code>run_forever</code> 会一直运行，直到 <code>stop</code> 被调用，但是你不能像下面这样调 <code>stop</code>：</p>
<p>loop.run_forever()<br />
loop.stop()</p>
<p><code>run_forever</code> 不返回，<code>stop</code> 永远也不会被调用。所以，只能在协程中调 <code>stop</code>：</p>
<pre><code class="language-python">async def do_some_work(loop, x):  
    print('Waiting ' + str(x))  
    await asyncio.sleep(x)  
    print('Done')  
    loop.stop()
</code></pre>
<p>这样并非没有问题，假如有多个协程在 loop 里运行：</p>
<pre><code class="language-python">asyncio.ensure_future(do_some_work(loop, 1))  
asyncio.ensure_future(do_some_work(loop, 3))

loop.run_forever()
</code></pre>
<p>第二个协程没结束，loop 就停止了——被先结束的那个协程给停掉的。<br />
要解决这个问题，可以用 <code>gather</code> 把多个协程合并成一个 future，并添加回调，然后在回调里再去停止 loop。</p>
<pre><code class="language-python">async def do_some_work(loop, x):  
    print('Waiting ' + str(x))  
    await asyncio.sleep(x)  
    print('Done')

def done_callback(loop, futu):  
    loop.stop()

loop = asyncio.get_event_loop()

futus = asyncio.gather(do_some_work(loop, 1), do_some_work(loop, 3))  
futus.add_done_callback(functools.partial(done_callback, loop))

loop.run_forever()
</code></pre>
<p>其实这基本上就是 <code>run_until_complete</code> 的实现了，<code>run_until_complete</code> 在内部也是调用 <code>run_forever</code>。</p>
<h2 id="close-loop"><a class="header" href="#close-loop">Close Loop?</a></h2>
<p>以上示例都没有调用 <code>loop.close</code>，好像也没有什么问题。所以到底要不要调 <code>loop.close</code> 呢？<br />
简单来说，loop 只要不关闭，就还可以再运行。：</p>
<pre><code class="language-python">loop.run_until_complete(do_some_work(loop, 1))  
loop.run_until_complete(do_some_work(loop, 3))  
loop.close()
</code></pre>
<p>但是如果关闭了，就不能再运行了：</p>
<pre><code class="language-python">loop.run_until_complete(do_some_work(loop, 1))  
loop.close()  
loop.run_until_complete(do_some_work(loop, 3)) # 此处异常
</code></pre>
<p>建议调用 <code>loop.close</code>，以彻底清理 loop 对象防止误用。</p>
<h2 id="gather-vs-wait"><a class="header" href="#gather-vs-wait">Gather vs. wait</a></h2>
<p><code>asyncio.gather</code> 和 <code>asyncio.wait</code> 功能相似。</p>
<pre><code class="language-python">coros = [do_some_work(loop, 1), do_some_work(loop, 3)]  
loop.run_until_complete(asyncio.wait(coros))
</code></pre>
<p>具体差别可请参见 StackOverflow 的讨论：<a href="https://stackoverflow.com/questions/42231161/asyncio-gather-vs-asyncio-wait">python - Asyncio.gather vs asyncio.wait - Stack Overflow</a>)。</p>
<p>抓住异步的异常：</p>
<pre><code class="language-python">results = await asyncio.gather(*coros, return_exceptions=True)
for result_or_exc in results:
    if isinstance(result_or_exc, Exception):
        print(&quot;I caught:&quot;, repr(result_or_exc))
</code></pre>
<h2 id="timer"><a class="header" href="#timer">Timer</a></h2>
<p>C++ Boost.Asio 提供了 IO 对象 timer，但是 Python 并没有原生支持 timer，不过可以用 <code>asyncio.sleep</code> 模拟。</p>
<pre><code class="language-python">async def timer(x, cb):  
    futu = asyncio.ensure_future(asyncio.sleep(x))  
    futu.add_done_callback(cb)  
    await futu

t = timer(3, lambda futu: print('Done'))  
loop.run_until_complete(t)
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../博客文章/_posts/Python/Python-Generator-Iterator-decorater.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../../博客文章/_posts/Python/Python-Tkinter-GUI.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../博客文章/_posts/Python/Python-Generator-Iterator-decorater.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../../博客文章/_posts/Python/Python-Tkinter-GUI.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../../elasticlunr.min.js"></script>
        <script src="../../../mark.min.js"></script>
        <script src="../../../searcher.js"></script>

        <script src="../../../clipboard.min.js"></script>
        <script src="../../../highlight.js"></script>
        <script src="../../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
